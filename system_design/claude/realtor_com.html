<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>System Design: Realtor.com</title>
<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<style>
  :root { --bg: #0d1117; --card: #161b22; --border: #30363d; --text: #e6edf3; --dim: #8b949e; --accent: #58a6ff; --green: #3fb950; --orange: #d29922; --red: #f85149; --purple: #bc8cff; }
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body { background: var(--bg); color: var(--text); font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif; line-height: 1.7; padding: 2rem; max-width: 1200px; margin: 0 auto; }
  h1 { font-size: 2.4rem; border-bottom: 2px solid var(--accent); padding-bottom: .5rem; margin-bottom: 1.5rem; }
  h2 { font-size: 1.8rem; color: var(--accent); margin-top: 2.5rem; margin-bottom: 1rem; border-left: 4px solid var(--accent); padding-left: .75rem; }
  h3 { font-size: 1.35rem; color: var(--green); margin-top: 1.8rem; margin-bottom: .6rem; }
  h4 { font-size: 1.1rem; color: var(--orange); margin-top: 1.2rem; margin-bottom: .4rem; }
  p, li { color: var(--text); margin-bottom: .5rem; }
  ul, ol { padding-left: 1.5rem; margin-bottom: 1rem; }
  li { margin-bottom: .35rem; }
  .card { background: var(--card); border: 1px solid var(--border); border-radius: 8px; padding: 1.5rem; margin: 1rem 0; }
  .card-accent { border-left: 4px solid var(--accent); }
  .card-green { border-left: 4px solid var(--green); }
  .card-orange { border-left: 4px solid var(--orange); }
  .card-red { border-left: 4px solid var(--red); }
  .card-purple { border-left: 4px solid var(--purple); }
  table { width: 100%; border-collapse: collapse; margin: 1rem 0; }
  th, td { border: 1px solid var(--border); padding: .6rem .8rem; text-align: left; }
  th { background: #1c2333; color: var(--accent); }
  td { background: var(--card); }
  code { background: #1c2333; padding: 2px 6px; border-radius: 4px; font-size: .9em; color: var(--orange); }
  pre { background: #1c2333; padding: 1rem; border-radius: 8px; overflow-x: auto; margin: 1rem 0; }
  pre code { padding: 0; background: none; }
  .mermaid {
    background: linear-gradient(135deg, #0d1117 0%, #131a24 50%, #0d1117 100%);
    border: 1px solid #1e3a5f;
    border-radius: 12px;
    padding: 2rem 1.5rem;
    margin: 1.5rem 0;
    text-align: center;
    box-shadow: 0 4px 24px rgba(0, 0, 0, 0.4), inset 0 1px 0 rgba(88, 166, 255, 0.08);
    position: relative;
    overflow: hidden;
  }
  .mermaid::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 1px;
    background: linear-gradient(90deg, transparent, rgba(88, 166, 255, 0.3), transparent);
  }
  .tag { display: inline-block; padding: 2px 10px; border-radius: 12px; font-size: .8rem; font-weight: 600; margin-right: .3rem; }
  .tag-sql { background: #1f3d1f; color: var(--green); }
  .tag-nosql { background: #3d2f1f; color: var(--orange); }
  .tag-pk { background: #1f2d3d; color: var(--accent); }
  .tag-fk { background: #3d1f3d; color: var(--purple); }
  .tag-idx { background: #3d1f1f; color: var(--red); }
  hr { border: none; border-top: 1px solid var(--border); margin: 2rem 0; }
  .toc { background: var(--card); border: 1px solid var(--border); border-radius: 8px; padding: 1.5rem 2rem; margin: 1.5rem 0; }
  .toc a { color: var(--accent); text-decoration: none; }
  .toc a:hover { text-decoration: underline; }
  .toc li { margin-bottom: .25rem; }
</style>
</head>
<body>

<h1>üè† System Design: Realtor.com</h1>
<p>A large-scale real estate listing and search platform enabling buyers, renters, sellers, and agents to list, discover, and transact on residential and commercial properties.</p>

<div class="toc">
<h3 style="margin-top:0;">Table of Contents</h3>
<ol>
  <li><a href="#fr">Functional Requirements</a></li>
  <li><a href="#nfr">Non-Functional Requirements</a></li>
  <li><a href="#flow1">Flow 1 ‚Äî Listing a Property</a></li>
  <li><a href="#flow2">Flow 2 ‚Äî Searching for Properties</a></li>
  <li><a href="#flow3">Flow 3 ‚Äî Viewing Property Details</a></li>
  <li><a href="#flow4">Flow 4 ‚Äî Saving Properties &amp; Saved-Search Notifications</a></li>
  <li><a href="#flow5">Flow 5 ‚Äî Contacting an Agent</a></li>
  <li><a href="#overall">Overall Combined Diagram</a></li>
  <li><a href="#schema">Database Schema</a></li>
  <li><a href="#cdn-cache">CDN &amp; Caching Deep Dive</a></li>
  <li><a href="#scaling">Scaling Considerations</a></li>
  <li><a href="#tradeoffs">Tradeoffs &amp; Deep Dives</a></li>
  <li><a href="#alternatives">Alternative Approaches</a></li>
  <li><a href="#additional">Additional Information</a></li>
  <li><a href="#vendors">Vendor Suggestions</a></li>
</ol>
</div>

<!-- ============================================================ -->
<h2 id="fr">1. Functional Requirements</h2>
<!-- ============================================================ -->
<div class="card card-accent">
<ol>
  <li><strong>Property Listing Management</strong> ‚Äî Agents/sellers can create, update, and deactivate property listings with details (address, price, beds, baths, sqft, description, listing type: sale/rent, property type, year built, lot size, HOA, etc.).</li>
  <li><strong>Media Upload</strong> ‚Äî Upload and manage photos, virtual-tour videos, and floor plans per listing.</li>
  <li><strong>Property Search</strong> ‚Äî Users can search by location (city, zip, address, neighborhood), price range, bedrooms, bathrooms, square footage, property type, listing type (buy/rent), and more.</li>
  <li><strong>Map-Based Search</strong> ‚Äî Users can drag/zoom a map to search within a visible bounding box; results update in real time.</li>
  <li><strong>Property Detail View</strong> ‚Äî Display full listing information including photo gallery, price history, tax history, neighborhood stats, nearby schools, walk score, and estimated mortgage.</li>
  <li><strong>User Accounts</strong> ‚Äî Registration, login, profile management for buyers, renters, sellers, and agents.</li>
  <li><strong>Save / Favorite Properties</strong> ‚Äî Authenticated users can save listings to their favorites list.</li>
  <li><strong>Saved Searches &amp; Alerts</strong> ‚Äî Users can save search criteria and receive notifications (email/push) when new or updated listings match.</li>
  <li><strong>Contact Agent</strong> ‚Äî Users can send an inquiry to the listing agent from the property detail page.</li>
  <li><strong>Price History &amp; Estimates</strong> ‚Äî Display historical sale/tax data and algorithmic property value estimates (Zestimate-like).</li>
</ol>
</div>

<!-- ============================================================ -->
<h2 id="nfr">2. Non-Functional Requirements</h2>
<!-- ============================================================ -->
<div class="card card-green">
<ol>
  <li><strong>Low Latency</strong> ‚Äî Search results returned in &lt; 200 ms p99; property detail pages load in &lt; 300 ms p99.</li>
  <li><strong>High Availability</strong> ‚Äî 99.95% uptime; the platform is the primary source of truth during home-buying decisions.</li>
  <li><strong>Scalability</strong> ‚Äî Support ~5 million active listings, ~100 million monthly unique visitors, peak ~50K search requests/second.</li>
  <li><strong>Eventual Consistency</strong> ‚Äî Acceptable for search index propagation (new listings appear in search within seconds, not instantly). Strong consistency for listing writes and user data.</li>
  <li><strong>Media Performance</strong> ‚Äî Images served via CDN with responsive resizing; median image load &lt; 100 ms.</li>
  <li><strong>Geo-Query Performance</strong> ‚Äî Bounding-box and radius queries must be efficient at scale (geospatial indexing).</li>
  <li><strong>Data Durability</strong> ‚Äî Zero data loss on listings or user data.</li>
  <li><strong>Security</strong> ‚Äî HTTPS everywhere, authentication via OAuth 2.0 / JWT, PII encryption at rest.</li>
</ol>
</div>

<!-- ============================================================ -->
<h2 id="flow1">3. Flow 1 ‚Äî Listing a Property</h2>
<!-- ============================================================ -->

<div class="mermaid">
flowchart LR
    A["üßë‚Äçüíº Agent / Seller\n(Web or Mobile Client)"] -->|"HTTP POST\n/api/listings"| B["‚öñÔ∏è Load Balancer"]
    B --> C["üîÄ API Gateway"]
    C --> D["üèóÔ∏è Listing Service"]
    D -->|"Write listing record"| E[("üóÑÔ∏è Listing DB\n(SQL)")]
    D -->|"Upload media URLs"| F["üì∑ Media Service"]
    F -->|"Store originals"| G[("üì¶ Object Storage")]
    F -->|"Resize & optimize"| G
    G -->|"Invalidate / warm"| H["üåê CDN"]
    D -->|"Publish listing.created event"| I["üì® Message Queue"]
    I -->|"Consume"| J["üîç Search Indexer"]
    J -->|"Upsert document"| K[("üîé Search Index")]
    I -->|"Consume"| L["üîî Notification Service"]
    L -->|"Match saved searches"| M[("üóÑÔ∏è Saved Search DB")]
    L -->|"Send email / push"| N["üì© Notification Channel\n(Email / Push)"]
</div>

<h3>Examples</h3>
<div class="card card-accent">
<h4>Example 1 ‚Äî New Listing (Happy Path)</h4>
<p>Agent Jane logs into the agent portal and clicks "Create Listing." She fills out the property form (123 Oak St, $450,000, 3 bed / 2 bath, 1,800 sqft, Single Family) and uploads 15 photos. She clicks "Publish."</p>
<p>The client sends an <code>HTTP POST /api/listings</code> with the listing payload and pre-signed media upload URLs. The <strong>Load Balancer</strong> routes the request to the <strong>API Gateway</strong>, which authenticates Jane's JWT and forwards to the <strong>Listing Service</strong>. The Listing Service validates the data, writes a new row to the <strong>Listing DB (SQL)</strong> with status <code>ACTIVE</code>, and calls the <strong>Media Service</strong> to finalize the uploaded images in <strong>Object Storage</strong>. The Media Service generates responsive thumbnails (200px, 600px, 1200px) and stores them. The CDN edge cache is warmed for the listing's primary image.</p>
<p>The Listing Service then publishes a <code>listing.created</code> event onto the <strong>Message Queue</strong>. The <strong>Search Indexer</strong> consumes this event and upserts the listing into the <strong>Search Index</strong> (making it discoverable). Concurrently, the <strong>Notification Service</strong> consumes the same event, queries the <strong>Saved Search DB</strong> for any users whose saved-search criteria match (e.g., "3-bed homes in Oak neighborhood under $500K"), and fires email/push notifications to those users.</p>

<h4>Example 2 ‚Äî Listing Update (Price Reduction)</h4>
<p>Agent Jane reduces the price from $450,000 to $425,000. The client sends <code>HTTP PATCH /api/listings/{listingId}</code> with <code>{"price": 425000}</code>. The Listing Service updates the row, appends a record to the <strong>price_history</strong> table, and publishes a <code>listing.updated</code> event. The Search Indexer updates the search document. The Notification Service detects a price drop and notifies any users who saved this specific property.</p>

<h4>Example 3 ‚Äî Listing with Validation Errors</h4>
<p>Agent Bob tries to create a listing without a required address field. The Listing Service returns <code>HTTP 400 Bad Request</code> with a validation error message. No database write or event publishing occurs.</p>
</div>

<h3>Component Deep Dive ‚Äî Flow 1</h3>

<div class="card card-purple">
<h4>Load Balancer</h4>
<p>Layer 7 (HTTP) load balancer distributing requests across API Gateway instances using round-robin with health checks. Terminates TLS.</p>

<h4>API Gateway</h4>
<p>Handles authentication (JWT validation), rate limiting, and request routing. Routes <code>/api/listings/*</code> traffic to the Listing Service.</p>

<h4>Listing Service</h4>
<table>
<tr><th>Protocol</th><th>Method</th><th>Endpoint</th><th>Input</th><th>Output</th></tr>
<tr><td>HTTP/REST</td><td>POST</td><td><code>/api/listings</code></td><td>JSON body: address, price, beds, baths, sqft, description, type, media_urls[], agent_id</td><td>201 Created ‚Äî <code>{ listing_id, status: "ACTIVE" }</code></td></tr>
<tr><td>HTTP/REST</td><td>PATCH</td><td><code>/api/listings/{id}</code></td><td>JSON body: partial fields to update</td><td>200 OK ‚Äî updated listing object</td></tr>
<tr><td>HTTP/REST</td><td>DELETE</td><td><code>/api/listings/{id}</code></td><td>Path param: listing_id</td><td>200 OK ‚Äî <code>{ status: "DEACTIVATED" }</code> (soft delete)</td></tr>
</table>

<h4>Media Service</h4>
<table>
<tr><th>Protocol</th><th>Method</th><th>Endpoint</th><th>Input</th><th>Output</th></tr>
<tr><td>HTTP/REST</td><td>POST</td><td><code>/api/media/presign</code></td><td>JSON: listing_id, file_names[], content_types[]</td><td>200 OK ‚Äî array of pre-signed upload URLs</td></tr>
<tr><td>HTTP/REST</td><td>POST</td><td><code>/api/media/finalize</code></td><td>JSON: listing_id, media_keys[]</td><td>200 OK ‚Äî array of CDN URLs (multiple sizes)</td></tr>
</table>
<p>The Media Service uses <strong>pre-signed URLs</strong> so clients upload directly to Object Storage, bypassing the service for the heavy data transfer. After upload, the service is called to trigger thumbnail generation (done asynchronously via an internal worker consuming from a processing queue).</p>

<h4>Listing DB (SQL)</h4>
<p>Relational database storing authoritative listing data. SQL is chosen for strong consistency, ACID transactions (e.g., listing + price_history in one transaction), and complex relational queries (joins across agent, office, listing).</p>

<h4>Object Storage</h4>
<p>Stores raw photos, resized thumbnails, virtual tour videos, and floor plan PDFs. Immutable, versioned, highly durable.</p>

<h4>CDN</h4>
<p>Caches and serves media globally. Images are served with cache headers (max-age 30 days). See <a href="#cdn-cache">CDN &amp; Caching Deep Dive</a>.</p>

<h4>Message Queue</h4>
<p>Decouples listing writes from downstream consumers (Search Indexer, Notification Service). Guarantees at-least-once delivery. Topic: <code>listing-events</code> with event types: <code>listing.created</code>, <code>listing.updated</code>, <code>listing.deactivated</code>. Two consumer groups subscribe independently. See <a href="#mq-deepdive">Message Queue Deep Dive</a>.</p>

<h4>Search Indexer</h4>
<p>Worker that consumes listing events and upserts/deletes documents in the Search Index. Performs field mapping (e.g., geocoding address ‚Üí lat/lng if not already provided).</p>

<h4>Search Index</h4>
<p>Full-text + geospatial search engine. Maintains inverted index on text fields and an R-tree / geohash index on coordinates. See <a href="#schema">Schema</a> section.</p>

<h4>Notification Service</h4>
<p>Consumes listing events, evaluates them against saved searches, and dispatches alerts. See <a href="#flow4">Flow 4</a>.</p>
</div>

<!-- ============================================================ -->
<h2 id="flow2">4. Flow 2 ‚Äî Searching for Properties</h2>
<!-- ============================================================ -->

<div class="mermaid">
flowchart LR
    A["üë§ User\n(Web / Mobile)"] -->|"HTTP GET\n/api/search?..."| B["‚öñÔ∏è Load Balancer"]
    B --> C["üîÄ API Gateway"]
    C --> D["üîç Search Service"]
    D -->|"Check cache"| E["‚ö° Cache\n(In-Memory)"]
    E -->|"Cache HIT"| D
    D -->|"Cache MISS\nQuery"| F[("üîé Search Index")]
    F -->|"Return ranked doc IDs\n+ summary fields"| D
    D -->|"Store results"| E
    D -->|"Return JSON"| A
</div>

<h3>Examples</h3>
<div class="card card-accent">
<h4>Example 1 ‚Äî Text-Based Search (Cache Miss)</h4>
<p>User Alice visits realtor.com and types "3 bed houses in Austin TX under 500K" into the search bar. The client sends <code>HTTP GET /api/search?city=Austin&state=TX&beds_min=3&price_max=500000&type=house&listing_type=sale&page=1&limit=20</code>.</p>
<p>The <strong>Load Balancer</strong> routes to the <strong>API Gateway</strong>, which forwards to the <strong>Search Service</strong>. The Search Service computes a cache key from the normalized query parameters and checks the <strong>Cache</strong>. It's a cache miss. The Search Service queries the <strong>Search Index</strong> with the filters and geo-constraint. The Search Index returns the top 20 matching listing IDs with summary fields (address, price, beds, baths, sqft, primary thumbnail URL, lat/lng). The Search Service stores this in the Cache (TTL: 60 seconds) and returns the JSON response to Alice.</p>

<h4>Example 2 ‚Äî Map-Based / Bounding Box Search</h4>
<p>User Bob is dragging around the map in the San Francisco area. As he stops panning, the client sends <code>HTTP GET /api/search?bounds=37.70,-122.52,37.82,-122.38&price_min=800000&beds_min=2</code>. The Search Service queries the Search Index with a <strong>geo_bounding_box</strong> filter on the lat/lng field plus the numeric filters. The index uses its geospatial index (R-tree / geohash) to efficiently find listings within the rectangle, then applies the price and bedroom filters. Results are returned sorted by relevance (a score combining recency, price match, and popularity).</p>

<h4>Example 3 ‚Äî Cached Search (Cache Hit)</h4>
<p>Five seconds after Alice's search, User Carol searches the same criteria. The Search Service finds the result in the Cache (within the 60-second TTL window) and returns it immediately without hitting the Search Index, reducing latency from ~120 ms to ~15 ms.</p>

<h4>Example 4 ‚Äî Paginated Search</h4>
<p>Alice clicks "Next Page." The client sends <code>HTTP GET /api/search?...&page=2&limit=20</code>. The Search Service uses cursor-based pagination (search_after) on the Search Index to fetch the next 20 results efficiently without deep pagination overhead.</p>
</div>

<h3>Component Deep Dive ‚Äî Flow 2</h3>

<div class="card card-purple">
<h4>Search Service</h4>
<table>
<tr><th>Protocol</th><th>Method</th><th>Endpoint</th><th>Input (Query Params)</th><th>Output</th></tr>
<tr><td>HTTP/REST</td><td>GET</td><td><code>/api/search</code></td><td>city, state, zip, bounds (lat1,lng1,lat2,lng2), beds_min, beds_max, baths_min, baths_max, price_min, price_max, sqft_min, sqft_max, property_type, listing_type, sort_by, page, limit</td><td>200 OK ‚Äî <code>{ total, page, results: [{listing_id, address, price, beds, baths, sqft, thumbnail_url, lat, lng, days_on_market}] }</code></td></tr>
</table>
<p>The Search Service is stateless. It translates user query parameters into a search-engine query (boolean filters + geo filter + full-text on description/address), fires it at the Search Index, and returns results. For autocomplete, a separate endpoint (<code>GET /api/search/suggest?q=...</code>) returns location suggestions.</p>

<h4>Cache (In-Memory)</h4>
<p>Sits in front of the Search Index. Cache key = hash of normalized query parameters. See <a href="#cdn-cache">CDN &amp; Caching Deep Dive</a> for strategy details.</p>

<h4>Search Index</h4>
<p>Distributed full-text and geospatial search engine. Each listing is a document with fields: listing_id, address, city, state, zip, lat, lng (geo_point), price, beds, baths, sqft, property_type, listing_type, description, status, created_at, updated_at, photos (URLs), agent_id. Indexed with inverted index on text fields, BKD-tree / R-tree on geo_point, and range-optimized indexes on numeric fields (price, beds, baths, sqft).</p>
</div>

<!-- ============================================================ -->
<h2 id="flow3">5. Flow 3 ‚Äî Viewing Property Details</h2>
<!-- ============================================================ -->

<div class="mermaid">
flowchart LR
    A["üë§ User\n(Web / Mobile)"] -->|"HTTP GET\n/api/listings/{id}"| B["‚öñÔ∏è Load Balancer"]
    B --> C["üîÄ API Gateway"]
    C --> D["üèóÔ∏è Listing Service"]
    D -->|"Check cache"| E["‚ö° Cache\n(In-Memory)"]
    E -->|"Cache HIT"| D
    D -->|"Cache MISS"| F[("üóÑÔ∏è Listing DB\n(SQL)")]
    F -->|"Return full listing\n+ price_history\n+ agent info"| D
    D -->|"Store in cache"| E
    D -->|"Return JSON"| A
    A -->|"Load images"| G["üåê CDN"]
    G -->|"Cache MISS"| H[("üì¶ Object Storage")]
</div>

<h3>Examples</h3>
<div class="card card-accent">
<h4>Example 1 ‚Äî Property Detail (Cache Miss)</h4>
<p>User Alice clicks on "123 Oak St" from her search results. The client sends <code>HTTP GET /api/listings/abc-123</code>. The Listing Service checks the Cache ‚Äî miss. It queries the <strong>Listing DB</strong> joining the <code>listings</code>, <code>price_history</code>, <code>listing_media</code>, and <code>agents</code> tables. The full listing object is assembled, stored in the Cache (TTL: 5 minutes), and returned. The client then loads the 15 images via the <strong>CDN</strong>. The CDN serves them from edge cache (or fetches from Object Storage on first request).</p>

<h4>Example 2 ‚Äî Hot Listing (Cache Hit)</h4>
<p>A newly listed $200K house in a competitive market is getting thousands of views per minute. After the first request populates the cache, subsequent requests are served from the <strong>Cache</strong> in ~5 ms, protecting the Listing DB from a thundering herd.</p>

<h4>Example 3 ‚Äî Listing Not Found</h4>
<p>User navigates to a deactivated or non-existent listing via an old bookmark. The Listing Service returns <code>HTTP 404 Not Found</code>. The client shows a "This listing is no longer available" page and suggests similar active listings.</p>
</div>

<h3>Component Deep Dive ‚Äî Flow 3</h3>

<div class="card card-purple">
<h4>Listing Service (Read Path)</h4>
<table>
<tr><th>Protocol</th><th>Method</th><th>Endpoint</th><th>Input</th><th>Output</th></tr>
<tr><td>HTTP/REST</td><td>GET</td><td><code>/api/listings/{id}</code></td><td>Path param: listing_id</td><td>200 OK ‚Äî Full listing JSON: address, price, beds, baths, sqft, description, property_type, listing_type, year_built, lot_size, hoa_fee, tax_history[], price_history[], media_urls[], agent: {name, phone, email, photo_url}, school_ratings, walk_score, lat, lng, days_on_market</td></tr>
</table>
<p>The read path uses the same Listing Service as the write path but with different handlers. On cache hit, the DB is not touched. On cache miss, a multi-join query is run and the result is cached.</p>
</div>

<!-- ============================================================ -->
<h2 id="flow4">6. Flow 4 ‚Äî Saving Properties &amp; Saved-Search Notifications</h2>
<!-- ============================================================ -->

<div class="mermaid">
flowchart LR
    A["üë§ User\n(Web / Mobile)"] -->|"HTTP POST\n/api/saved-properties"| B["‚öñÔ∏è Load Balancer"]
    B --> C["üîÄ API Gateway"]
    C --> D["üìå User Service"]
    D -->|"Write"| E[("üóÑÔ∏è User DB\n(SQL)")]

    A2["üë§ User\n(Web / Mobile)"] -->|"HTTP POST\n/api/saved-searches"| B
    C --> D
    D -->|"Write saved search criteria"| E

    F["üì® Message Queue\n(listing events)"] -->|"Consume"| G["üîî Notification Service"]
    G -->|"Read saved searches"| H[("üóÑÔ∏è Saved Search DB\n(cache layer)")]
    G -->|"Match? ‚Üí Send alert"| I["üì© Email / Push\nNotification Channel"]
</div>

<h3>Examples</h3>
<div class="card card-accent">
<h4>Example 1 ‚Äî Saving a Property</h4>
<p>User Alice views "123 Oak St" and clicks the ‚ù§Ô∏è "Save" button. The client sends <code>HTTP POST /api/saved-properties</code> with body <code>{ listing_id: "abc-123" }</code>. The <strong>User Service</strong> writes a row to the <code>saved_properties</code> table in the <strong>User DB</strong>. Alice can later view all her saved properties via <code>HTTP GET /api/saved-properties</code>.</p>

<h4>Example 2 ‚Äî Creating a Saved Search</h4>
<p>User Bob wants to be notified whenever a 2+ bed condo under $400K appears in Miami. He clicks "Save Search" on his current search results page. The client sends <code>HTTP POST /api/saved-searches</code> with body <code>{ city: "Miami", state: "FL", beds_min: 2, price_max: 400000, property_type: "condo" }</code>. The User Service writes the criteria to the <code>saved_searches</code> table.</p>

<h4>Example 3 ‚Äî Notification Triggered by New Listing</h4>
<p>Three days later, Agent Jane publishes a new condo listing in Miami: 2 bed, $375K. The <strong>Listing Service</strong> publishes a <code>listing.created</code> event to the Message Queue. The <strong>Notification Service</strong> consumes the event, loads all saved-search criteria that could match Miami condos, and evaluates them. Bob's saved search matches (city=Miami, beds‚â•2, price‚â§400K, type=condo). The Notification Service dispatches an email and a push notification to Bob: "New listing matches your saved search: 2 bed condo in Miami for $375,000."</p>

<h4>Example 4 ‚Äî Price Drop Notification</h4>
<p>Alice has "123 Oak St" saved. The agent drops the price. The <code>listing.updated</code> event fires. The Notification Service detects it's a price change and checks the <code>saved_properties</code> table. Alice has saved this listing, so she receives a push notification: "Price reduced! 123 Oak St is now $425,000 (was $450,000)."</p>
</div>

<h3>Component Deep Dive ‚Äî Flow 4</h3>

<div class="card card-purple">
<h4>User Service</h4>
<table>
<tr><th>Protocol</th><th>Method</th><th>Endpoint</th><th>Input</th><th>Output</th></tr>
<tr><td>HTTP/REST</td><td>POST</td><td><code>/api/saved-properties</code></td><td>JSON: { listing_id }</td><td>201 Created</td></tr>
<tr><td>HTTP/REST</td><td>GET</td><td><code>/api/saved-properties</code></td><td>Query: page, limit</td><td>200 OK ‚Äî array of saved listing summaries</td></tr>
<tr><td>HTTP/REST</td><td>DELETE</td><td><code>/api/saved-properties/{listing_id}</code></td><td>Path param</td><td>200 OK</td></tr>
<tr><td>HTTP/REST</td><td>POST</td><td><code>/api/saved-searches</code></td><td>JSON: search criteria object</td><td>201 Created ‚Äî { saved_search_id }</td></tr>
<tr><td>HTTP/REST</td><td>GET</td><td><code>/api/saved-searches</code></td><td>Query: page, limit</td><td>200 OK ‚Äî array of saved search objects</td></tr>
<tr><td>HTTP/REST</td><td>DELETE</td><td><code>/api/saved-searches/{id}</code></td><td>Path param</td><td>200 OK</td></tr>
</table>

<h4>Notification Service</h4>
<p>Long-running consumer process subscribing to the <code>listing-events</code> topic on the Message Queue. For each event:</p>
<ol>
  <li><strong>listing.created</strong> ‚Üí query saved searches by geography + filters. For efficient matching, saved searches are indexed by city/state/zip in a cache layer. The service loads candidate saved searches and evaluates each filter in memory.</li>
  <li><strong>listing.updated (price change)</strong> ‚Üí query <code>saved_properties</code> for users who saved this listing_id; also evaluate saved searches if relevant criteria changed.</li>
  <li><strong>listing.deactivated</strong> ‚Üí optionally notify users who saved it that the listing was removed.</li>
</ol>
<p>Notifications are dispatched via an email delivery service (SMTP-based) and a push notification gateway (APNs for iOS, FCM for Android).</p>
</div>

<!-- ============================================================ -->
<h2 id="flow5">7. Flow 5 ‚Äî Contacting an Agent</h2>
<!-- ============================================================ -->

<div class="mermaid">
flowchart LR
    A["üë§ User\n(Web / Mobile)"] -->|"HTTP POST\n/api/inquiries"| B["‚öñÔ∏è Load Balancer"]
    B --> C["üîÄ API Gateway"]
    C --> D["üí¨ Inquiry Service"]
    D -->|"Write inquiry record"| E[("üóÑÔ∏è Inquiry DB\n(SQL)")]
    D -->|"Publish inquiry.created"| F["üì® Message Queue"]
    F -->|"Consume"| G["üìß Email / SMS Service"]
    G -->|"Send to agent"| H["üßë‚Äçüíº Agent"]
</div>

<h3>Examples</h3>
<div class="card card-accent">
<h4>Example 1 ‚Äî Buyer Contacts Agent</h4>
<p>User Alice is on the listing detail page for "123 Oak St." She fills out the contact form: name, email, phone, message ("I'd like to schedule a tour this Saturday"). She clicks "Contact Agent." The client sends <code>HTTP POST /api/inquiries</code> with <code>{ listing_id: "abc-123", name: "Alice", email: "alice@email.com", phone: "555-1234", message: "..." }</code>.</p>
<p>The <strong>Inquiry Service</strong> writes the inquiry to the <strong>Inquiry DB</strong> and publishes an <code>inquiry.created</code> event to the <strong>Message Queue</strong>. The <strong>Email/SMS Service</strong> consumes the event and sends an email (and optionally SMS) to Agent Jane with Alice's contact information and message.</p>

<h4>Example 2 ‚Äî Unauthenticated User</h4>
<p>An anonymous user (not logged in) can still submit an inquiry ‚Äî the form collects their name, email, and phone. The API does not require authentication for this endpoint, but rate limiting (per IP) is enforced at the API Gateway to prevent spam.</p>
</div>

<h3>Component Deep Dive ‚Äî Flow 5</h3>

<div class="card card-purple">
<h4>Inquiry Service</h4>
<table>
<tr><th>Protocol</th><th>Method</th><th>Endpoint</th><th>Input</th><th>Output</th></tr>
<tr><td>HTTP/REST</td><td>POST</td><td><code>/api/inquiries</code></td><td>JSON: listing_id, name, email, phone, message</td><td>201 Created ‚Äî { inquiry_id }</td></tr>
<tr><td>HTTP/REST</td><td>GET</td><td><code>/api/inquiries?agent_id=xyz</code></td><td>Query: agent_id, page, limit</td><td>200 OK ‚Äî list of inquiries for the agent</td></tr>
</table>
<p>The inquiry is persisted for record-keeping and agent CRM-like functionality. The message queue decouples the write from the email/SMS delivery, ensuring the user gets a fast response even if the email service is slow.</p>
</div>

<!-- ============================================================ -->
<h2 id="overall">8. Overall Combined Diagram</h2>
<!-- ============================================================ -->

<div class="mermaid">
flowchart TB
    subgraph Clients
        WEB["üåê Web Client"]
        MOB["üì± Mobile Client"]
    end

    WEB & MOB --> LB["‚öñÔ∏è Load Balancer"]
    LB --> GW["üîÄ API Gateway\n(Auth, Rate Limit, Routing)"]

    subgraph Services
        LS["üèóÔ∏è Listing Service"]
        SS["üîç Search Service"]
        US["üë§ User Service"]
        IS["üí¨ Inquiry Service"]
        MS["üì∑ Media Service"]
        NS["üîî Notification Service"]
        SI["üîÑ Search Indexer"]
    end

    GW --> LS & SS & US & IS

    LS --> LDB[("üóÑÔ∏è Listing DB\n(SQL)")]
    LS --> MS
    MS --> OBJ[("üì¶ Object Storage")]
    OBJ --> CDN["üåê CDN"]

    LS -->|"Publish events"| MQ["üì® Message Queue"]
    MQ --> SI
    SI --> IDX[("üîé Search Index")]
    MQ --> NS

    SS -->|"Check"| CACHE["‚ö° Search Cache"]
    SS -->|"Query"| IDX

    US --> UDB[("üóÑÔ∏è User DB\n(SQL)")]
    IS --> IDB[("üóÑÔ∏è Inquiry DB\n(SQL)")]

    NS --> UDB
    NS --> EMAIL["üì© Email / Push"]

    LS -->|"Read"| LCACHE["‚ö° Listing Cache"]
    LCACHE --> LDB

    Clients -->|"Load images"| CDN
</div>

<h3>Overall Flow Examples</h3>
<div class="card card-accent">
<h4>End-to-End Example: From Listing to Buyer Notification to Contact</h4>
<ol>
  <li><strong>Agent lists property:</strong> Agent Jane creates a listing via <code>POST /api/listings</code>. The Listing Service writes to the Listing DB, the Media Service stores images in Object Storage (CDN-backed), and a <code>listing.created</code> event is published to the Message Queue.</li>
  <li><strong>Search index updated:</strong> The Search Indexer consumes the event and upserts the listing into the Search Index (takes ~2-5 seconds).</li>
  <li><strong>Saved search notification:</strong> The Notification Service also consumes the event, matches Bob's saved search criteria, and sends him an email: "New listing: 2 bed condo in Miami for $375K."</li>
  <li><strong>Bob searches &amp; finds it:</strong> Bob opens his email and clicks through, or independently searches via <code>GET /api/search?city=Miami&beds_min=2&price_max=400000</code>. The Search Service checks the Cache (miss ‚Üí query Search Index ‚Üí cache result ‚Üí return).</li>
  <li><strong>Bob views details:</strong> Bob clicks the listing. <code>GET /api/listings/xyz-789</code>. The Listing Service checks the Listing Cache (miss ‚Üí query Listing DB ‚Üí cache ‚Üí return). Images load from the CDN.</li>
  <li><strong>Bob contacts agent:</strong> Bob fills out the contact form and clicks submit. <code>POST /api/inquiries</code>. The Inquiry Service persists the record, publishes to the Message Queue, and the Email Service sends Agent Jane an email with Bob's info.</li>
  <li><strong>Bob saves the listing:</strong> Bob also clicks ‚ù§Ô∏è. <code>POST /api/saved-properties</code>. The User Service writes to the User DB.</li>
  <li><strong>Price drop:</strong> A week later, Jane reduces the price. <code>PATCH /api/listings/xyz-789</code>. Event published ‚Üí Notification Service detects Bob saved this listing ‚Üí push notification to Bob.</li>
</ol>
</div>

<!-- ============================================================ -->
<h2 id="schema">9. Database Schema</h2>
<!-- ============================================================ -->

<h3>SQL Tables</h3>

<div class="card card-green">
<h4>Table: <code>users</code> <span class="tag tag-sql">SQL</span></h4>
<table>
<tr><th>Column</th><th>Type</th><th>Constraints</th></tr>
<tr><td>user_id</td><td>UUID</td><td><span class="tag tag-pk">PRIMARY KEY</span></td></tr>
<tr><td>email</td><td>VARCHAR(255)</td><td>UNIQUE, NOT NULL</td></tr>
<tr><td>password_hash</td><td>VARCHAR(255)</td><td>NOT NULL</td></tr>
<tr><td>name</td><td>VARCHAR(255)</td><td>NOT NULL</td></tr>
<tr><td>phone</td><td>VARCHAR(20)</td><td>NULLABLE</td></tr>
<tr><td>role</td><td>ENUM('buyer','seller','agent','admin')</td><td>NOT NULL</td></tr>
<tr><td>created_at</td><td>TIMESTAMP</td><td>NOT NULL</td></tr>
<tr><td>updated_at</td><td>TIMESTAMP</td><td>NOT NULL</td></tr>
</table>
<p><strong>Why SQL:</strong> User data is highly relational (users ‚Üí saved_properties, users ‚Üí saved_searches, users ‚Üí inquiries), requires strong consistency (password changes, email uniqueness), and ACID guarantees for authentication flows.</p>
<p><strong>Read:</strong> User login (authentication), profile page load. <strong>Write:</strong> Registration, profile update.</p>
<p><strong>Indexes:</strong></p>
<ul>
  <li><span class="tag tag-idx">Hash Index</span> on <code>email</code> ‚Äî exact-match lookups for login; hash index is O(1) for equality queries.</li>
</ul>
<p><strong>Sharding:</strong> Not required at the expected scale (~tens of millions of users). A single primary + read replicas suffices. If needed, shard by <code>user_id</code> (hash-based) for even distribution.</p>
</div>

<div class="card card-green">
<h4>Table: <code>agents</code> <span class="tag tag-sql">SQL</span></h4>
<table>
<tr><th>Column</th><th>Type</th><th>Constraints</th></tr>
<tr><td>agent_id</td><td>UUID</td><td><span class="tag tag-pk">PRIMARY KEY</span></td></tr>
<tr><td>user_id</td><td>UUID</td><td><span class="tag tag-fk">FOREIGN KEY ‚Üí users.user_id</span> UNIQUE</td></tr>
<tr><td>license_number</td><td>VARCHAR(50)</td><td>NOT NULL</td></tr>
<tr><td>brokerage</td><td>VARCHAR(255)</td><td>NULLABLE</td></tr>
<tr><td>bio</td><td>TEXT</td><td>NULLABLE</td></tr>
<tr><td>photo_url</td><td>VARCHAR(512)</td><td>NULLABLE</td></tr>
<tr><td>phone</td><td>VARCHAR(20)</td><td>NOT NULL</td></tr>
<tr><td>created_at</td><td>TIMESTAMP</td><td>NOT NULL</td></tr>
</table>
<p><strong>Why SQL:</strong> 1:1 relationship with users; referenced by listings (FK). Need transactional integrity.</p>
<p><strong>Read:</strong> Property detail page (join to show agent info). <strong>Write:</strong> Agent profile creation/update.</p>
<p><strong>Normalization note:</strong> Separated from <code>users</code> to follow normalization principles ‚Äî not all users are agents, and agent-specific fields (license, brokerage) would cause many NULLs in a combined table.</p>
</div>

<div class="card card-green">
<h4>Table: <code>listings</code> <span class="tag tag-sql">SQL</span></h4>
<table>
<tr><th>Column</th><th>Type</th><th>Constraints</th></tr>
<tr><td>listing_id</td><td>UUID</td><td><span class="tag tag-pk">PRIMARY KEY</span></td></tr>
<tr><td>agent_id</td><td>UUID</td><td><span class="tag tag-fk">FK ‚Üí agents.agent_id</span> NOT NULL</td></tr>
<tr><td>address</td><td>VARCHAR(512)</td><td>NOT NULL</td></tr>
<tr><td>city</td><td>VARCHAR(100)</td><td>NOT NULL</td></tr>
<tr><td>state</td><td>VARCHAR(2)</td><td>NOT NULL</td></tr>
<tr><td>zip</td><td>VARCHAR(10)</td><td>NOT NULL</td></tr>
<tr><td>latitude</td><td>DECIMAL(10,7)</td><td>NOT NULL</td></tr>
<tr><td>longitude</td><td>DECIMAL(10,7)</td><td>NOT NULL</td></tr>
<tr><td>price</td><td>INTEGER</td><td>NOT NULL</td></tr>
<tr><td>beds</td><td>SMALLINT</td><td>NOT NULL</td></tr>
<tr><td>baths</td><td>DECIMAL(3,1)</td><td>NOT NULL</td></tr>
<tr><td>sqft</td><td>INTEGER</td><td>NOT NULL</td></tr>
<tr><td>lot_size_sqft</td><td>INTEGER</td><td>NULLABLE</td></tr>
<tr><td>year_built</td><td>SMALLINT</td><td>NULLABLE</td></tr>
<tr><td>property_type</td><td>ENUM('house','condo','townhouse','land','multi_family')</td><td>NOT NULL</td></tr>
<tr><td>listing_type</td><td>ENUM('sale','rent')</td><td>NOT NULL</td></tr>
<tr><td>description</td><td>TEXT</td><td>NULLABLE</td></tr>
<tr><td>hoa_fee</td><td>INTEGER</td><td>NULLABLE</td></tr>
<tr><td>status</td><td>ENUM('active','pending','sold','deactivated')</td><td>NOT NULL DEFAULT 'active'</td></tr>
<tr><td>created_at</td><td>TIMESTAMP</td><td>NOT NULL</td></tr>
<tr><td>updated_at</td><td>TIMESTAMP</td><td>NOT NULL</td></tr>
</table>
<p><strong>Why SQL:</strong> Listings are the core entity with strong relational ties (agent FK, price history, media, saved properties). ACID transactions needed for listing creation (listing + media records atomically). Complex queries in admin/analytics dashboards.</p>
<p><strong>Read:</strong> Property detail page (cache miss), admin dashboards, agent portal. <strong>Write:</strong> Listing creation, price update, status change.</p>
<p><strong>Indexes:</strong></p>
<ul>
  <li><span class="tag tag-idx">B-Tree Index</span> on <code>(status, city, state)</code> ‚Äî composite index for filtered queries on active listings by location. B-tree supports range and equality queries efficiently.</li>
  <li><span class="tag tag-idx">B-Tree Index</span> on <code>agent_id</code> ‚Äî for the agent portal "My Listings" page.</li>
  <li><span class="tag tag-idx">R-Tree / Spatial Index</span> on <code>(latitude, longitude)</code> ‚Äî for any geo-queries done directly against the DB (e.g., admin tools). The primary geo search goes through the Search Index, but having a spatial index on the SQL DB is useful for data integrity checks and fallback queries. R-tree partitions 2D space efficiently for bounding-box queries.</li>
</ul>
<p><strong>Sharding:</strong> Recommended once listing count exceeds tens of millions. Shard by <code>listing_id</code> (hash-based) for even distribution. <strong>Why listing_id and not geo?</strong> Geographic sharding creates hot spots (California shard would be overloaded). Hash-based on listing_id ensures even distribution. The Search Index handles geo-queries and doesn't need collocated data.</p>
</div>

<div class="card card-green">
<h4>Table: <code>listing_media</code> <span class="tag tag-sql">SQL</span></h4>
<table>
<tr><th>Column</th><th>Type</th><th>Constraints</th></tr>
<tr><td>media_id</td><td>UUID</td><td><span class="tag tag-pk">PRIMARY KEY</span></td></tr>
<tr><td>listing_id</td><td>UUID</td><td><span class="tag tag-fk">FK ‚Üí listings.listing_id</span> NOT NULL</td></tr>
<tr><td>url</td><td>VARCHAR(512)</td><td>NOT NULL</td></tr>
<tr><td>media_type</td><td>ENUM('photo','video','floor_plan')</td><td>NOT NULL</td></tr>
<tr><td>display_order</td><td>SMALLINT</td><td>NOT NULL</td></tr>
<tr><td>width</td><td>INTEGER</td><td>NULLABLE</td></tr>
<tr><td>height</td><td>INTEGER</td><td>NULLABLE</td></tr>
<tr><td>created_at</td><td>TIMESTAMP</td><td>NOT NULL</td></tr>
</table>
<p><strong>Why SQL:</strong> Needs referential integrity with listings (cascade delete on listing removal). Ordered display (display_order) is easy with SQL ORDER BY.</p>
<p><strong>Read:</strong> Property detail page (joined with listing). <strong>Write:</strong> Listing creation/media upload.</p>
<p><strong>Indexes:</strong></p>
<ul>
  <li><span class="tag tag-idx">B-Tree Index</span> on <code>(listing_id, display_order)</code> ‚Äî retrieve all media for a listing in display order efficiently.</li>
</ul>
</div>

<div class="card card-green">
<h4>Table: <code>price_history</code> <span class="tag tag-sql">SQL</span></h4>
<table>
<tr><th>Column</th><th>Type</th><th>Constraints</th></tr>
<tr><td>history_id</td><td>UUID</td><td><span class="tag tag-pk">PRIMARY KEY</span></td></tr>
<tr><td>listing_id</td><td>UUID</td><td><span class="tag tag-fk">FK ‚Üí listings.listing_id</span> NOT NULL</td></tr>
<tr><td>price</td><td>INTEGER</td><td>NOT NULL</td></tr>
<tr><td>event_type</td><td>ENUM('listed','price_change','sold','relisted')</td><td>NOT NULL</td></tr>
<tr><td>recorded_at</td><td>TIMESTAMP</td><td>NOT NULL</td></tr>
</table>
<p><strong>Why SQL:</strong> Append-only log tightly coupled to listing. Relational FK ensures integrity. Ordered time-series display.</p>
<p><strong>Read:</strong> Property detail page (price history chart). <strong>Write:</strong> Listing creation, price update.</p>
<p><strong>Indexes:</strong></p>
<ul>
  <li><span class="tag tag-idx">B-Tree Index</span> on <code>(listing_id, recorded_at)</code> ‚Äî retrieve chronological price history for a listing.</li>
</ul>
</div>

<div class="card card-green">
<h4>Table: <code>saved_properties</code> <span class="tag tag-sql">SQL</span></h4>
<table>
<tr><th>Column</th><th>Type</th><th>Constraints</th></tr>
<tr><td>user_id</td><td>UUID</td><td><span class="tag tag-pk">COMPOSITE PK</span> <span class="tag tag-fk">FK ‚Üí users.user_id</span></td></tr>
<tr><td>listing_id</td><td>UUID</td><td><span class="tag tag-pk">COMPOSITE PK</span> <span class="tag tag-fk">FK ‚Üí listings.listing_id</span></td></tr>
<tr><td>saved_at</td><td>TIMESTAMP</td><td>NOT NULL</td></tr>
</table>
<p><strong>Why SQL:</strong> Classic many-to-many junction table. Needs referential integrity (user + listing FKs). Small row size, simple queries.</p>
<p><strong>Read:</strong> "My Saved Homes" page, Notification Service checking if a user saved a specific listing. <strong>Write:</strong> User clicks ‚ù§Ô∏è Save / Unsave.</p>
<p><strong>Indexes:</strong></p>
<ul>
  <li><span class="tag tag-idx">B-Tree Index</span> on <code>(user_id, saved_at DESC)</code> ‚Äî efficiently list a user's saved homes in reverse chronological order.</li>
  <li><span class="tag tag-idx">B-Tree Index</span> on <code>(listing_id)</code> ‚Äî efficiently find all users who saved a specific listing (for price-drop notifications).</li>
</ul>
</div>

<div class="card card-green">
<h4>Table: <code>saved_searches</code> <span class="tag tag-sql">SQL</span></h4>
<table>
<tr><th>Column</th><th>Type</th><th>Constraints</th></tr>
<tr><td>saved_search_id</td><td>UUID</td><td><span class="tag tag-pk">PRIMARY KEY</span></td></tr>
<tr><td>user_id</td><td>UUID</td><td><span class="tag tag-fk">FK ‚Üí users.user_id</span> NOT NULL</td></tr>
<tr><td>city</td><td>VARCHAR(100)</td><td>NULLABLE</td></tr>
<tr><td>state</td><td>VARCHAR(2)</td><td>NULLABLE</td></tr>
<tr><td>zip</td><td>VARCHAR(10)</td><td>NULLABLE</td></tr>
<tr><td>beds_min</td><td>SMALLINT</td><td>NULLABLE</td></tr>
<tr><td>beds_max</td><td>SMALLINT</td><td>NULLABLE</td></tr>
<tr><td>baths_min</td><td>DECIMAL(3,1)</td><td>NULLABLE</td></tr>
<tr><td>price_min</td><td>INTEGER</td><td>NULLABLE</td></tr>
<tr><td>price_max</td><td>INTEGER</td><td>NULLABLE</td></tr>
<tr><td>sqft_min</td><td>INTEGER</td><td>NULLABLE</td></tr>
<tr><td>property_type</td><td>VARCHAR(50)</td><td>NULLABLE</td></tr>
<tr><td>listing_type</td><td>ENUM('sale','rent')</td><td>NULLABLE</td></tr>
<tr><td>notification_frequency</td><td>ENUM('instant','daily','weekly')</td><td>DEFAULT 'instant'</td></tr>
<tr><td>created_at</td><td>TIMESTAMP</td><td>NOT NULL</td></tr>
</table>
<p><strong>Why SQL:</strong> Structured search criteria with well-defined columns. FK to users. The Notification Service needs to query saved searches by location to find matches efficiently.</p>
<p><strong>Read:</strong> Notification Service when a listing event fires (query by city/state/zip to find matching saved searches). User's "My Saved Searches" page. <strong>Write:</strong> User saves a search.</p>
<p><strong>Indexes:</strong></p>
<ul>
  <li><span class="tag tag-idx">B-Tree Composite Index</span> on <code>(city, state, listing_type)</code> ‚Äî the Notification Service queries by geographic area and listing type when evaluating new listing events. This index narrows down candidates quickly before in-memory evaluation of remaining filters.</li>
  <li><span class="tag tag-idx">B-Tree Index</span> on <code>(user_id)</code> ‚Äî for loading a user's saved searches.</li>
</ul>
<p><strong>Denormalization note:</strong> The saved search criteria are stored as flattened columns rather than a JSON blob, even though they mirror search API parameters. This is intentional: the Notification Service needs to query <em>by individual filter fields</em> (e.g., "find all saved searches where city = 'Miami'"), which is efficient with indexed columns but impossible to query efficiently in a JSON blob.</p>
</div>

<div class="card card-green">
<h4>Table: <code>inquiries</code> <span class="tag tag-sql">SQL</span></h4>
<table>
<tr><th>Column</th><th>Type</th><th>Constraints</th></tr>
<tr><td>inquiry_id</td><td>UUID</td><td><span class="tag tag-pk">PRIMARY KEY</span></td></tr>
<tr><td>listing_id</td><td>UUID</td><td><span class="tag tag-fk">FK ‚Üí listings.listing_id</span> NOT NULL</td></tr>
<tr><td>user_id</td><td>UUID</td><td><span class="tag tag-fk">FK ‚Üí users.user_id</span> NULLABLE (anonymous allowed)</td></tr>
<tr><td>agent_id</td><td>UUID</td><td><span class="tag tag-fk">FK ‚Üí agents.agent_id</span> NOT NULL</td></tr>
<tr><td>name</td><td>VARCHAR(255)</td><td>NOT NULL</td></tr>
<tr><td>email</td><td>VARCHAR(255)</td><td>NOT NULL</td></tr>
<tr><td>phone</td><td>VARCHAR(20)</td><td>NULLABLE</td></tr>
<tr><td>message</td><td>TEXT</td><td>NOT NULL</td></tr>
<tr><td>status</td><td>ENUM('new','read','replied')</td><td>DEFAULT 'new'</td></tr>
<tr><td>created_at</td><td>TIMESTAMP</td><td>NOT NULL</td></tr>
</table>
<p><strong>Why SQL:</strong> Relational to both listings and agents. Agents need CRM-like queries (all inquiries sorted by date, filtered by status). ACID for status transitions.</p>
<p><strong>Read:</strong> Agent portal "My Inquiries" page. <strong>Write:</strong> User submits contact form.</p>
<p><strong>Indexes:</strong></p>
<ul>
  <li><span class="tag tag-idx">B-Tree Index</span> on <code>(agent_id, created_at DESC)</code> ‚Äî agent's inbox sorted by most recent.</li>
  <li><span class="tag tag-idx">B-Tree Index</span> on <code>(listing_id)</code> ‚Äî count/list inquiries per listing (analytics).</li>
</ul>
</div>

<h3>Search Index Document (Not a SQL/NoSQL table ‚Äî a search-engine document)</h3>
<div class="card card-orange">
<p>The <strong>Search Index</strong> is a separate system (not a traditional database). Each listing is indexed as a document:</p>
<pre><code>{
  "listing_id": "abc-123",
  "address": "123 Oak St",
  "city": "Austin",
  "state": "TX",
  "zip": "78701",
  "location": { "lat": 30.2672, "lon": -97.7431 },   // geo_point type
  "price": 450000,
  "beds": 3,
  "baths": 2.0,
  "sqft": 1800,
  "property_type": "house",
  "listing_type": "sale",
  "description": "Beautiful 3-bed home in downtown Austin...",
  "status": "active",
  "thumbnail_url": "https://cdn.example.com/abc-123/thumb.jpg",
  "agent_id": "agent-456",
  "days_on_market": 12,
  "created_at": "2025-02-01T10:00:00Z",
  "updated_at": "2025-02-10T14:00:00Z"
}</code></pre>
<p><strong>Index types used:</strong></p>
<ul>
  <li><strong>Inverted Index</strong> on <code>address</code>, <code>city</code>, <code>description</code> ‚Äî for full-text search and autocomplete.</li>
  <li><strong>BKD-Tree / R-Tree</strong> on <code>location</code> (geo_point) ‚Äî for bounding-box and distance-based geospatial queries.</li>
  <li><strong>Numeric Range Index</strong> on <code>price</code>, <code>beds</code>, <code>baths</code>, <code>sqft</code> ‚Äî for efficient range filtering.</li>
  <li><strong>Keyword Index</strong> on <code>property_type</code>, <code>listing_type</code>, <code>status</code> ‚Äî for exact-match filtering.</li>
</ul>
<p><strong>Why a separate search engine (and not querying the SQL DB)?</strong> The SQL DB would struggle with the combination of full-text search + geospatial queries + multi-faceted numeric filtering + relevance scoring at 50K QPS. A purpose-built search engine excels at this use case. The Search Index is kept in sync via the Message Queue (eventual consistency with ~2-5 second lag, which is acceptable).</p>
<p><strong>Denormalization:</strong> The search document denormalizes data from the <code>listings</code> table (e.g., <code>thumbnail_url</code> from <code>listing_media</code>, <code>days_on_market</code> computed from <code>created_at</code>). This is done so that search results can be rendered without a round-trip to the Listing DB. The trade-off is data staleness (seconds), which is acceptable for a listing tile in search results.</p>
</div>

<!-- ============================================================ -->
<h2 id="cdn-cache">10. CDN &amp; Caching Deep Dive</h2>
<!-- ============================================================ -->

<h3>CDN (Content Delivery Network)</h3>
<div class="card card-accent">
<h4>Why CDN is Appropriate</h4>
<p>Realtor.com is <strong>extremely media-heavy</strong>. A typical listing has 15-30 high-resolution photos, plus potential video tours and floor plans. Users are geographically distributed across the entire U.S. Without a CDN, every image request would travel to the origin Object Storage, adding 100-500 ms of latency and creating a bandwidth bottleneck. A CDN caches images at edge nodes worldwide, reducing image load times to &lt; 50 ms for most users.</p>

<h4>What is Cached</h4>
<ul>
  <li>All listing photos (multiple responsive sizes: 200px thumbnail, 600px card, 1200px full, 2400px zoom)</li>
  <li>Agent profile photos</li>
  <li>Virtual tour videos (HLS segments for adaptive streaming)</li>
  <li>Floor plan PDFs/images</li>
  <li>Static assets (JS, CSS, fonts, icons)</li>
</ul>

<h4>CDN Strategy</h4>
<ul>
  <li><strong>Pull-based (lazy loading):</strong> CDN fetches from Object Storage on first request. Subsequent requests served from edge cache.</li>
  <li><strong>Cache Headers:</strong> <code>Cache-Control: public, max-age=2592000</code> (30 days). Images are immutable ‚Äî if a photo changes, a new URL is generated (content-addressed naming).</li>
  <li><strong>Cache Warming:</strong> When a new listing is created with 15+ photos, the primary thumbnail is proactively warmed in the CDN (the Listing Service makes a HEAD request to the CDN URL for the primary image after creation). Other images are lazy-loaded.</li>
  <li><strong>Eviction Policy:</strong> LRU (Least Recently Used) at the CDN edge. Old listings that haven't been viewed in weeks will be evicted; they'll be re-fetched from Object Storage if requested again.</li>
</ul>
</div>

<h3>In-Memory Cache ‚Äî Search Cache</h3>
<div class="card card-green">
<h4>Why Cache is Appropriate for Search</h4>
<p>At 50K search QPS, even a fast search engine would struggle. Many searches are duplicates or near-duplicates (e.g., "3 bed Austin TX" is searched thousands of times per hour). Caching popular search results avoids redundant search-engine queries.</p>

<h4>Caching Strategy: Cache-Aside (Lazy Loading)</h4>
<ol>
  <li><strong>Read:</strong> Search Service computes cache key (hash of normalized query params) ‚Üí check cache ‚Üí if HIT, return cached result ‚Üí if MISS, query Search Index, store result in cache, return.</li>
  <li><strong>Write/Invalidation:</strong> No direct write-through. Cache entries expire via TTL. When a listing is updated/created, we do NOT invalidate individual search cache entries (too expensive to determine which queries are affected). Instead, the short TTL ensures eventual freshness.</li>
</ol>
<p><strong>Why Cache-Aside and NOT Write-Through:</strong> A write-through strategy would require knowing which search queries are affected by a listing change ‚Äî this is computationally infeasible since any listing update could affect thousands of different search queries. Cache-aside with a short TTL is simpler and sufficient.</p>

<h4>Expiration Policy</h4>
<p><strong>TTL: 60 seconds.</strong> This balances freshness (new listings appear in search within 60 seconds at most) with cache hit rate. At 50K QPS, even a 60-second TTL yields very high hit rates for popular queries.</p>

<h4>Eviction Policy</h4>
<p><strong>LRU (Least Recently Used).</strong> Unpopular/niche queries (e.g., "5+ bed house in a rural zip code") are evicted first, keeping popular queries cached. This maximizes cache hit rate given a fixed memory budget.</p>
</div>

<h3>In-Memory Cache ‚Äî Listing Detail Cache</h3>
<div class="card card-green">
<h4>Why Cache is Appropriate for Listing Details</h4>
<p>Hot listings (newly listed, price-reduced, in competitive markets) receive thousands of views in a short time. Without caching, each view would query the Listing DB with multi-table joins. The cache absorbs this read amplification.</p>

<h4>Caching Strategy: Cache-Aside (Lazy Loading) with Event-Driven Invalidation</h4>
<ol>
  <li><strong>Read:</strong> Listing Service checks cache by listing_id ‚Üí HIT returns the cached detail object ‚Üí MISS queries the Listing DB (joins listings + price_history + listing_media + agents), caches the result, returns.</li>
  <li><strong>Invalidation:</strong> When a <code>listing.updated</code> or <code>listing.deactivated</code> event is consumed by a cache invalidation worker (subscribing to the Message Queue), the corresponding cache entry is deleted. The next read will repopulate it.</li>
</ol>
<p><strong>Why event-driven invalidation here (and not for search cache):</strong> Listing cache keys are deterministic (keyed by listing_id), so invalidating on update is trivial and O(1). This ensures users never see stale pricing on the detail page ‚Äî important for transactional accuracy.</p>

<h4>Expiration Policy</h4>
<p><strong>TTL: 5 minutes.</strong> Safety net in case an invalidation event is lost. Long enough to absorb traffic spikes on hot listings.</p>

<h4>Eviction Policy</h4>
<p><strong>LRU.</strong> Same reasoning ‚Äî hot listings stay cached, cold listings are evicted.</p>
</div>

<!-- ============================================================ -->
<h2 id="scaling">11. Scaling Considerations</h2>
<!-- ============================================================ -->

<div class="card card-accent">
<h3>Load Balancers</h3>
<h4>Where Load Balancers Are Placed</h4>
<ol>
  <li><strong>L1 ‚Äî External Load Balancer (in front of API Gateway):</strong> Internet-facing Layer 7 load balancer. Terminates TLS, performs health checks, and distributes traffic across multiple API Gateway instances. Uses round-robin with sticky sessions disabled (services are stateless).</li>
  <li><strong>L2 ‚Äî Internal Load Balancer (between API Gateway and services):</strong> The API Gateway itself acts as a reverse proxy, but if services are independently scaled, an internal L4 load balancer distributes traffic to Listing Service, Search Service, User Service, and Inquiry Service pools. Uses least-connections algorithm for even load distribution.</li>
</ol>

<h4>Deep Dive on Load Balancers</h4>
<p><strong>External LB:</strong> Handles up to 50K+ requests/second during peak. Supports auto-scaling of backend instances. Uses health check endpoints (<code>GET /health</code>) on each API Gateway instance with 5-second intervals. If an instance fails 3 consecutive checks, it's removed from the rotation. Supports connection draining (30-second drain period) during deployments.</p>
<p><strong>Internal LB:</strong> Lower throughput per service but critical for distributing load across horizontally scaled service instances. The Search Service and Listing Service are the hottest and are independently auto-scaled. The internal LB ensures even distribution.</p>

<h3>Horizontal Scaling by Component</h3>
<table>
<tr><th>Component</th><th>Scaling Strategy</th><th>Notes</th></tr>
<tr><td>API Gateway</td><td>Horizontal ‚Äî add instances behind LB</td><td>Stateless; scale based on CPU/connection count</td></tr>
<tr><td>Listing Service</td><td>Horizontal ‚Äî add instances</td><td>Stateless; scale based on request rate</td></tr>
<tr><td>Search Service</td><td>Horizontal ‚Äî add instances</td><td>Stateless; scale based on QPS</td></tr>
<tr><td>User Service</td><td>Horizontal ‚Äî add instances</td><td>Lower traffic than search</td></tr>
<tr><td>Inquiry Service</td><td>Horizontal ‚Äî add instances</td><td>Lowest traffic among services</td></tr>
<tr><td>Media Service</td><td>Horizontal ‚Äî add workers</td><td>Scale image processing workers based on upload queue depth</td></tr>
<tr><td>Search Indexer</td><td>Horizontal ‚Äî add consumer instances</td><td>Partition the message queue topic; each partition handled by one consumer</td></tr>
<tr><td>Notification Service</td><td>Horizontal ‚Äî add consumer instances</td><td>Same partitioning as indexer; scale based on lag</td></tr>
<tr><td>Listing DB (SQL)</td><td>Vertical + Read Replicas + Sharding</td><td>Primary handles writes; read replicas for read-heavy paths. Shard by listing_id when needed.</td></tr>
<tr><td>User DB (SQL)</td><td>Vertical + Read Replicas</td><td>Lower scale; read replicas suffice</td></tr>
<tr><td>Search Index</td><td>Horizontal ‚Äî add shards and replicas</td><td>Data sharded by listing_id; replica shards for read throughput</td></tr>
<tr><td>Cache</td><td>Horizontal ‚Äî consistent hashing</td><td>Add nodes with consistent hashing to minimize cache invalidation on resize</td></tr>
<tr><td>Message Queue</td><td>Horizontal ‚Äî add partitions</td><td>More partitions = more parallel consumers</td></tr>
<tr><td>Object Storage</td><td>Managed / infinite scale</td><td>Object storage is horizontally scalable by design</td></tr>
<tr><td>CDN</td><td>Managed / edge nodes</td><td>CDN provider manages edge scaling</td></tr>
</table>

<h3>Database Read Replicas</h3>
<p>The Listing DB is read-heavy (100:1 read-to-write ratio). Deploy 3-5 read replicas. The Listing Service routes <code>GET</code> requests to read replicas and <code>POST/PATCH/DELETE</code> to the primary. Replication lag is typically &lt; 100 ms, acceptable for detail page reads (the cache absorbs most reads anyway).</p>

<h3>Auto-Scaling Triggers</h3>
<ul>
  <li><strong>Services:</strong> Scale up when average CPU &gt; 60% or p99 latency &gt; 500 ms. Scale down when CPU &lt; 30% for 10 minutes.</li>
  <li><strong>Search Index:</strong> Monitor query latency; add replica shards when p99 &gt; 150 ms.</li>
  <li><strong>Message Queue Consumers:</strong> Scale based on consumer lag (if messages are backing up, add consumer instances).</li>
</ul>
</div>

<!-- ============================================================ -->
<h2 id="tradeoffs">12. Tradeoffs &amp; Deep Dives</h2>
<!-- ============================================================ -->

<div class="card card-orange">
<h3 id="mq-deepdive">Message Queue Deep Dive</h3>
<h4>Why a Message Queue?</h4>
<p>The Listing Service needs to trigger multiple downstream actions after a listing write: update the search index, evaluate saved search notifications, and potentially trigger analytics events. Without a message queue, the Listing Service would make synchronous calls to each downstream system, creating tight coupling and increasing write latency. With a message queue:</p>
<ul>
  <li><strong>Decoupling:</strong> Listing Service only needs to publish an event; it doesn't know or care about consumers.</li>
  <li><strong>Reliability:</strong> If the Search Indexer is down, messages are durably stored in the queue and processed when it recovers. No data loss.</li>
  <li><strong>Scalability:</strong> Consumers scale independently. Search Indexer and Notification Service can process at their own pace.</li>
</ul>

<h4>How Messages Are Published</h4>
<p>After a successful DB write, the Listing Service publishes a message to the <code>listing-events</code> topic. The message contains:</p>
<pre><code>{
  "event_type": "listing.created",   // or listing.updated, listing.deactivated
  "listing_id": "abc-123",
  "timestamp": "2025-02-10T14:00:00Z",
  "data": { /* full or partial listing object */ }
}</code></pre>
<p>The message is partitioned by <code>listing_id</code> to ensure ordering per listing (important: a create must be processed before an update for the same listing).</p>

<h4>How Messages Are Consumed</h4>
<p>Two independent <strong>consumer groups</strong> subscribe to the same topic:</p>
<ol>
  <li><strong>search-indexer-group:</strong> Each consumer reads from assigned partitions, upserts the listing document in the Search Index, and commits the offset.</li>
  <li><strong>notification-service-group:</strong> Each consumer reads from assigned partitions, evaluates the event against saved searches, dispatches notifications, and commits the offset.</li>
</ol>
<p>At-least-once delivery is guaranteed. Consumers are idempotent (upsert operations are naturally idempotent; notification service deduplicates by event_id).</p>

<h4>Why Not Pub/Sub?</h4>
<p>A pub/sub system would also work. However, a message queue with consumer groups provides better guarantees: message durability, replay capability, and backpressure handling (slow consumers don't lose messages). Pub/sub is often fire-and-forget, which is risky for search index consistency. In practice, modern message queue systems support pub/sub semantics (topic with multiple consumer groups), so the distinction is blurred.</p>

<h4>Why Not Direct Synchronous Calls?</h4>
<p>If the Listing Service called the Search Indexer synchronously, a slow or failed indexing operation would increase listing write latency or cause failures. The async approach ensures listing writes are fast (~50 ms) and downstream processing happens independently.</p>
</div>

<div class="card card-orange">
<h3>Consistency vs. Availability Tradeoff</h3>
<p><strong>Listing Writes:</strong> Strong consistency (SQL with ACID). If a listing price is updated, the write is confirmed only after it's durable in the primary DB.</p>
<p><strong>Search Results:</strong> Eventual consistency. A new listing may take 2-5 seconds to appear in search results (message queue + indexing lag). This is acceptable ‚Äî users don't expect real-time search for real estate.</p>
<p><strong>Listing Detail Page:</strong> Near-real-time consistency. Event-driven cache invalidation ensures price changes are reflected within seconds. If the cache entry is stale (missed invalidation), the 5-minute TTL is the safety net.</p>
</div>

<div class="card card-orange">
<h3>SQL vs. Search Index Duality</h3>
<p>This design intentionally maintains two representations of listing data:</p>
<ol>
  <li><strong>SQL DB:</strong> Source of truth. Handles writes, transactional integrity, and relational queries (joins, admin dashboards).</li>
  <li><strong>Search Index:</strong> Optimized read replica for user-facing search. Handles full-text + geo + faceted queries at massive scale.</li>
</ol>
<p><strong>Tradeoff:</strong> Data duplication and eventual consistency. <strong>Benefit:</strong> Each system is optimized for its workload. The SQL DB doesn't need to handle 50K search QPS, and the Search Index doesn't need ACID transactions.</p>
</div>

<div class="card card-orange">
<h3>WebSocket / Polling / SSE ‚Äî Not Used</h3>
<p>This design does NOT use WebSockets, long polling, or Server-Sent Events for the main flows. Here's why:</p>
<ul>
  <li><strong>Real-time updates on search results:</strong> Not needed. Users perform a search and view results. If a listing's price changes while they're viewing results, it's acceptable to show the price from when the search was executed. A page refresh or new search picks up the change.</li>
  <li><strong>Notifications:</strong> Delivered via email and mobile push (APNs/FCM), not in-app WebSocket. Most real estate users check listings periodically, not in real-time like a chat app. Push notifications and email are the standard UX for this domain.</li>
  <li><strong>Map-based search:</strong> Each pan/zoom triggers a new HTTP GET request (debounced). This is more efficient than maintaining a WebSocket for streaming results, since the user pauses between interactions.</li>
</ul>
<p><strong>If real-time in-app notifications were desired</strong> (e.g., showing a badge count update), Server-Sent Events (SSE) would be preferred over WebSockets because the data flow is unidirectional (server ‚Üí client) and SSE is simpler, uses HTTP, and auto-reconnects.</p>
</div>

<div class="card card-orange">
<h3>Protocol Choices</h3>
<p><strong>HTTP/REST over HTTPS (TLS 1.3):</strong> All client-to-server communication. REST is chosen for simplicity, wide tooling support, cacheability (GET requests are cacheable at CDN/proxy level), and statelessness. Every service exposes RESTful endpoints.</p>
<p><strong>Why not gRPC for inter-service communication?</strong> gRPC with Protocol Buffers would be more efficient for inter-service calls (binary format, HTTP/2 multiplexing). For a system this size, it's a viable optimization. We chose REST for simplicity in the initial design, but migrating internal service-to-service calls to gRPC is a natural scaling optimization.</p>
</div>

<!-- ============================================================ -->
<h2 id="alternatives">13. Alternative Approaches</h2>
<!-- ============================================================ -->

<div class="card card-red">
<h3>Alternative 1: Single Database for Everything (No Separate Search Index)</h3>
<p><strong>Approach:</strong> Use the SQL database's built-in full-text search and geospatial extensions for all search queries.</p>
<p><strong>Why not chosen:</strong> SQL full-text search degrades at scale (50K QPS across millions of documents with geo + faceted filtering). The query planner struggles to optimize queries combining full-text, geographic, and numeric range filters simultaneously. A dedicated search engine is purpose-built for this. Additionally, mixing heavy read traffic (search) with write traffic (listing updates) on the same database creates contention.</p>

<h3>Alternative 2: NoSQL Document Database as Primary Store</h3>
<p><strong>Approach:</strong> Store listings as documents in a NoSQL database (e.g., a document store) instead of SQL.</p>
<p><strong>Why not chosen:</strong> Listings have strong relational needs: an agent has many listings, a listing has many photos, a listing has price history, users save many listings. These relationships are natural in SQL with foreign keys. A document store would require denormalization and duplication (embedding agent info in every listing document), leading to update anomalies (changing agent phone number requires updating every listing document). SQL's referential integrity is valuable for data correctness in a real estate platform where accuracy is critical.</p>

<h3>Alternative 3: GraphQL Instead of REST</h3>
<p><strong>Approach:</strong> Use GraphQL for the API layer, allowing clients to request exactly the data they need.</p>
<p><strong>Why not chosen:</strong> GraphQL is excellent for complex, nested data fetching (listing ‚Üí agent ‚Üí office ‚Üí reviews), and Realtor.com could benefit from it. We chose REST for simplicity in this design. However, GraphQL is a strong alternative, especially for the property detail page where mobile clients may want a smaller payload than web clients. The downside is added complexity in query optimization and caching (GraphQL responses are harder to cache at the HTTP level since queries vary).</p>

<h3>Alternative 4: CQRS (Command Query Responsibility Segregation) with Event Sourcing</h3>
<p><strong>Approach:</strong> Full CQRS: write side uses event sourcing (every state change is an immutable event), read side materializes views from the event log.</p>
<p><strong>Why not chosen:</strong> Our design already implements a lightweight form of CQRS (SQL DB for writes, Search Index for reads, synced via Message Queue). Full event sourcing adds significant complexity (event store, projection rebuilding, eventual consistency across all reads) that isn't justified for a real estate platform where the write volume is relatively low (~1K listings created/updated per second) and the data model is straightforward. Event sourcing shines in domains with complex business logic and audit requirements (e.g., banking).</p>

<h3>Alternative 5: Pre-Computing Search Results by Geography</h3>
<p><strong>Approach:</strong> Pre-compute and cache search results for every city/neighborhood combination, refreshing periodically.</p>
<p><strong>Why not chosen:</strong> The combinatorial explosion of search filter combinations (city √ó price range √ó beds √ó baths √ó property type √ó listing type √ó sort order) makes pre-computation infeasible. A city like Austin could have thousands of unique filter combinations. The search index with a short-TTL cache is a more flexible and efficient approach.</p>
</div>

<!-- ============================================================ -->
<h2 id="additional">14. Additional Information</h2>
<!-- ============================================================ -->

<div class="card card-purple">
<h3>Geocoding</h3>
<p>When a listing is created with an address but without lat/lng, the system must geocode the address. This is done by the <strong>Search Indexer</strong> (or a dedicated Geocoding Service) before indexing. The geocoded coordinates are written back to the Listing DB as well. A geocoding API (e.g., a mapping service) is called. Results are cached aggressively since addresses don't change coordinates.</p>

<h3>Image Processing Pipeline</h3>
<ol>
  <li>Client obtains pre-signed upload URLs from Media Service.</li>
  <li>Client uploads raw images directly to Object Storage.</li>
  <li>Object Storage triggers an event (or Media Service is called to finalize).</li>
  <li>An image processing worker resizes each image to 4 sizes: thumbnail (200px), card (600px), full (1200px), zoom (2400px). WebP format is generated alongside JPEG for browsers that support it.</li>
  <li>Processed images are stored in Object Storage with predictable paths: <code>/{listing_id}/{media_id}_{size}.{format}</code>.</li>
  <li>CDN URLs are generated and stored in the <code>listing_media</code> table.</li>
</ol>

<h3>Rate Limiting</h3>
<p>The API Gateway enforces rate limits:</p>
<ul>
  <li><strong>Search:</strong> 100 requests/minute per IP (unauthenticated), 300/minute (authenticated).</li>
  <li><strong>Listing creation:</strong> 50/hour per agent (prevent spam listings).</li>
  <li><strong>Contact agent:</strong> 10/hour per IP (prevent agent spam).</li>
</ul>

<h3>Monitoring &amp; Observability</h3>
<ul>
  <li><strong>Metrics:</strong> Request rate, error rate (5xx), p50/p95/p99 latency per service, cache hit rate, search index lag, message queue consumer lag.</li>
  <li><strong>Alerting:</strong> p99 latency &gt; 500ms, error rate &gt; 1%, consumer lag &gt; 10K messages, cache hit rate drops below 60%.</li>
  <li><strong>Distributed tracing:</strong> Each request gets a trace ID propagated across services for debugging latency issues.</li>
</ul>

<h3>Data Pipeline for Analytics / ML</h3>
<p>Listing events, search queries, and user behavior (clicks, saves, time on page) are streamed to a data warehouse via the Message Queue for:</p>
<ul>
  <li>Search ranking model training (learning which listings users prefer).</li>
  <li>Property value estimation model (analyzing historical sales, price changes, neighborhood trends).</li>
  <li>Personalized recommendations ("Homes you might like" based on browsing history).</li>
</ul>

<h3>SEO Considerations</h3>
<p>Property detail pages need to be server-side rendered (SSR) or statically generated for search engine crawlability. Listing URLs should be SEO-friendly: <code>/homes/austin-tx/123-oak-st-78701/abc-123</code>. Structured data (JSON-LD schema.org/RealEstateListing) is embedded in each page for rich search results.</p>
</div>

<!-- ============================================================ -->
<h2 id="vendors">15. Vendor Suggestions</h2>
<!-- ============================================================ -->

<div class="card card-green">
<table>
<tr><th>Component</th><th>Vendor Options</th><th>Why</th></tr>
<tr><td>SQL Database</td><td>PostgreSQL, MySQL, Amazon Aurora</td><td>PostgreSQL: excellent geospatial support (PostGIS), JSON support, mature. Aurora: managed, auto-scaling storage, MySQL/PG compatible.</td></tr>
<tr><td>Search Index</td><td>Elasticsearch, OpenSearch, Apache Solr</td><td>Elasticsearch/OpenSearch: industry standard for full-text + geo search, proven at scale (billions of docs). Built-in geo_point type, aggregations, and relevance scoring.</td></tr>
<tr><td>In-Memory Cache</td><td>Redis, Memcached</td><td>Redis: versatile (strings, hashes, sorted sets, pub/sub), supports TTL natively, cluster mode for horizontal scaling. Memcached: simpler, slightly faster for pure key-value caching.</td></tr>
<tr><td>Message Queue</td><td>Apache Kafka, Amazon SQS/SNS, RabbitMQ, Apache Pulsar</td><td>Kafka: high throughput, durable, supports consumer groups and replay. Ideal for the event-driven architecture with multiple consumers. Pulsar: similar to Kafka with multi-tenancy.</td></tr>
<tr><td>Object Storage</td><td>Amazon S3, Google Cloud Storage, Azure Blob Storage</td><td>S3: industry standard, 11 nines durability, lifecycle policies, pre-signed URLs. All three are comparable for this use case.</td></tr>
<tr><td>CDN</td><td>Cloudflare, Amazon CloudFront, Akamai, Fastly</td><td>Cloudflare: extensive edge network, image optimization built-in, DDoS protection. CloudFront: tight S3 integration. Akamai: largest edge network, proven for media-heavy sites.</td></tr>
<tr><td>Push Notifications</td><td>Firebase Cloud Messaging (FCM), Apple Push Notification Service (APNs), OneSignal</td><td>FCM/APNs: required for Android/iOS push. OneSignal: unified abstraction layer over both.</td></tr>
<tr><td>Load Balancer</td><td>AWS ALB/NLB, Google Cloud Load Balancing, Nginx, HAProxy, Envoy</td><td>ALB: managed L7 with auto-scaling. Nginx/HAProxy: self-managed, battle-tested. Envoy: modern, gRPC-native, great for service mesh.</td></tr>
<tr><td>Geocoding</td><td>Google Maps Geocoding API, Mapbox, HERE</td><td>Google Maps: most accurate, highest coverage. Mapbox: developer-friendly, competitive pricing.</td></tr>
</table>
</div>

<hr>
<p style="text-align:center; color: var(--dim); margin-top: 2rem;">System Design Document ‚Äî Realtor.com ‚Äî Generated February 2026</p>

<script>
  mermaid.initialize({ 
    startOnLoad: true, 
    theme: 'base',
    themeVariables: {
      // Background & general
      darkMode: true,
      background: '#0d1117',
      mainBkg: '#1a2332',
      
      // Primary colors for nodes
      primaryColor: '#1a3a5c',
      primaryTextColor: '#e6edf3',
      primaryBorderColor: '#58a6ff',

      // Secondary colors
      secondaryColor: '#1a3327',
      secondaryTextColor: '#e6edf3',
      secondaryBorderColor: '#3fb950',

      // Tertiary colors  
      tertiaryColor: '#2d1f3d',
      tertiaryTextColor: '#e6edf3',
      tertiaryBorderColor: '#bc8cff',

      // Node & default styling
      nodeBorder: '#58a6ff',
      nodeTextColor: '#e6edf3',

      // Lines & arrows
      lineColor: '#4a90d9',

      // Text
      textColor: '#e6edf3',

      // Flowchart specific
      clusterBkg: '#131a24',
      clusterBorder: '#30363d',
      
      // Labels
      labelBackground: '#0d1117',
      labelTextColor: '#8b949e',

      // Edge label
      edgeLabelBackground: '#161b22',

      // Font
      fontFamily: '-apple-system, BlinkMacSystemFont, Segoe UI, Helvetica, Arial, sans-serif',
      fontSize: '14px',

      // Notes
      noteBkgColor: '#1c2333',
      noteTextColor: '#e6edf3',
      noteBorderColor: '#30363d'
    },
    flowchart: { 
      useMaxWidth: true, 
      htmlLabels: true,
      curve: 'basis',
      nodeSpacing: 50,
      rankSpacing: 60,
      padding: 15
    }
  });
</script>
</body>
</html>
