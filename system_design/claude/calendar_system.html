<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>System Design: Calendar System</title>
<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<style>
  body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; line-height: 1.7; color: #1a1a1a; max-width: 1100px; margin: 0 auto; padding: 40px 20px; background: #f9fafb; }
  h1 { font-size: 2.2em; border-bottom: 3px solid #2563eb; padding-bottom: 12px; color: #1e293b; }
  h2 { font-size: 1.6em; margin-top: 48px; color: #1e40af; border-bottom: 2px solid #dbeafe; padding-bottom: 8px; }
  h3 { font-size: 1.25em; margin-top: 32px; color: #1e3a5f; }
  h4 { font-size: 1.1em; margin-top: 24px; color: #334155; }
  ul, ol { margin: 10px 0; }
  li { margin: 6px 0; }
  code { background: #e2e8f0; padding: 2px 6px; border-radius: 4px; font-size: 0.92em; }
  pre { background: #1e293b; color: #e2e8f0; padding: 18px; border-radius: 8px; overflow-x: auto; font-size: 0.9em; }
  .diagram-container { background: white; padding: 24px; border-radius: 12px; box-shadow: 0 1px 6px rgba(0,0,0,0.08); margin: 20px 0; }
  .example-box { background: #eff6ff; border-left: 4px solid #3b82f6; padding: 16px 20px; margin: 16px 0; border-radius: 0 8px 8px 0; }
  .example-box strong { color: #1e40af; }
  .note-box { background: #fefce8; border-left: 4px solid #eab308; padding: 16px 20px; margin: 16px 0; border-radius: 0 8px 8px 0; }
  .note-box strong { color: #854d0e; }
  .warn-box { background: #fef2f2; border-left: 4px solid #ef4444; padding: 16px 20px; margin: 16px 0; border-radius: 0 8px 8px 0; }
  table { border-collapse: collapse; width: 100%; margin: 16px 0; }
  th, td { border: 1px solid #cbd5e1; padding: 10px 14px; text-align: left; }
  th { background: #1e40af; color: white; }
  tr:nth-child(even) { background: #f1f5f9; }
  .mermaid { display: flex; justify-content: center; }
</style>
</head>
<body>

<h1>System Design: Calendar System</h1>
<p>A comprehensive design for a calendar application that allows users to create, manage, and share events, handle recurring events, send reminders, and support collaborative scheduling — similar to Google Calendar or Outlook Calendar.</p>

<!-- ============================== -->
<h2>1. Functional Requirements</h2>
<!-- ============================== -->
<ol>
  <li><strong>Event CRUD:</strong> Users can create, read, update, and delete calendar events (title, description, location, start/end time, all-day flag).</li>
  <li><strong>Recurring Events:</strong> Users can create events that repeat on a configurable schedule (daily, weekly, monthly, yearly, custom RRULE) and edit/delete a single occurrence, all occurrences, or "this and following" occurrences.</li>
  <li><strong>Calendars:</strong> Each user has one or more calendars (e.g., "Work", "Personal"). Users can create, rename, and delete calendars.</li>
  <li><strong>Event Invitations &amp; RSVP:</strong> A user (organizer) can invite other users to an event. Invitees can accept, decline, or mark tentative. The organizer sees the aggregate RSVP status.</li>
  <li><strong>Calendar Sharing:</strong> A user can share an entire calendar with another user with read-only or read-write permissions.</li>
  <li><strong>Calendar Views:</strong> Users can view their calendar in day, week, or month views. All events across all of a user's calendars are merged into a single view.</li>
  <li><strong>Free / Busy Lookup:</strong> When scheduling a meeting, a user can check the free/busy status of other users to find available time slots.</li>
  <li><strong>Reminders:</strong> Users can set one or more reminders per event (e.g., 10 minutes before, 1 day before). Reminders are delivered via push notification and/or email.</li>
  <li><strong>Time Zone Support:</strong> Events store their time zone. The UI renders events in the viewer's local time zone.</li>
  <li><strong>Search:</strong> Users can search for events by title or description.</li>
</ol>

<!-- ============================== -->
<h2>2. Non-Functional Requirements</h2>
<!-- ============================== -->
<ol>
  <li><strong>High Availability:</strong> The system must be available 99.99% of the time. Calendar is a critical productivity tool; downtime blocks meetings.</li>
  <li><strong>Low Read Latency:</strong> Calendar view requests should return in &lt; 200ms at the 99th percentile. Users open their calendar many times per day.</li>
  <li><strong>Strong Consistency for Writes:</strong> When a user creates or updates an event, the change must be immediately visible to that user and eventually consistent for other viewers within a few seconds.</li>
  <li><strong>Scalability:</strong> Support hundreds of millions of users with billions of events. Handle read-heavy workloads (reads &gt;&gt; writes, roughly 10:1).</li>
  <li><strong>Durability:</strong> Zero event data loss. Events are critical business data.</li>
  <li><strong>Reliable Reminders:</strong> Reminders must fire within a few seconds of the scheduled time. Late or missed reminders are unacceptable.</li>
  <li><strong>Multi-platform:</strong> Support web, iOS, and Android clients.</li>
  <li><strong>Security &amp; Privacy:</strong> Events are visible only to the owner and authorized viewers. All traffic encrypted in transit (TLS).</li>
</ol>

<!-- ============================== -->
<h2>3. System Design Flows &amp; Diagrams</h2>
<!-- ============================== -->

<!-- ============ FLOW 1 ============ -->
<h3>3.1 Flow 1 — Event Creation</h3>
<p>This flow covers a user creating a new event (one-time or recurring), optionally with attendees.</p>

<div class="diagram-container">
<pre class="mermaid">
graph LR
    Client["Client\n(Web / iOS / Android)"]
    LB["Load Balancer"]
    AG["API Gateway"]
    ES["Event Service"]
    DB[("Event DB\n(SQL)")]
    Cache[("Cache")]
    MQ["Message Queue"]
    NS["Notification Service"]
    Push["Push / Email"]

    Client -->|"HTTP POST /events"| LB
    LB --> AG
    AG --> ES
    ES -->|"INSERT event + attendees"| DB
    ES -->|"Invalidate / write-through"| Cache
    ES -->|"Publish: invitation + reminder jobs"| MQ
    MQ --> NS
    NS --> Push
</pre>
</div>

<div class="example-box">
<strong>Example 1 — Simple one-time event (no attendees):</strong><br>
Alice opens her calendar app and taps "Create Event." She fills in title = "Dentist Appointment", date = March 5 2026 2:00 PM – 3:00 PM, timezone = America/New_York, reminder = 1 hour before. She taps Save. The client sends an <code>HTTP POST /events</code> to the Load Balancer, which forwards it through the API Gateway to the Event Service. The Event Service validates the payload, stores the event in the Event DB (SQL), writes through to the Cache, and publishes a "schedule_reminder" message to the Message Queue with remind_at = March 5 2026 1:00 PM UTC. The response <code>201 Created</code> with the event object is returned to the client. No invitation notifications are sent because there are no attendees.
</div>

<div class="example-box">
<strong>Example 2 — Event with attendees:</strong><br>
Bob creates a "Design Review" meeting on March 10 2026 10:00 AM – 11:00 AM and adds Alice and Carol as attendees. The client sends <code>HTTP POST /events</code> with an <code>attendees</code> array containing Alice and Carol's user IDs. The Event Service inserts the event row and two event_attendees rows (both with rsvp_status = "pending") in a single SQL transaction. It then publishes two messages to the Message Queue: (1) an "event_invitation" message for each attendee, and (2) a "schedule_reminder" message. The Notification Service consumes the invitation messages and sends push notifications to Alice and Carol saying "Bob invited you to Design Review on March 10."
</div>

<div class="example-box">
<strong>Example 3 — Recurring event:</strong><br>
Carol creates "Daily Standup" every weekday at 9:00 AM starting March 3 2026 with no end date. The client sends <code>HTTP POST /events</code> with <code>is_recurring = true</code> and <code>recurrence_rule = "FREQ=WEEKLY;BYDAY=MO,TU,WE,TH,FR"</code>. The Event Service stores a single master event row with the recurrence rule — it does NOT pre-generate individual occurrences. This keeps storage efficient. When Carol (or any attendee) later opens a calendar view, the Calendar Read Service will virtually expand the recurrence rule into individual occurrences for the requested time range.
</div>

<h4>3.1.1 Deep Dive — Components in Flow 1</h4>

<h4>Client (Web / iOS / Android)</h4>
<p>The front-end application. On web, a single-page app. On mobile, native iOS/Android apps. Responsible for rendering the calendar UI, collecting event form data, and calling the backend API. Converts displayed times to the user's local time zone.</p>

<h4>Load Balancer</h4>
<p>An L7 (application-layer) load balancer that distributes incoming HTTP requests across multiple API Gateway instances using round-robin or least-connections. It terminates TLS, performs health checks, and provides horizontal scaling. Placed at the edge of the backend.</p>

<h4>API Gateway</h4>
<p>A reverse-proxy that handles authentication (validates JWT/session tokens), rate limiting, request validation, and routes requests to the correct microservice. For event creation it routes to the Event Service.</p>

<h4>Event Service</h4>
<p>The core service for event CRUD operations. Stateless.</p>
<ul>
  <li><strong>Protocol:</strong> HTTP REST</li>
  <li><strong>Endpoint:</strong> <code>POST /events</code></li>
  <li><strong>Input:</strong> JSON body with <code>calendar_id</code>, <code>title</code>, <code>description</code>, <code>location</code>, <code>start_time</code> (ISO-8601 UTC), <code>end_time</code>, <code>timezone</code>, <code>is_all_day</code>, <code>is_recurring</code>, <code>recurrence_rule</code> (RRULE string), <code>attendee_ids[]</code>, <code>reminders[]</code> (array of {minutes_before, type}).</li>
  <li><strong>Output:</strong> <code>201 Created</code> with the full event object including generated <code>event_id</code>. On validation failure, <code>400 Bad Request</code>.</li>
  <li><strong>Behavior:</strong> Wraps the INSERT of the event row plus any attendee and reminder rows in a single SQL transaction to guarantee atomicity. After commit, publishes messages to the Message Queue asynchronously (fire-and-forget with retry) so that failure to enqueue does not fail the user request. Writes through to the Cache to keep it fresh.</li>
</ul>

<h4>Event DB (SQL)</h4>
<p>A relational database storing events, attendees, reminders, calendars, and users. SQL is chosen for ACID guarantees on event writes and for the ability to perform range queries (e.g., all events between two dates). Described in detail in the Schema section.</p>

<h4>Cache</h4>
<p>An in-memory key-value cache that stores recently-accessed calendar views. On event creation, the Event Service writes through to the cache (invalidating or updating the relevant calendar view entries). Described in detail in the Cache Deep Dive section.</p>

<h4>Message Queue</h4>
<p>An asynchronous message queue used to decouple the Event Service from downstream consumers (Notification Service, Reminder Scheduler). The Event Service publishes messages; consumers pull and process them. Described in detail in the Message Queue Deep Dive section.</p>

<h4>Notification Service</h4>
<p>Consumes messages from the Message Queue and delivers notifications to users via push notification (APNs for iOS, FCM for Android), email, or in-app. Stateless. Tracks delivery status.</p>

<!-- ============ FLOW 2 ============ -->
<h3>3.2 Flow 2 — Calendar View (Read)</h3>
<p>This flow covers a user opening their calendar to view events for a given time range (day, week, or month).</p>

<div class="diagram-container">
<pre class="mermaid">
graph LR
    Client["Client\n(Web / iOS / Android)"]
    LB["Load Balancer"]
    AG["API Gateway"]
    CS["Calendar Read Service"]
    Cache[("Cache")]
    DB[("Event DB\n(SQL)")]
    RE["Recurrence\nExpander"]

    Client -->|"HTTP GET /calendars/{userId}/events?start=...&end=..."| LB
    LB --> AG
    AG --> CS
    CS -->|"Check cache"| Cache
    Cache -.->|"Cache miss"| CS
    CS -->|"Query events in range"| DB
    CS --> RE
    RE -->|"Expanded\noccurrences"| CS
    CS -->|"Populate cache"| Cache
</pre>
</div>

<div class="example-box">
<strong>Example 1 — Cache hit (day view):</strong><br>
Alice opens her calendar app on March 5 2026. The client sends <code>HTTP GET /calendars/alice123/events?start=2026-03-05T00:00:00Z&amp;end=2026-03-06T00:00:00Z&amp;view=day</code>. The request hits the Load Balancer → API Gateway → Calendar Read Service. The Read Service checks the Cache with key <code>alice123:day:2026-03-05</code>. A cached result exists (populated from a previous request 2 minutes ago). The service returns the cached event list immediately with <code>200 OK</code>. Latency is ~15ms.
</div>

<div class="example-box">
<strong>Example 2 — Cache miss with recurring event expansion (week view):</strong><br>
Bob opens week view for March 3–9 2026. Cache key <code>bob456:week:2026-03-03</code> is not found (miss). The Calendar Read Service queries the Event DB: <code>SELECT * FROM events WHERE calendar_id IN (bob's calendar IDs) AND ((start_time &lt; end_range AND end_time &gt; start_range) OR is_recurring = true)</code>. It retrieves 4 one-time events and 1 recurring event ("Daily Standup" with RRULE). The Recurrence Expander processes the RRULE and generates 5 virtual occurrences (Mon–Fri) within the requested range. The service merges the 4 one-time events + 5 expanded occurrences = 9 total events, writes the result to the Cache, and returns it with <code>200 OK</code>.
</div>

<div class="example-box">
<strong>Example 3 — Shared calendar view:</strong><br>
Carol has shared her "Work" calendar with Alice (read-only). When Alice opens her calendar, the client requests events for all of Alice's own calendars PLUS any shared calendars. The Calendar Read Service checks the <code>calendar_shares</code> table to find that Alice has read access to Carol's "Work" calendar (calendar_id = 77). It then includes calendar_id 77 in the query. Alice sees her own events alongside Carol's work events, color-coded differently.
</div>

<h4>3.2.1 Deep Dive — Components in Flow 2</h4>

<h4>Calendar Read Service</h4>
<p>A read-optimized service responsible for assembling a user's calendar view. Stateless.</p>
<ul>
  <li><strong>Protocol:</strong> HTTP REST</li>
  <li><strong>Endpoint:</strong> <code>GET /calendars/{userId}/events?start={ISO-8601}&amp;end={ISO-8601}&amp;view={day|week|month}</code></li>
  <li><strong>Input:</strong> User ID (from path), start/end time range (query params), view type (query param).</li>
  <li><strong>Output:</strong> <code>200 OK</code> with a JSON array of event objects (each with id, title, start, end, color, calendar_name, rsvp_status if applicable, etc.).</li>
  <li><strong>Behavior:</strong> First checks the cache. On miss, queries the Event DB for all events in the user's calendars (including shared calendars) that overlap with the requested range. Passes any recurring master events to the Recurrence Expander. Merges and sorts all events by start_time. Populates the cache. Returns the result.</li>
</ul>

<h4>Recurrence Expander</h4>
<p>An internal library/module within the Calendar Read Service (not a separate microservice) that takes an RRULE string, a master event's start time, and a query range, and returns the list of concrete occurrence date-times within that range. It also applies any stored exceptions (deleted or modified single occurrences). This is a <strong>lazy expansion</strong> strategy — occurrences are computed on the fly rather than pre-materialized, keeping storage efficient for events that repeat indefinitely.</p>

<!-- ============ FLOW 3 ============ -->
<h3>3.3 Flow 3 — Event Invitation &amp; RSVP</h3>
<p>This flow covers an invitee responding to an event invitation (accepting, declining, or marking tentative).</p>

<div class="diagram-container">
<pre class="mermaid">
graph LR
    Client["Invitee Client"]
    LB["Load Balancer"]
    AG["API Gateway"]
    ES["Event Service"]
    DB[("Event DB\n(SQL)")]
    Cache[("Cache")]
    MQ["Message Queue"]
    NS["Notification Service"]
    OrgClient["Organizer\n(Push / Email)"]

    Client -->|"HTTP PATCH /events/{eventId}/rsvp"| LB
    LB --> AG
    AG --> ES
    ES -->|"UPDATE event_attendees SET rsvp_status"| DB
    ES -->|"Invalidate cache"| Cache
    ES -->|"Publish: rsvp_update"| MQ
    MQ --> NS
    NS --> OrgClient
</pre>
</div>

<div class="example-box">
<strong>Example 1 — Accepting an invitation:</strong><br>
Alice receives a push notification: "Bob invited you to Design Review on March 10." She taps the notification, opening the event detail screen. She taps "Accept." The client sends <code>HTTP PATCH /events/evt_8832/rsvp</code> with body <code>{"rsvp_status": "accepted"}</code>. The Event Service updates Alice's row in the <code>event_attendees</code> table (setting <code>rsvp_status = 'accepted'</code> and <code>responded_at = now()</code>). It invalidates the cache entries for both Alice's and Bob's calendars (since the RSVP count on the event changed). It publishes an "rsvp_update" message to the Message Queue. The Notification Service consumes it and sends Bob a push notification: "Alice accepted Design Review."
</div>

<div class="example-box">
<strong>Example 2 — Declining an invitation:</strong><br>
Carol receives the same invitation. She taps "Decline" with an optional note: "Conflict with another meeting." The flow is identical, except <code>rsvp_status = 'declined'</code>. Bob receives a notification: "Carol declined Design Review." The event remains on Carol's calendar in a dimmed/strikethrough style so she knows she was invited but declined.
</div>

<h4>3.3.1 Deep Dive — Components in Flow 3</h4>

<h4>Event Service (RSVP Endpoint)</h4>
<ul>
  <li><strong>Protocol:</strong> HTTP REST</li>
  <li><strong>Endpoint:</strong> <code>PATCH /events/{eventId}/rsvp</code></li>
  <li><strong>Input:</strong> Event ID (path), JSON body with <code>rsvp_status</code> ("accepted" | "declined" | "tentative") and optional <code>note</code>.</li>
  <li><strong>Output:</strong> <code>200 OK</code> with updated attendee object.</li>
  <li><strong>Authorization:</strong> The authenticated user must be an attendee of the event. The API Gateway validates the JWT; the Event Service checks the <code>event_attendees</code> row exists for the user.</li>
</ul>

<!-- ============ FLOW 4 ============ -->
<h3>3.4 Flow 4 — Reminders &amp; Notifications</h3>
<p>This flow covers the system proactively sending reminders to users before their events begin.</p>

<div class="diagram-container">
<pre class="mermaid">
graph LR
    RS["Reminder Scheduler\n(Cron / Scheduled Worker)"]
    DB[("Event DB\n(SQL)")]
    MQ["Message Queue"]
    NS["Notification Service"]
    Push["Push Notification\n(APNs / FCM)"]
    Email["Email Service"]

    RS -->|"Poll: SELECT reminders\nWHERE remind_at <= now()\nAND is_sent = false"| DB
    RS -->|"Publish: send_reminder"| MQ
    MQ --> NS
    NS --> Push
    NS --> Email
    RS -->|"UPDATE reminders\nSET is_sent = true"| DB
</pre>
</div>

<div class="example-box">
<strong>Example 1 — Push notification reminder:</strong><br>
Alice has a "Dentist Appointment" on March 5 at 2:00 PM with a reminder set for 1 hour before. The reminder row in the DB has <code>remind_at = 2026-03-05T13:00:00Z</code> and <code>is_sent = false</code>. The Reminder Scheduler runs every 30 seconds. At 1:00:15 PM UTC, it queries: <code>SELECT * FROM reminders WHERE remind_at &lt;= '2026-03-05T13:00:15Z' AND is_sent = false LIMIT 1000</code>. Alice's reminder is returned. The scheduler publishes a "send_reminder" message to the Message Queue and marks <code>is_sent = true</code> in the DB. The Notification Service consumes the message and sends a push notification to Alice's phone: "Dentist Appointment in 1 hour."
</div>

<div class="example-box">
<strong>Example 2 — Multiple reminders on one event:</strong><br>
Bob set two reminders for "Design Review": 1 day before (email) and 15 minutes before (push). The DB has two reminder rows. The 1-day reminder fires on March 9 at 10:00 AM — the Notification Service sends Bob an email. The 15-minute reminder fires on March 10 at 9:45 AM — the Notification Service sends a push notification.
</div>

<div class="example-box">
<strong>Example 3 — Reminder for recurring event:</strong><br>
Carol's "Daily Standup" repeats every weekday at 9:00 AM with a 10-minute reminder. Since recurring events are lazily expanded, the system needs a way to schedule reminders for upcoming occurrences. The Reminder Scheduler has a secondary job: every night at midnight, it expands recurring events for the next 24 hours, generates reminder rows for each occurrence, and inserts them into the <code>reminders</code> table. This ensures that the standard reminder polling mechanism picks them up.
</div>

<h4>3.4.1 Deep Dive — Components in Flow 4</h4>

<h4>Reminder Scheduler</h4>
<p>A background worker process that runs on a fixed schedule (every 30 seconds). It polls the <code>reminders</code> table for unsent reminders whose <code>remind_at</code> has passed. To avoid duplicate sends across multiple scheduler instances, it uses a <strong>row-level lock</strong> (<code>SELECT ... FOR UPDATE SKIP LOCKED</code>) to claim a batch of reminders. After publishing to the Message Queue, it marks them as sent. If the Message Queue publish fails, the reminder remains unsent and will be retried on the next poll.</p>
<p>A secondary nightly job expands recurring events for the next 24–48 hours and materializes reminder rows. This is the bridge between lazy recurrence expansion and reliable reminder delivery.</p>

<h4>Notification Service</h4>
<p>Consumes "send_reminder" and "event_invitation" and "rsvp_update" messages from the Message Queue. Looks up the user's notification preferences and device tokens. Sends push notifications via APNs (iOS) or FCM (Android). Sends emails via an SMTP relay or transactional email service. Idempotent — uses the reminder_id / notification_id to deduplicate.</p>

<!-- ============ FLOW 5 ============ -->
<h3>3.5 Flow 5 — Free / Busy Lookup</h3>
<p>This flow covers a user checking other users' availability when scheduling a meeting.</p>

<div class="diagram-container">
<pre class="mermaid">
graph LR
    Client["Client"]
    LB["Load Balancer"]
    AG["API Gateway"]
    FBS["Free/Busy Service"]
    DB[("Event DB\n(SQL)")]
    Cache[("Cache")]

    Client -->|"HTTP POST /freebusy"| LB
    LB --> AG
    AG --> FBS
    FBS -->|"Check cache"| Cache
    FBS -->|"Query events for\nrequested users in range"| DB
    FBS -->|"Return busy\ntime blocks"| Client
</pre>
</div>

<div class="example-box">
<strong>Example:</strong><br>
Bob wants to schedule a meeting with Alice and Carol on March 10. He clicks "Find a time" in the event creation form. The client sends <code>HTTP POST /freebusy</code> with body <code>{"user_ids": ["alice123", "carol789"], "start": "2026-03-10T08:00:00Z", "end": "2026-03-10T18:00:00Z"}</code>. The Free/Busy Service queries the Event DB for all non-declined events for Alice and Carol in that range (respecting privacy — it only returns busy/free, not event titles). It returns: Alice is busy 9:00–10:00 and 14:00–15:00; Carol is busy 9:00–9:30 and 11:00–12:00. The client overlays this on a timeline grid, highlighting 10:00–11:00 as the first slot where all three participants are free.
</div>

<h4>3.5.1 Deep Dive — Components in Flow 5</h4>

<h4>Free/Busy Service</h4>
<ul>
  <li><strong>Protocol:</strong> HTTP REST</li>
  <li><strong>Endpoint:</strong> <code>POST /freebusy</code></li>
  <li><strong>Input:</strong> JSON body with <code>user_ids[]</code>, <code>start</code> (ISO-8601), <code>end</code> (ISO-8601).</li>
  <li><strong>Output:</strong> <code>200 OK</code> with a map of user_id → array of busy time blocks <code>[{start, end}]</code>.</li>
  <li><strong>Privacy:</strong> Returns only time blocks (busy/free), never event details. Respects calendar sharing permissions — only shows free/busy if the user has at least "free/busy" visibility.</li>
  <li><strong>Performance:</strong> Uses the cache when available. For users whose calendar data isn't cached, performs a targeted SQL query with a time-range index.</li>
</ul>

<!-- ============ COMBINED FLOW ============ -->
<h3>3.6 Combined Overall Flow</h3>
<p>This diagram shows all components in a single unified view, illustrating how the system fits together.</p>

<div class="diagram-container">
<pre class="mermaid">
graph TB
    Client["Client\n(Web / iOS / Android)"]
    LB["Load Balancer"]
    AG["API Gateway\n(Auth, Rate Limit, Routing)"]

    ES["Event Service\n(CRUD + RSVP)"]
    CS["Calendar Read Service\n(+ Recurrence Expander)"]
    FBS["Free/Busy Service"]
    NS["Notification Service"]
    RS["Reminder Scheduler\n(Background Worker)"]

    DB[("Event DB\n(SQL)\n—\nevents, calendars,\nattendees, reminders,\ncalendar_shares, users")]
    NF[("Notification Feed\n(NoSQL)")]
    Cache[("Cache\n(In-Memory)")]
    MQ["Message Queue"]

    Push["Push Notifications\n(APNs / FCM)"]
    Email["Email Service"]

    Client --> LB
    LB --> AG

    AG -->|"POST/PUT/DELETE /events\nPATCH /events/.../rsvp"| ES
    AG -->|"GET /calendars/.../events"| CS
    AG -->|"POST /freebusy"| FBS

    ES --> DB
    ES --> Cache
    ES --> MQ

    CS --> Cache
    CS --> DB

    FBS --> Cache
    FBS --> DB

    MQ --> NS
    NS --> Push
    NS --> Email
    NS --> NF

    RS -->|"Poll reminders"| DB
    RS --> MQ
</pre>
</div>

<div class="example-box">
<strong>End-to-end example — Full meeting lifecycle:</strong><br>
<strong>Step 1 — Free/Busy check:</strong> Bob wants to meet Alice and Carol. He opens "Find a time" → <code>POST /freebusy</code> → Free/Busy Service queries the Event DB → returns availability. Bob picks March 10, 10:00–11:00 AM.<br><br>
<strong>Step 2 — Event creation with invites:</strong> Bob creates "Design Review" at 10:00–11:00 with Alice and Carol as attendees, reminder = 15 min before → <code>POST /events</code> → Event Service writes to Event DB + Cache, publishes invitation messages + schedule_reminder to Message Queue → Notification Service sends push notifications to Alice and Carol.<br><br>
<strong>Step 3 — RSVPs:</strong> Alice accepts → <code>PATCH /events/evt_8832/rsvp</code> → Event Service updates DB + invalidates Cache, publishes rsvp_update → Notification Service notifies Bob. Carol declines similarly.<br><br>
<strong>Step 4 — Calendar view:</strong> The next morning, Bob opens his calendar for the week → <code>GET /calendars/bob456/events?start=...&end=...</code> → Calendar Read Service checks Cache (miss) → queries DB → expands any recurring events → populates Cache → returns event list including "Design Review" showing Alice = accepted, Carol = declined.<br><br>
<strong>Step 5 — Reminder:</strong> On March 10 at 9:45 AM, the Reminder Scheduler polls the DB, finds Bob's 15-minute reminder → publishes "send_reminder" to MQ → Notification Service sends push notification to Bob: "Design Review in 15 minutes."
</div>

<!-- ============================== -->
<h2>4. Database Schema</h2>
<!-- ============================== -->

<h3>4.1 SQL Tables</h3>

<h4>4.1.1 <code>users</code></h4>
<table>
<tr><th>Column</th><th>Type</th><th>Constraints</th><th>Description</th></tr>
<tr><td>id</td><td>UUID</td><td><strong>PRIMARY KEY</strong></td><td>Unique user identifier</td></tr>
<tr><td>username</td><td>VARCHAR(64)</td><td>UNIQUE, NOT NULL</td><td>Display name</td></tr>
<tr><td>email</td><td>VARCHAR(255)</td><td>UNIQUE, NOT NULL</td><td>Email address for notifications</td></tr>
<tr><td>timezone</td><td>VARCHAR(64)</td><td>NOT NULL, DEFAULT 'UTC'</td><td>User's default timezone (IANA format, e.g., "America/New_York")</td></tr>
<tr><td>created_at</td><td>TIMESTAMP</td><td>NOT NULL</td><td>Account creation time (UTC)</td></tr>
</table>
<p><strong>Why SQL:</strong> Users have well-defined, structured attributes. Relationships to calendars, events, and attendees require referential integrity. The user table is relatively small and read-heavy, making SQL an ideal fit.</p>
<p><strong>Read/Write triggers:</strong> Written when a user signs up. Read during authentication and when resolving user info for notifications and calendar views.</p>
<p><strong>Indexes:</strong></p>
<ul>
  <li><strong>Hash index on <code>email</code>:</strong> Used for login/authentication lookups. Hash is chosen because lookups are always exact-match (no range queries on email).</li>
</ul>

<h4>4.1.2 <code>calendars</code></h4>
<table>
<tr><th>Column</th><th>Type</th><th>Constraints</th><th>Description</th></tr>
<tr><td>id</td><td>UUID</td><td><strong>PRIMARY KEY</strong></td><td>Unique calendar identifier</td></tr>
<tr><td>owner_id</td><td>UUID</td><td><strong>FOREIGN KEY → users.id</strong>, NOT NULL</td><td>Calendar owner</td></tr>
<tr><td>name</td><td>VARCHAR(128)</td><td>NOT NULL</td><td>"Work", "Personal", etc.</td></tr>
<tr><td>color</td><td>VARCHAR(7)</td><td>NOT NULL, DEFAULT '#3b82f6'</td><td>Hex color for UI display</td></tr>
<tr><td>is_primary</td><td>BOOLEAN</td><td>NOT NULL, DEFAULT false</td><td>Whether this is the user's default calendar</td></tr>
<tr><td>created_at</td><td>TIMESTAMP</td><td>NOT NULL</td><td>Calendar creation time (UTC)</td></tr>
</table>
<p><strong>Why SQL:</strong> Calendars have strong relational ties to users (owner) and events. The schema is well-defined and unlikely to change. Enforces the constraint that each user has exactly one primary calendar.</p>
<p><strong>Read/Write triggers:</strong> Written when a user creates a new calendar. Read during every calendar view request (to determine which calendars to fetch events for).</p>
<p><strong>Indexes:</strong></p>
<ul>
  <li><strong>B-tree index on <code>owner_id</code>:</strong> Every calendar view starts by looking up all calendars owned by (or shared with) a user. B-tree allows efficient equality lookup and is well-suited since owner_id has moderate cardinality.</li>
</ul>

<h4>4.1.3 <code>events</code></h4>
<table>
<tr><th>Column</th><th>Type</th><th>Constraints</th><th>Description</th></tr>
<tr><td>id</td><td>UUID</td><td><strong>PRIMARY KEY</strong></td><td>Unique event identifier</td></tr>
<tr><td>calendar_id</td><td>UUID</td><td><strong>FOREIGN KEY → calendars.id</strong>, NOT NULL</td><td>Which calendar this event belongs to</td></tr>
<tr><td>creator_id</td><td>UUID</td><td><strong>FOREIGN KEY → users.id</strong>, NOT NULL</td><td>User who created the event</td></tr>
<tr><td>title</td><td>VARCHAR(256)</td><td>NOT NULL</td><td>Event title</td></tr>
<tr><td>description</td><td>TEXT</td><td>NULLABLE</td><td>Event description / notes</td></tr>
<tr><td>location</td><td>VARCHAR(512)</td><td>NULLABLE</td><td>Event location (text or URL for virtual meetings)</td></tr>
<tr><td>start_time</td><td>TIMESTAMP</td><td>NOT NULL</td><td>Event start (UTC)</td></tr>
<tr><td>end_time</td><td>TIMESTAMP</td><td>NOT NULL</td><td>Event end (UTC)</td></tr>
<tr><td>timezone</td><td>VARCHAR(64)</td><td>NOT NULL</td><td>Original timezone the event was created in</td></tr>
<tr><td>is_all_day</td><td>BOOLEAN</td><td>NOT NULL, DEFAULT false</td><td>Whether this is an all-day event</td></tr>
<tr><td>is_recurring</td><td>BOOLEAN</td><td>NOT NULL, DEFAULT false</td><td>Whether this event has recurrence</td></tr>
<tr><td>recurrence_rule</td><td>VARCHAR(512)</td><td>NULLABLE</td><td>RRULE string (RFC 5545), e.g., "FREQ=WEEKLY;BYDAY=MO,TU,WE,TH,FR"</td></tr>
<tr><td>recurring_master_id</td><td>UUID</td><td>NULLABLE, <strong>FOREIGN KEY → events.id</strong></td><td>If this is an exception instance, points to the master recurring event</td></tr>
<tr><td>original_start_time</td><td>TIMESTAMP</td><td>NULLABLE</td><td>For exception instances: the start_time of the occurrence being overridden</td></tr>
<tr><td>created_at</td><td>TIMESTAMP</td><td>NOT NULL</td><td>Row creation time</td></tr>
<tr><td>updated_at</td><td>TIMESTAMP</td><td>NOT NULL</td><td>Last update time</td></tr>
</table>
<p><strong>Why SQL:</strong> Events require ACID transactions (e.g., creating an event with attendees atomically). Time-range queries (<code>start_time BETWEEN x AND y</code>) are critical and benefit from B-tree indexes in SQL. Referential integrity (foreign keys to calendars, users) prevents orphan data. The schema is well-defined.</p>
<p><strong>Read/Write triggers:</strong> Written on event creation and update. Read on every calendar view request, free/busy lookup, search, and reminder scheduling.</p>
<p><strong>Indexes:</strong></p>
<ul>
  <li><strong>Composite B-tree index on <code>(calendar_id, start_time)</code>:</strong> This is the most critical index. Every calendar view query filters by calendar_id and a time range. The composite index enables the database to seek directly to the right calendar and then scan only the events within the requested date range. B-tree is chosen because time-range queries benefit from its ordered structure.</li>
  <li><strong>B-tree index on <code>creator_id</code>:</strong> Used when looking up all events a user organized. B-tree for equality + potential range ordering by date.</li>
  <li><strong>B-tree index on <code>recurring_master_id</code>:</strong> Used to find all exception instances of a recurring event (e.g., when deleting "all occurrences").</li>
  <li><strong>Full-text index on <code>(title, description)</code>:</strong> Supports the event search feature. An inverted index is used to enable keyword searches across event titles and descriptions efficiently.</li>
</ul>
<p><strong>Sharding:</strong> The <code>events</code> table will be the largest table and a candidate for sharding. <strong>Shard by <code>calendar_id</code></strong> using hash-based sharding. This ensures all events for a given calendar land on the same shard, so a calendar view query (which filters by calendar_id) hits only one shard. This avoids scatter-gather queries. The downside is that a single calendar with an extremely large number of events could create a hot shard, but in practice, individual calendars rarely exceed tens of thousands of events, so this is acceptable.</p>

<h4>4.1.4 <code>event_attendees</code></h4>
<table>
<tr><th>Column</th><th>Type</th><th>Constraints</th><th>Description</th></tr>
<tr><td>id</td><td>UUID</td><td><strong>PRIMARY KEY</strong></td><td>Unique row identifier</td></tr>
<tr><td>event_id</td><td>UUID</td><td><strong>FOREIGN KEY → events.id</strong>, NOT NULL</td><td>The event</td></tr>
<tr><td>user_id</td><td>UUID</td><td><strong>FOREIGN KEY → users.id</strong>, NOT NULL</td><td>The attendee</td></tr>
<tr><td>rsvp_status</td><td>ENUM('pending','accepted','declined','tentative')</td><td>NOT NULL, DEFAULT 'pending'</td><td>RSVP status</td></tr>
<tr><td>is_organizer</td><td>BOOLEAN</td><td>NOT NULL, DEFAULT false</td><td>Whether this attendee is the organizer</td></tr>
<tr><td>invited_at</td><td>TIMESTAMP</td><td>NOT NULL</td><td>When the invitation was sent</td></tr>
<tr><td>responded_at</td><td>TIMESTAMP</td><td>NULLABLE</td><td>When the attendee responded</td></tr>
</table>
<p><strong>Why SQL:</strong> This is a classic many-to-many join table between events and users. SQL enforces referential integrity (both event_id and user_id must exist). RSVP updates require ACID guarantees.</p>
<p><strong>Read/Write triggers:</strong> Written when an event with attendees is created, and when an attendee RSVPs. Read when displaying attendee lists on event detail views, and during free/busy lookups (to filter out declined events).</p>
<p><strong>Indexes:</strong></p>
<ul>
  <li><strong>Composite B-tree index on <code>(event_id, user_id)</code>:</strong> Unique constraint + fast lookup for "is user X an attendee of event Y?" Also used when fetching all attendees for an event.</li>
  <li><strong>B-tree index on <code>user_id</code>:</strong> Used during free/busy lookups and to find all events a user is invited to.</li>
</ul>
<p><strong>Sharding:</strong> Co-located with the <code>events</code> table — sharded by <code>event_id</code> (which maps to the same shard as the event's calendar_id). This way, fetching an event and its attendees always hits the same shard.</p>

<h4>4.1.5 <code>calendar_shares</code></h4>
<table>
<tr><th>Column</th><th>Type</th><th>Constraints</th><th>Description</th></tr>
<tr><td>id</td><td>UUID</td><td><strong>PRIMARY KEY</strong></td><td>Unique row identifier</td></tr>
<tr><td>calendar_id</td><td>UUID</td><td><strong>FOREIGN KEY → calendars.id</strong>, NOT NULL</td><td>The shared calendar</td></tr>
<tr><td>shared_with_user_id</td><td>UUID</td><td><strong>FOREIGN KEY → users.id</strong>, NOT NULL</td><td>User the calendar is shared with</td></tr>
<tr><td>permission_level</td><td>ENUM('read','write','free_busy_only')</td><td>NOT NULL</td><td>Access level</td></tr>
<tr><td>created_at</td><td>TIMESTAMP</td><td>NOT NULL</td><td>When the share was created</td></tr>
</table>
<p><strong>Why SQL:</strong> Relational data with foreign keys. Small table. Needs referential integrity.</p>
<p><strong>Read/Write triggers:</strong> Written when a user shares a calendar. Read on every calendar view request (to determine which additional calendars to include) and during free/busy lookups (to check permissions).</p>
<p><strong>Indexes:</strong></p>
<ul>
  <li><strong>B-tree index on <code>shared_with_user_id</code>:</strong> Used to find all calendars shared with a given user. Critical for the calendar view flow.</li>
  <li><strong>Composite unique index on <code>(calendar_id, shared_with_user_id)</code>:</strong> Prevents duplicate shares and enables fast permission checks.</li>
</ul>

<h4>4.1.6 <code>reminders</code></h4>
<table>
<tr><th>Column</th><th>Type</th><th>Constraints</th><th>Description</th></tr>
<tr><td>id</td><td>UUID</td><td><strong>PRIMARY KEY</strong></td><td>Unique reminder identifier</td></tr>
<tr><td>event_id</td><td>UUID</td><td><strong>FOREIGN KEY → events.id</strong>, NOT NULL</td><td>The event this reminder is for</td></tr>
<tr><td>user_id</td><td>UUID</td><td><strong>FOREIGN KEY → users.id</strong>, NOT NULL</td><td>The user to remind</td></tr>
<tr><td>remind_at</td><td>TIMESTAMP</td><td>NOT NULL</td><td>When to fire the reminder (UTC)</td></tr>
<tr><td>reminder_type</td><td>ENUM('push','email','both')</td><td>NOT NULL, DEFAULT 'push'</td><td>Delivery channel</td></tr>
<tr><td>is_sent</td><td>BOOLEAN</td><td>NOT NULL, DEFAULT false</td><td>Whether the reminder has been sent</td></tr>
<tr><td>created_at</td><td>TIMESTAMP</td><td>NOT NULL</td><td>Row creation time</td></tr>
</table>
<p><strong>Why SQL:</strong> Reminders require reliable delivery — ACID guarantees ensure a reminder is not lost. The <code>is_sent</code> flag combined with <code>SELECT FOR UPDATE SKIP LOCKED</code> enables exactly-once delivery semantics across multiple scheduler instances.</p>
<p><strong>Read/Write triggers:</strong> Written when an event with reminders is created, and nightly for upcoming recurring event occurrences. Read every 30 seconds by the Reminder Scheduler.</p>
<p><strong>Indexes:</strong></p>
<ul>
  <li><strong>Composite B-tree index on <code>(is_sent, remind_at)</code>:</strong> This is the critical index for the Reminder Scheduler's polling query: <code>WHERE is_sent = false AND remind_at &lt;= now()</code>. The composite index allows the DB to jump directly to unsent reminders ordered by time. B-tree is chosen for the time-range component. The <code>is_sent</code> prefix partitions the index so that already-sent reminders (the majority) are skipped efficiently.</li>
</ul>

<h3>4.2 NoSQL Tables</h3>

<h4>4.2.1 <code>notification_feed</code></h4>
<table>
<tr><th>Column</th><th>Type</th><th>Constraints</th><th>Description</th></tr>
<tr><td>user_id</td><td>UUID</td><td><strong>PARTITION KEY</strong></td><td>The user who received the notification</td></tr>
<tr><td>timestamp</td><td>TIMESTAMP</td><td><strong>SORT KEY</strong></td><td>When the notification was created (newest first)</td></tr>
<tr><td>notification_type</td><td>STRING</td><td>NOT NULL</td><td>"event_invitation", "rsvp_update", "event_update", "reminder"</td></tr>
<tr><td>event_id</td><td>UUID</td><td>NOT NULL</td><td>Associated event</td></tr>
<tr><td>actor_id</td><td>UUID</td><td>NULLABLE</td><td>User who triggered the notification (e.g., who sent the invite)</td></tr>
<tr><td>message</td><td>STRING</td><td>NOT NULL</td><td>Human-readable notification text</td></tr>
<tr><td>is_read</td><td>BOOLEAN</td><td>NOT NULL, DEFAULT false</td><td>Whether the user has seen this notification</td></tr>
</table>
<p><strong>Why NoSQL:</strong> The notification feed is a write-heavy, append-mostly workload. Access pattern is simple: always query by <code>user_id</code> and order by <code>timestamp</code> (no complex joins needed). NoSQL (wide-column / key-value) provides excellent write throughput, automatic horizontal scaling, and the partition-key + sort-key model maps perfectly to this access pattern. No referential integrity is needed — notifications are fire-and-forget records.</p>
<p><strong>Read/Write triggers:</strong> Written by the Notification Service after sending a notification. Read when a user opens their notification feed / inbox in the app.</p>
<p><strong>Sharding:</strong> Inherently sharded by <code>user_id</code> (partition key). Each user's notifications are co-located. This guarantees single-partition reads for the notification feed, keeping latency low.</p>

<h3>4.3 Denormalization Decisions</h3>
<div class="note-box">
<strong>Denormalization #1 — <code>notification_feed.message</code>:</strong> The notification message is pre-rendered and stored as a string (e.g., "Alice accepted Design Review") rather than storing raw IDs and computing the message at read time. This is denormalized because the actor's display name and event title are duplicated. <strong>Why:</strong> The notification feed is read-heavy and latency-sensitive. Pre-rendering avoids JOIN-like lookups across users and events at read time. The trade-off is that if a user renames an event after a notification was created, the notification text will be stale — but this is acceptable for notification feeds.
</div>
<div class="note-box">
<strong>Normalization elsewhere:</strong> The core SQL tables (events, attendees, calendars) are kept normalized. Events reference calendars by ID, attendees reference events and users by ID. This avoids data duplication and ensures consistency for the source-of-truth data. Since calendar views already benefit from caching, the read overhead of joins is mitigated.
</div>

<!-- ============================== -->
<h2>5. Cache Deep Dive</h2>
<!-- ============================== -->

<h3>5.1 What is Cached</h3>
<p>The in-memory cache stores <strong>calendar view results</strong> — the pre-computed list of events for a specific user, view type, and date range. Cache keys follow the pattern:</p>
<pre>calendar_view:{user_id}:{view_type}:{start_date}</pre>
<p>Example: <code>calendar_view:alice123:week:2026-03-03</code> → JSON array of event objects for Alice's week view starting March 3.</p>
<p>Additionally, <strong>free/busy results</strong> are cached with short TTLs for users who are frequently looked up.</p>

<h3>5.2 Caching Strategy: Write-Through + Read-Through</h3>
<ul>
  <li><strong>Write-through:</strong> When the Event Service creates, updates, or deletes an event, it invalidates (deletes) the affected cache keys after the DB write. For the common case where the user is viewing the same time range they just edited, the Event Service can also eagerly re-populate the cache. This ensures the user immediately sees their own changes.</li>
  <li><strong>Read-through:</strong> When the Calendar Read Service encounters a cache miss, it queries the DB, computes the result (including recurrence expansion), writes the result to the cache, and returns it to the client.</li>
</ul>
<p><strong>Why write-through + read-through:</strong> Calendar data is read-heavy (users check their calendar many times per day) but writes are relatively infrequent. Write-through ensures the cache is always fresh after a write, avoiding serving stale data to the user who just made a change. Read-through lazily populates the cache for other view combinations.</p>

<h3>5.3 Eviction Policy: LRU (Least Recently Used)</h3>
<p>Cache entries are evicted using LRU when memory pressure is high. <strong>Why LRU:</strong> Calendar views for recent and upcoming dates are accessed frequently (today's view, this week's view), while historical views (e.g., 6 months ago) are rarely revisited. LRU naturally keeps hot entries (recent dates) in cache and evicts cold entries (old dates).</p>

<h3>5.4 Expiration Policy: TTL of 5 Minutes</h3>
<p>Each cache entry has a TTL of 5 minutes. <strong>Why 5 minutes:</strong> This balances freshness and performance. Calendar data can change due to other users' actions (e.g., someone else accepting an invite), and a 5-minute TTL ensures these changes propagate without relying solely on write-through invalidation (which only covers local writes). The TTL is short enough to keep data fresh but long enough to meaningfully reduce DB load.</p>

<h3>5.5 Why a Cache is Appropriate Here</h3>
<p>Calendar views are read-heavy (estimated 10:1 read-to-write ratio). The same calendar view data is requested repeatedly (every time the user opens the app). Computing a calendar view involves querying across multiple calendars, expanding recurring events, and merging results — this is computationally expensive and benefits significantly from caching.</p>

<!-- ============================== -->
<h2>6. CDN Deep Dive</h2>
<!-- ============================== -->
<p>A CDN is <strong>used only for static assets</strong> — the calendar application's JavaScript bundles, CSS, images (icons, logos), and fonts. Calendar data itself (events, attendees) is dynamic and user-specific, making it unsuitable for CDN caching.</p>
<p><strong>Why not CDN for calendar data:</strong> Every user sees a different calendar. CDN is designed for content that is the same for many users (static files, public content). User-specific calendar views would have a near-zero cache hit rate at the CDN layer and would require complex cache invalidation logic.</p>

<!-- ============================== -->
<h2>7. Message Queue Deep Dive</h2>
<!-- ============================== -->

<h3>7.1 Purpose</h3>
<p>The message queue decouples the Event Service (producer) from the Notification Service (consumer). Without it, the Event Service would need to synchronously call the Notification Service during event creation, making the request slower and coupling the two services' availability.</p>

<h3>7.2 How Messages are Produced</h3>
<p>After successfully committing the event/RSVP to the database, the Event Service publishes a message to the appropriate topic on the message queue. Message types include:</p>
<ul>
  <li><code>event_invitation</code> — published when an event with attendees is created. One message per attendee. Contains: event_id, attendee_user_id, organizer_user_id, event_title, event_time.</li>
  <li><code>rsvp_update</code> — published when an attendee RSVPs. Contains: event_id, attendee_user_id, rsvp_status, organizer_user_id.</li>
  <li><code>event_update</code> — published when an event is modified. Contains: event_id, change_type (reschedule, cancel, etc.), affected_user_ids.</li>
  <li><code>send_reminder</code> — published by the Reminder Scheduler when a reminder is due. Contains: reminder_id, event_id, user_id, event_title, event_time.</li>
</ul>
<p>The publish is done asynchronously after the DB commit. If the publish fails, a retry mechanism (with exponential backoff) attempts re-delivery. A separate reconciliation job periodically checks for events whose notifications were never published (by comparing events table timestamps with the notification feed).</p>

<h3>7.3 How Messages are Consumed</h3>
<p>The Notification Service runs multiple consumer instances that pull messages from the queue. Messages are processed and acknowledged individually. If processing fails (e.g., push notification delivery fails), the message is returned to the queue (via NACK) and retried. After a configurable number of retries, failed messages are moved to a <strong>dead-letter queue</strong> for manual inspection.</p>
<p><strong>Delivery semantics:</strong> At-least-once. The Notification Service is idempotent — it uses the message's unique ID (e.g., reminder_id, combination of event_id + user_id + action) to deduplicate.</p>

<h3>7.4 Why a Message Queue (vs Alternatives)</h3>
<ul>
  <li><strong>Why not synchronous HTTP calls:</strong> Coupling Event Service to Notification Service would increase latency for the user and reduce fault tolerance. If the Notification Service is down, event creation would fail.</li>
  <li><strong>Why not pub/sub:</strong> Pub/sub would also work here. However, a message queue with explicit acknowledgment and dead-letter queues provides stronger delivery guarantees for critical notifications. In a pub/sub model, if a subscriber is temporarily down, messages can be lost (depending on the implementation). The message queue's persistent, pull-based model is safer for notifications and reminders where reliability is paramount.</li>
  <li><strong>Why not polling the DB directly:</strong> The Reminder Scheduler does poll the DB, but for real-time notifications (invitations, RSVPs), polling would introduce unacceptable latency. The message queue provides near-instant delivery.</li>
</ul>

<!-- ============================== -->
<h2>8. Scaling Considerations</h2>
<!-- ============================== -->

<h3>8.1 Load Balancers</h3>
<p>Load balancers are placed at two levels:</p>
<ol>
  <li><strong>External Load Balancer (Client → API Gateway):</strong> An L7 load balancer that distributes client traffic across multiple API Gateway instances. Uses round-robin with health checks. Terminates TLS. Provides DDoS protection and rate limiting at the edge.</li>
  <li><strong>Internal Load Balancers (API Gateway → Microservices):</strong> L4/L7 load balancers (or service mesh sidecar proxies) distribute traffic from the API Gateway to the Event Service, Calendar Read Service, and Free/Busy Service instances. Uses least-connections to optimize utilization.</li>
</ol>
<p>All services (Event Service, Calendar Read Service, Free/Busy Service, Notification Service) are stateless, so they scale horizontally by adding more instances behind load balancers.</p>

<h3>8.2 Database Scaling</h3>
<ul>
  <li><strong>Read replicas:</strong> Deploy read replicas of the SQL database. The Calendar Read Service and Free/Busy Service read from replicas, offloading the primary. Slight replication lag (seconds) is acceptable since the cache handles most reads, and eventual consistency for other users' event changes is tolerable.</li>
  <li><strong>Sharding:</strong> As described, the events table is sharded by <code>calendar_id</code>. The notification_feed NoSQL table is auto-sharded by <code>user_id</code>.</li>
  <li><strong>Connection pooling:</strong> All services use connection pools to the database to avoid overwhelming the DB with connections.</li>
</ul>

<h3>8.3 Cache Scaling</h3>
<p>The cache layer scales by running a distributed cache cluster with consistent hashing for key distribution. Adding nodes rebalances keys with minimal disruption.</p>

<h3>8.4 Message Queue Scaling</h3>
<p>Partition the message queue by topic (invitation, reminder, rsvp_update). Each partition can be consumed by multiple consumer instances in a consumer group, enabling parallel processing. Add partitions and consumers as throughput demands grow.</p>

<h3>8.5 Reminder Scheduler Scaling</h3>
<p>Multiple Reminder Scheduler instances run concurrently. The <code>SELECT FOR UPDATE SKIP LOCKED</code> pattern ensures each reminder is claimed by exactly one instance, preventing duplicates. Adding more instances increases throughput linearly.</p>

<h3>8.6 Estimated Traffic</h3>
<p>For 100 million users, assuming each user views their calendar ~5 times/day and creates ~0.5 events/day:</p>
<ul>
  <li>Reads: 500 million/day ≈ ~5,800 QPS</li>
  <li>Writes: 50 million/day ≈ ~580 QPS</li>
  <li>With cache hit rate of 80%, DB read QPS ≈ ~1,160</li>
</ul>

<!-- ============================== -->
<h2>9. Tradeoffs &amp; Deep Dives</h2>
<!-- ============================== -->

<h3>9.1 Recurring Events: Lazy Expansion vs Pre-materialization</h3>
<p><strong>Chosen approach: Lazy expansion (compute on read).</strong></p>
<ul>
  <li><strong>Pros:</strong> Storage-efficient (one row per recurring series, not one row per occurrence). No need to update thousands of rows when a recurring event is modified. Supports infinite recurrences.</li>
  <li><strong>Cons:</strong> Read-time computation overhead (RRULE expansion). Reminder scheduling requires a nightly materialization job for the next 24–48 hours.</li>
  <li><strong>Trade-off:</strong> We accept slightly more complex read logic (RRULE expansion) in exchange for dramatically simpler write logic and storage efficiency. The cache mitigates the read overhead.</li>
</ul>

<h3>9.2 Recurring Event Exceptions</h3>
<p>When a user edits a single occurrence of a recurring event (e.g., moves next Tuesday's standup to 10:00 AM), the system creates an <strong>exception instance</strong> — a new event row with <code>recurring_master_id</code> pointing to the master event and <code>original_start_time</code> set to the occurrence being overridden. The Recurrence Expander checks for exceptions and replaces the virtual occurrence with the exception instance. Deleting a single occurrence creates an exception with a "cancelled" status.</p>
<p>"This and following" modifications split the recurring series: the original master's RRULE is updated to end before the modification date, and a new master event is created for the remaining occurrences.</p>

<h3>9.3 Time Zone Handling</h3>
<p>All times are stored in UTC in the database. The event's <code>timezone</code> field records the original timezone for display purposes and for recurring events (so "9:00 AM Eastern every day" correctly adjusts for daylight saving time). The Recurrence Expander computes occurrences in the event's original timezone, then converts to UTC. The client converts UTC to the viewer's local timezone for display.</p>

<h3>9.4 Consistency Model</h3>
<p>Strong consistency for the user making a change (write-through cache ensures they see their own writes immediately). Eventual consistency (within seconds) for other users, via cache TTL expiration and DB replication lag. This trade-off is acceptable: it's fine if Alice sees Bob's new event a few seconds late, but it's not acceptable if Bob doesn't see his own event after creating it.</p>

<h3>9.5 Conflict Detection for Overlapping Events</h3>
<p>The system does NOT prevent overlapping events by default (users may intentionally have conflicts). However, the Free/Busy Service provides advisory conflict detection. When creating an event, the client can optionally call <code>POST /freebusy</code> and display a warning like "You have a conflicting event at this time."</p>

<!-- ============================== -->
<h2>10. Alternative Approaches</h2>
<!-- ============================== -->

<h3>10.1 NoSQL for Events (Instead of SQL)</h3>
<p><strong>Alternative:</strong> Store events in a NoSQL wide-column database with partition key = calendar_id and sort key = start_time.</p>
<p><strong>Why not chosen:</strong> While the read pattern (query by calendar_id + time range) maps well to NoSQL, calendar events require ACID transactions (creating an event with attendees atomically), complex queries (free/busy across multiple users), and referential integrity. SQL's transaction support, JOINs, and constraints provide stronger guarantees. The read performance gap is closed by the cache layer.</p>

<h3>10.2 Pre-materializing Recurring Events (Instead of Lazy Expansion)</h3>
<p><strong>Alternative:</strong> When a user creates a recurring event, pre-generate individual event rows for the next N years.</p>
<p><strong>Why not chosen:</strong> A daily recurring event over 5 years = ~1,825 rows per event. For millions of users this explodes storage. Editing "all occurrences" requires updating thousands of rows. Infinite recurrences are impossible to pre-generate. The lazy expansion approach is far more efficient.</p>

<h3>10.3 WebSockets for Real-time Calendar Updates</h3>
<p><strong>Alternative:</strong> Use WebSocket connections so that when one user modifies a shared event, all other viewers see the update instantly.</p>
<p><strong>Why not chosen as primary mechanism:</strong> Real-time push is a nice-to-have for calendars but not essential. Calendar data changes infrequently (a few times per day), and the 5-minute cache TTL provides near-real-time updates. WebSocket adds significant complexity: managing persistent connections, handling reconnection, maintaining a WebSocket connection registry, and scaling socket servers. For a calendar system, the complexity cost outweighs the benefit. Push notifications (for invitations and RSVPs) provide sufficient real-time UX for the most important interactions. WebSockets could be added as a future optimization for collaborative editing scenarios.</p>

<h3>10.4 Event Sourcing / CQRS</h3>
<p><strong>Alternative:</strong> Use event sourcing to record all changes as immutable events (EventCreated, EventUpdated, AttendeeAdded, RSVPChanged) and build read models from the event log.</p>
<p><strong>Why not chosen:</strong> Adds significant architectural complexity. Calendar data has a relatively simple write model. The audit trail benefit can be achieved with simpler approaches (e.g., an <code>updated_at</code> timestamp and a separate audit log table). CQRS is overkill for this use case.</p>

<h3>10.5 Graph Database for Social/Sharing Relationships</h3>
<p><strong>Alternative:</strong> Use a graph database to model user-calendar and user-event relationships.</p>
<p><strong>Why not chosen:</strong> The relationships (user → calendar, event → attendees, calendar → shared_with) are well-modeled by SQL foreign keys and join tables. The access patterns don't require graph traversals (no "friends of friends" queries). SQL is simpler and sufficient.</p>

<h3>10.6 Polling Instead of Message Queue for Notifications</h3>
<p><strong>Alternative:</strong> Instead of a message queue, have the Notification Service poll the events and event_attendees tables for new invitations and RSVPs.</p>
<p><strong>Why not chosen:</strong> Polling introduces latency (notifications delayed until next poll interval). High-frequency polling wastes database resources. The message queue provides near-instant, event-driven processing with minimal overhead.</p>

<!-- ============================== -->
<h2>11. Additional Considerations</h2>
<!-- ============================== -->

<h3>11.1 CalDAV / iCal Interoperability</h3>
<p>To integrate with external calendar apps (Apple Calendar, Thunderbird), the system should expose a CalDAV endpoint or generate .ics (iCalendar) feeds. This allows users to subscribe to their calendars from third-party apps. The RRULE format used for recurrence is directly from the iCalendar (RFC 5545) standard, ensuring compatibility.</p>

<h3>11.2 Rate Limiting &amp; Abuse Prevention</h3>
<p>The API Gateway enforces rate limits per user to prevent abuse (e.g., creating thousands of events programmatically). Recommended limits: 100 event creates per minute per user, 1000 reads per minute per user.</p>

<h3>11.3 Soft Deletes</h3>
<p>Events are soft-deleted (a <code>deleted_at</code> timestamp is set) rather than hard-deleted. This enables "undo" functionality, audit trails, and prevents data loss from accidental deletions. Soft-deleted events are excluded from queries via a <code>WHERE deleted_at IS NULL</code> clause (handled by the index).</p>

<h3>11.4 Idempotency</h3>
<p>The Event Service supports idempotent event creation by accepting an optional client-generated <code>idempotency_key</code>. If a duplicate request is received (e.g., due to a network retry), the service returns the already-created event instead of creating a duplicate.</p>

<h3>11.5 Backup &amp; Disaster Recovery</h3>
<p>The SQL database is backed up with continuous WAL (Write-Ahead Log) archiving for point-in-time recovery. Cross-region replication provides disaster recovery for regional failures.</p>

<h3>11.6 Monitoring &amp; Alerting</h3>
<p>Key metrics to monitor: reminder delivery latency (p50, p99), cache hit rate, DB query latency, message queue depth (backlog), API error rates. Alerts should fire if reminder latency exceeds 1 minute or message queue depth grows unchecked.</p>

<!-- ============================== -->
<h2>12. Vendor Recommendations</h2>
<!-- ============================== -->

<div class="note-box">
<strong>Note:</strong> The design above is vendor-agnostic. The following are recommendations based on the access patterns and requirements described.
</div>

<table>
<tr><th>Component</th><th>Vendor Options</th><th>Rationale</th></tr>
<tr>
  <td>SQL Database (Event DB)</td>
  <td>PostgreSQL, MySQL, Amazon Aurora, Google Cloud Spanner</td>
  <td>PostgreSQL is recommended for its excellent support for range queries (B-tree indexes on timestamps), full-text search, and the <code>SELECT FOR UPDATE SKIP LOCKED</code> feature critical for the Reminder Scheduler. Cloud Spanner is an option if global distribution is needed. Aurora provides managed scaling.</td>
</tr>
<tr>
  <td>NoSQL Database (Notification Feed)</td>
  <td>Apache Cassandra, Amazon DynamoDB, Google Bigtable</td>
  <td>Wide-column stores are ideal for the partition-key + sort-key access pattern. Cassandra provides tunable consistency and excellent write throughput. DynamoDB offers fully managed operation with auto-scaling.</td>
</tr>
<tr>
  <td>In-Memory Cache</td>
  <td>Redis, Memcached</td>
  <td>Redis is preferred for its support for TTL, LRU eviction, and rich data structures (e.g., storing JSON-serialized calendar views). Redis Cluster provides horizontal scaling with consistent hashing.</td>
</tr>
<tr>
  <td>Message Queue</td>
  <td>Apache Kafka, RabbitMQ, Amazon SQS</td>
  <td>Kafka is recommended for its durability, partitioning, and high throughput. It also provides message retention, enabling replay if needed. RabbitMQ is simpler for lower-scale deployments. SQS offers a fully managed option.</td>
</tr>
<tr>
  <td>Push Notifications</td>
  <td>APNs (Apple), FCM (Google)</td>
  <td>Platform-mandated: APNs is required for iOS push, FCM for Android. These are not interchangeable.</td>
</tr>
<tr>
  <td>Load Balancer</td>
  <td>Nginx, HAProxy, AWS ALB, Google Cloud Load Balancer</td>
  <td>Nginx and HAProxy are proven L7 load balancers with health checks, TLS termination, and round-robin/least-connections. Cloud-managed LBs reduce operational overhead.</td>
</tr>
<tr>
  <td>Full-Text Search (if advanced search needed)</td>
  <td>Elasticsearch, Apache Solr, Meilisearch</td>
  <td>If the built-in SQL full-text index is insufficient (e.g., need fuzzy matching, autocomplete, or search across millions of events), an inverted index engine like Elasticsearch provides superior search capabilities.</td>
</tr>
</table>

<script>
  mermaid.initialize({ startOnLoad: true, theme: 'base', themeVariables: { primaryColor: '#dbeafe', primaryTextColor: '#1e3a5f', primaryBorderColor: '#3b82f6', lineColor: '#64748b', secondaryColor: '#f1f5f9', tertiaryColor: '#fff' } });
</script>

</body>
</html>
