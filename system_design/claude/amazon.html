<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>System Design: Amazon E-Commerce</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <script>mermaid.initialize({startOnLoad:true, theme:'neutral', flowchart:{useMaxWidth:true, htmlLabels:true}});</script>
    <style>
        :root {
            --primary: #232f3e;
            --accent: #ff9900;
            --bg: #f8f9fa;
            --card: #ffffff;
            --text: #1a1a2e;
            --border: #dee2e6;
            --code-bg: #2d2d2d;
            --success: #28a745;
            --info: #17a2b8;
            --warning: #ffc107;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg);
            color: var(--text);
            line-height: 1.7;
            padding: 0;
        }
        header {
            background: var(--primary);
            color: #fff;
            padding: 40px 60px;
            border-bottom: 4px solid var(--accent);
        }
        header h1 { font-size: 2.4em; margin-bottom: 8px; }
        header p { font-size: 1.1em; opacity: 0.85; }
        .container { max-width: 1200px; margin: 0 auto; padding: 30px 60px 60px; }
        h2 {
            font-size: 1.8em;
            color: var(--primary);
            border-bottom: 3px solid var(--accent);
            padding-bottom: 10px;
            margin: 50px 0 20px;
        }
        h3 {
            font-size: 1.35em;
            color: var(--primary);
            margin: 30px 0 12px;
        }
        h4 {
            font-size: 1.1em;
            color: #444;
            margin: 20px 0 10px;
        }
        p, li { margin-bottom: 8px; }
        ul, ol { padding-left: 28px; margin-bottom: 16px; }
        .card {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 24px;
            margin: 16px 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.06);
        }
        .example-card {
            background: #fff8e1;
            border-left: 4px solid var(--accent);
            padding: 18px 22px;
            margin: 14px 0;
            border-radius: 0 8px 8px 0;
        }
        .example-card strong { color: #e65100; }
        .diagram-container {
            background: #fff;
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 24px;
            margin: 20px 0;
            overflow-x: auto;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 16px 0;
            font-size: 0.95em;
        }
        th {
            background: var(--primary);
            color: #fff;
            padding: 12px 16px;
            text-align: left;
            font-weight: 600;
        }
        td {
            padding: 10px 16px;
            border-bottom: 1px solid var(--border);
        }
        tr:nth-child(even) { background: #f4f6f8; }
        tr:hover { background: #e8ecf0; }
        code {
            background: #eef;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'SF Mono', 'Fira Code', monospace;
            font-size: 0.9em;
        }
        pre {
            background: var(--code-bg);
            color: #f8f8f2;
            padding: 18px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 12px 0;
            font-size: 0.9em;
        }
        .tag {
            display: inline-block;
            padding: 3px 10px;
            border-radius: 12px;
            font-size: 0.8em;
            font-weight: 600;
            margin: 2px 4px;
        }
        .tag-sql { background: #d4edda; color: #155724; }
        .tag-nosql { background: #cce5ff; color: #004085; }
        .tag-cache { background: #fff3cd; color: #856404; }
        .tag-queue { background: #f8d7da; color: #721c24; }
        .tag-grpc { background: #e2d5f1; color: #4a148c; }
        .tag-http { background: #d1ecf1; color: #0c5460; }
        .toc {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 24px 32px;
            margin: 20px 0;
        }
        .toc a { color: var(--primary); text-decoration: none; }
        .toc a:hover { color: var(--accent); text-decoration: underline; }
        .toc ol { counter-reset: toc-counter; list-style: none; padding-left: 0; }
        .toc > ol > li { counter-increment: toc-counter; margin-bottom: 6px; }
        .toc > ol > li::before {
            content: counter(toc-counter) ". ";
            font-weight: 700;
            color: var(--accent);
        }
        .highlight { background: #fff3cd; padding: 2px 4px; border-radius: 3px; }
        .note {
            background: #e7f5ff;
            border-left: 4px solid var(--info);
            padding: 14px 18px;
            margin: 14px 0;
            border-radius: 0 8px 8px 0;
        }
        .warning {
            background: #fff3cd;
            border-left: 4px solid var(--warning);
            padding: 14px 18px;
            margin: 14px 0;
            border-radius: 0 8px 8px 0;
        }
        .deep-dive {
            background: #f0f4ff;
            border: 1px solid #c3d4f7;
            border-radius: 8px;
            padding: 20px;
            margin: 16px 0;
        }
        .deep-dive h4 { color: #1a237e; margin-top: 0; }
        .api-block {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 14px 18px;
            border-radius: 6px;
            margin: 8px 0;
            font-family: 'SF Mono', 'Fira Code', monospace;
            font-size: 0.88em;
        }
        .api-block .method { font-weight: bold; }
        .api-block .get { color: #4ec9b0; }
        .api-block .post { color: #dcdcaa; }
        .api-block .put { color: #569cd6; }
        .api-block .delete { color: #f44747; }
        .api-block .patch { color: #ce9178; }
    </style>
</head>
<body>

<header>
    <h1>üõí System Design: Amazon (E-Commerce Platform)</h1>
    <p>A comprehensive system design for a large-scale e-commerce platform supporting product search, cart management, order placement, order tracking, and seller management.</p>
</header>

<div class="container">

<!-- ============================================================ -->
<!-- TABLE OF CONTENTS -->
<!-- ============================================================ -->
<div class="toc">
    <h3>Table of Contents</h3>
    <ol>
        <li><a href="#func-req">Functional Requirements</a></li>
        <li><a href="#nonfunc-req">Non-Functional Requirements</a></li>
        <li><a href="#flow1">Flow 1: Product Search &amp; Discovery</a></li>
        <li><a href="#flow2">Flow 2: Product Detail Page</a></li>
        <li><a href="#flow3">Flow 3: Cart Management</a></li>
        <li><a href="#flow4">Flow 4: Checkout &amp; Order Placement</a></li>
        <li><a href="#flow5">Flow 5: Order Fulfillment &amp; Tracking</a></li>
        <li><a href="#flow6">Flow 6: Seller Product Management</a></li>
        <li><a href="#combined">Combined Overall Diagram</a></li>
        <li><a href="#schema">Database Schema</a></li>
        <li><a href="#cdn-cache">CDN &amp; Caching Deep Dive</a></li>
        <li><a href="#mq-deep">Message Queue Deep Dive</a></li>
        <li><a href="#protocols">Protocol Deep Dive (gRPC, SSE, HTTP)</a></li>
        <li><a href="#scaling">Scaling Considerations</a></li>
        <li><a href="#tradeoffs">Tradeoffs &amp; Deep Dives</a></li>
        <li><a href="#alternatives">Alternative Approaches</a></li>
        <li><a href="#additional">Additional Information</a></li>
        <li><a href="#vendors">Vendor Section</a></li>
    </ol>
</div>

<!-- ============================================================ -->
<!-- 1. FUNCTIONAL REQUIREMENTS -->
<!-- ============================================================ -->
<h2 id="func-req">1. Functional Requirements</h2>
<div class="card">
    <ol>
        <li><strong>Product Search &amp; Discovery:</strong> Users can search for products by keyword, browse by category, apply filters (price range, ratings, brand, Prime eligibility), and sort results. Autocomplete/typeahead suggestions are provided.</li>
        <li><strong>Product Detail Page:</strong> Users can view a product's full details including images, description, price, seller information, available inventory status, reviews, ratings, and related product recommendations.</li>
        <li><strong>Shopping Cart:</strong> Users can add products to a persistent cart, update item quantities, remove items, and see real-time price totals. Cart persists across sessions for authenticated users.</li>
        <li><strong>Checkout &amp; Order Placement:</strong> Users can enter a shipping address, select a payment method, review their order, and place it. Inventory is reserved upon order placement and payment is processed. Order confirmation is sent via email/push notification.</li>
        <li><strong>Order Tracking:</strong> Users can view order history, check real-time order/shipping status, receive status-change notifications (shipped, out for delivery, delivered), and initiate returns.</li>
        <li><strong>Seller Product Management:</strong> Sellers can list new products (with images, descriptions, pricing), update product information, manage inventory quantities, and view sales analytics.</li>
        <li><strong>Reviews &amp; Ratings:</strong> Authenticated buyers can submit a rating (1‚Äì5 stars) and a text review (optionally with images) for products they have purchased.</li>
        <li><strong>Recommendations:</strong> The system recommends products based on browsing history, purchase history, and collaborative filtering ("Customers who bought X also bought Y").</li>
    </ol>
</div>

<!-- ============================================================ -->
<!-- 2. NON-FUNCTIONAL REQUIREMENTS -->
<!-- ============================================================ -->
<h2 id="nonfunc-req">2. Non-Functional Requirements</h2>
<div class="card">
    <table>
        <tr><th>Requirement</th><th>Target</th><th>Rationale</th></tr>
        <tr><td><strong>Availability</strong></td><td>99.99% uptime</td><td>Revenue loss for every second of downtime; global user base expects 24/7 access.</td></tr>
        <tr><td><strong>Latency ‚Äì Search</strong></td><td>&lt; 200 ms (p99)</td><td>Users abandon slow searches. Fast results drive conversions.</td></tr>
        <tr><td><strong>Latency ‚Äì Page Load</strong></td><td>&lt; 500 ms (p99)</td><td>Product pages must render quickly to minimize bounce rate.</td></tr>
        <tr><td><strong>Throughput</strong></td><td>Millions of concurrent users; 100K+ orders/min at peak</td><td>Must sustain traffic spikes during flash sales (e.g., Prime Day, Black Friday).</td></tr>
        <tr><td><strong>Consistency ‚Äì Orders/Inventory</strong></td><td>Strong consistency</td><td>Prevent overselling; payment and inventory must be ACID-compliant.</td></tr>
        <tr><td><strong>Consistency ‚Äì Search/Reviews</strong></td><td>Eventual consistency (seconds)</td><td>A few seconds of staleness is acceptable for search index and review aggregates.</td></tr>
        <tr><td><strong>Durability</strong></td><td>Zero data loss for orders/payments</td><td>Financial data is irrecoverable; requires synchronous replication.</td></tr>
        <tr><td><strong>Scalability</strong></td><td>Horizontal scaling for all services</td><td>Stateless services behind load balancers; shardable databases.</td></tr>
        <tr><td><strong>Fault Tolerance</strong></td><td>Graceful degradation</td><td>Recommendation or review service failures must not block checkout.</td></tr>
        <tr><td><strong>Security</strong></td><td>PCI-DSS compliant for payments; TLS everywhere</td><td>Protect user data and payment information.</td></tr>
        <tr><td><strong>Global Reach</strong></td><td>Multi-region deployment with CDN</td><td>Serve users with low latency regardless of geographic location.</td></tr>
    </table>
</div>

<!-- ============================================================ -->
<!-- 3. FLOW 1: PRODUCT SEARCH & DISCOVERY -->
<!-- ============================================================ -->
<h2 id="flow1">3. Flow 1: Product Search &amp; Discovery</h2>

<div class="diagram-container">
<pre class="mermaid">
graph TD
    Client["üë§ Client (Browser/App)"]
    LB["‚öñÔ∏è Load Balancer"]
    GW["üö™ API Gateway"]
    SS["üîç Search Service"]
    SC[("üóÑÔ∏è Search Cache<br/>(In-Memory Cache)")]
    SI[("üìá Search Index<br/>(Inverted Index)")]
    PS["üì¶ Product Service"]
    PC[("üóÑÔ∏è Product Cache<br/>(In-Memory Cache)")]
    PDB[("üíæ Product DB<br/>(NoSQL ‚Äì Document)")]
    CDN["üåê CDN"]
    OS[("üóÉÔ∏è Object Storage<br/>(Images)")]

    Client -->|"HTTPS GET<br/>/api/v1/search?q=..."| LB
    LB --> GW
    GW -->|"Auth + Rate Limit"| SS
    SS -->|"1. Check cache"| SC
    SS -->|"2. Cache miss ‚Üí query"| SI
    SS -->|"3. Fetch product summaries"| PS
    PS -->|"Check cache"| PC
    PS -->|"Cache miss"| PDB
    Client -->|"Static assets &amp; images"| CDN
    CDN -->|"Origin pull"| OS

    style Client fill:#e3f2fd,stroke:#1565c0,stroke-width:2px
    style LB fill:#fff3e0,stroke:#e65100,stroke-width:2px
    style GW fill:#fff3e0,stroke:#e65100,stroke-width:2px
    style SS fill:#e8f5e9,stroke:#2e7d32,stroke-width:2px
    style SC fill:#fff8e1,stroke:#f9a825,stroke-width:2px
    style SI fill:#fce4ec,stroke:#c62828,stroke-width:2px
    style PS fill:#e8f5e9,stroke:#2e7d32,stroke-width:2px
    style PC fill:#fff8e1,stroke:#f9a825,stroke-width:2px
    style PDB fill:#e8eaf6,stroke:#283593,stroke-width:2px
    style CDN fill:#f3e5f5,stroke:#6a1b9a,stroke-width:2px
    style OS fill:#e8eaf6,stroke:#283593,stroke-width:2px
</pre>
</div>

<h3>Examples</h3>

<div class="example-card">
    <strong>Example 1 ‚Äì Basic keyword search (cache miss):</strong><br/>
    User types "wireless headphones" into the search bar and presses Enter. The client sends an <code>HTTPS GET /api/v1/search?q=wireless+headphones&page=1</code> to the Load Balancer. The Load Balancer forwards to the API Gateway, which authenticates the request (JWT token) and applies rate limiting. The API Gateway routes to the Search Service. The Search Service first checks the Search Cache for the key <code>hash("wireless headphones:page1:no-filters")</code>. It's a cache miss, so the Search Service queries the Search Index (inverted index) with the tokenized query ["wireless", "headphones"], combining the posting lists and ranking by relevance (TF-IDF + popularity). The index returns the top 20 product IDs. The Search Service calls the Product Service with those IDs to fetch summary data (name, price, thumbnail URL, average rating). The Product Service checks its cache for each product ID, fetches any misses from the Product DB (NoSQL document store), and returns the summaries. The Search Service combines the results, writes them to the Search Cache (TTL: 2 minutes), and returns the response to the client. Product images are loaded separately from the CDN.
</div>

<div class="example-card">
    <strong>Example 2 ‚Äì Filtered search (cache hit):</strong><br/>
    User searches "wireless headphones" with filter <code>price: $20-$50</code> and <code>rating: 4+</code>. The request <code>HTTPS GET /api/v1/search?q=wireless+headphones&min_price=20&max_price=50&min_rating=4&page=1</code> arrives at the Search Service. The cache key includes the filters: <code>hash("wireless headphones:page1:price_20_50:rating_4")</code>. If another user recently performed the same search, this is a cache hit. The cached JSON response is returned immediately (<10 ms), bypassing the Search Index and Product DB entirely.
</div>

<div class="example-card">
    <strong>Example 3 ‚Äì Autocomplete/typeahead:</strong><br/>
    As the user types "wire" into the search bar, the client sends <code>HTTPS GET /api/v1/search/suggest?prefix=wire</code> after a 150 ms debounce. The Search Service looks up the prefix trie / completion index and returns the top 8 suggestions: ["wireless headphones", "wireless earbuds", "wireless charger", "wire stripper", ...]. These are served from an in-memory data structure with &lt; 50 ms latency.
</div>

<h3>Component Deep Dive</h3>

<div class="deep-dive">
    <h4>Load Balancer</h4>
    <p>Sits between clients and the API Gateway. Uses <strong>Layer 7 (application-level)</strong> load balancing to inspect HTTP headers and route requests. Employs <strong>round-robin with health checks</strong> to distribute traffic evenly across API Gateway instances. Terminates TLS to offload encryption from backend services.</p>
</div>

<div class="deep-dive">
    <h4>API Gateway</h4>
    <p>Single entry point for all client requests. Responsibilities:</p>
    <ul>
        <li><strong>Authentication:</strong> Validates JWT tokens from the <code>Authorization</code> header.</li>
        <li><strong>Rate Limiting:</strong> Token bucket algorithm per user (e.g., 100 requests/sec).</li>
        <li><strong>Request Routing:</strong> Routes to the appropriate microservice based on URL path.</li>
        <li><strong>Protocol Translation:</strong> Accepts HTTPS from clients, can forward as gRPC internally.</li>
    </ul>
</div>

<div class="deep-dive">
    <h4>Search Service</h4>
    <p><span class="tag tag-http">HTTP</span></p>
    <ul>
        <li><strong>Protocol:</strong> HTTP/HTTPS (client-facing)</li>
        <li><strong>Endpoint:</strong></li>
    </ul>
    <div class="api-block">
        <span class="method get">GET</span> /api/v1/search?q={query}&amp;category={cat}&amp;min_price={min}&amp;max_price={max}&amp;min_rating={rating}&amp;sort={relevance|price_asc|price_desc|rating}&amp;page={page}&amp;page_size={size}
    </div>
    <p><strong>Input:</strong> Query string, optional filters (category, price range, rating, brand), sort order, pagination params.</p>
    <p><strong>Output:</strong></p>
    <pre>{
  "results": [
    {"product_id": "p123", "name": "Wireless Headphones X", "price": 29.99,
     "image_url": "https://cdn.example.com/img/p123_thumb.jpg",
     "avg_rating": 4.3, "review_count": 1842, "prime_eligible": true}
  ],
  "total_results": 5420,
  "page": 1,
  "page_size": 20,
  "facets": {"brands": [{"name": "BrandA", "count": 312}], "price_ranges": [...]}
}</pre>
    <p>Typeahead endpoint:</p>
    <div class="api-block">
        <span class="method get">GET</span> /api/v1/search/suggest?prefix={prefix}
    </div>
    <p><strong>Output:</strong> <code>{"suggestions": ["wireless headphones", "wireless charger", ...]}</code></p>
</div>

<div class="deep-dive">
    <h4>Search Index (Inverted Index)</h4>
    <p>A distributed search index storing an inverted index of product data. Each document in the index contains: <code>product_id</code>, <code>name</code>, <code>description</code>, <code>category</code>, <code>brand</code>, <code>price</code>, <code>avg_rating</code>, <code>image_url</code>. The inverted index maps each token to a posting list of product IDs. Supports full-text search, faceted filtering, and relevance ranking. Updated asynchronously when products are created or modified (via message queue).</p>
</div>

<div class="deep-dive">
    <h4>Product Service</h4>
    <p><span class="tag tag-http">HTTP</span> <span class="tag tag-grpc">gRPC (internal)</span></p>
    <p>Serves product data. Exposes both an HTTP endpoint for the API Gateway and a gRPC endpoint for internal service-to-service calls (from Search Service, Cart Service, etc.).</p>
    <div class="api-block">
        <span class="method get">GET</span> /api/v1/products/{product_id}
    </div>
    <p><strong>Input:</strong> product_id (path param)</p>
    <p><strong>Output:</strong> Full product details (see Flow 2 for complete schema).</p>
    <p><strong>Internal gRPC:</strong> <code>GetProductBatch(product_ids[]) ‚Üí products[]</code> ‚Äî used by Search Service to fetch summaries for multiple products in a single call, avoiding N+1 queries.</p>
</div>

<div class="deep-dive">
    <h4>Search Cache (In-Memory Cache)</h4>
    <p>Caches search results keyed by a hash of (query + filters + sort + page). Details in the <a href="#cdn-cache">CDN &amp; Caching Deep Dive</a> section.</p>
</div>

<div class="deep-dive">
    <h4>CDN &amp; Object Storage</h4>
    <p>The CDN caches and serves product images (multiple resolutions: thumbnail, medium, large), static website assets (JS, CSS, fonts), and pre-rendered category landing pages. Object Storage is the origin for all images and media. Details in the <a href="#cdn-cache">CDN &amp; Caching Deep Dive</a> section.</p>
</div>


<!-- ============================================================ -->
<!-- 4. FLOW 2: PRODUCT DETAIL PAGE -->
<!-- ============================================================ -->
<h2 id="flow2">4. Flow 2: Product Detail Page</h2>

<div class="diagram-container">
<pre class="mermaid">
graph TD
    Client["üë§ Client"]
    LB["‚öñÔ∏è Load Balancer"]
    GW["üö™ API Gateway"]
    PS["üì¶ Product Service"]
    PC[("üóÑÔ∏è Product Cache")]
    PDB[("üíæ Product DB<br/>(NoSQL ‚Äì Document)")]
    RS["‚≠ê Review Service"]
    RDB[("üíæ Review DB<br/>(NoSQL ‚Äì Document)")]
    IS["üìä Inventory Service"]
    IDB[("üíæ Inventory DB<br/>(SQL)")]
    REC["ü§ñ Recommendation Service"]
    ML[("üß† ML Model Store")]
    UH[("üìú User History<br/>(NoSQL ‚Äì KV)")]
    CDN["üåê CDN"]
    OS[("üóÉÔ∏è Object Storage")]

    Client -->|"HTTPS GET<br/>/api/v1/products/{id}"| LB
    LB --> GW
    GW --> PS
    PS --> PC
    PS --> PDB

    GW --> RS
    RS --> RDB

    GW --> IS
    IS --> IDB

    GW --> REC
    REC --> ML
    REC --> UH

    Client --> CDN
    CDN --> OS

    style Client fill:#e3f2fd,stroke:#1565c0,stroke-width:2px
    style LB fill:#fff3e0,stroke:#e65100,stroke-width:2px
    style GW fill:#fff3e0,stroke:#e65100,stroke-width:2px
    style PS fill:#e8f5e9,stroke:#2e7d32,stroke-width:2px
    style RS fill:#e8f5e9,stroke:#2e7d32,stroke-width:2px
    style IS fill:#e8f5e9,stroke:#2e7d32,stroke-width:2px
    style REC fill:#e8f5e9,stroke:#2e7d32,stroke-width:2px
    style PC fill:#fff8e1,stroke:#f9a825,stroke-width:2px
    style PDB fill:#e8eaf6,stroke:#283593,stroke-width:2px
    style RDB fill:#e8eaf6,stroke:#283593,stroke-width:2px
    style IDB fill:#e8eaf6,stroke:#283593,stroke-width:2px
    style ML fill:#fce4ec,stroke:#c62828,stroke-width:2px
    style UH fill:#e8eaf6,stroke:#283593,stroke-width:2px
    style CDN fill:#f3e5f5,stroke:#6a1b9a,stroke-width:2px
    style OS fill:#e8eaf6,stroke:#283593,stroke-width:2px
</pre>
</div>

<h3>Examples</h3>

<div class="example-card">
    <strong>Example 1 ‚Äì Viewing a popular product (cache hit):</strong><br/>
    User clicks on "Wireless Headphones X" from search results. The client sends <code>HTTPS GET /api/v1/products/p123</code>. The API Gateway fans out three parallel internal requests: (1) Product Service for product details ‚Äî hits the Product Cache immediately; (2) Review Service for the top reviews; (3) Inventory Service for stock status. Simultaneously, a fourth call goes to the Recommendation Service, which uses the user's browsing history and the current product ID to generate "Frequently bought together" and "Customers also viewed" sections. The API Gateway aggregates all four responses and returns a single JSON payload. Product images (carousel) load from the CDN.
</div>

<div class="example-card">
    <strong>Example 2 ‚Äì Viewing a niche product (cache miss, low stock):</strong><br/>
    User clicks on "Vintage Typewriter Ribbon (Ink Black)". This is a rarely viewed product, so the Product Cache misses. The Product Service queries the Product DB (NoSQL document store) by <code>product_id</code>, returns the product document, and writes it to cache (TTL: 10 minutes). The Inventory Service queries the Inventory DB (SQL) and finds <code>available_quantity = 3</code>. The response includes a <code>"low_stock": true</code> flag, which the client renders as "Only 3 left in stock ‚Äî order soon." The Recommendation Service has limited collaborative filtering data for this niche product, so it falls back to category-based recommendations.
</div>

<div class="example-card">
    <strong>Example 3 ‚Äì Recommendation service is down (graceful degradation):</strong><br/>
    User views a product, but the Recommendation Service is experiencing an outage. The API Gateway's circuit breaker detects the failure (3 consecutive timeouts) and opens the circuit. The product detail response is still returned with product data, reviews, and inventory status ‚Äî but the "Recommended Products" section is omitted (or shows a cached fallback). The user experience is degraded but not broken. Checkout and cart functionality remain fully operational.
</div>

<h3>Component Deep Dive</h3>

<div class="deep-dive">
    <h4>Review Service</h4>
    <p><span class="tag tag-http">HTTP</span></p>
    <div class="api-block">
        <span class="method get">GET</span> /api/v1/products/{product_id}/reviews?page={page}&amp;sort={most_recent|most_helpful|highest|lowest}
    </div>
    <p><strong>Input:</strong> product_id (path), pagination, sort order.</p>
    <p><strong>Output:</strong></p>
    <pre>{
  "avg_rating": 4.3,
  "rating_distribution": {"5": 842, "4": 521, "3": 234, "2": 98, "1": 147},
  "total_reviews": 1842,
  "reviews": [
    {"review_id": "r456", "user_name": "Jane D.", "rating": 5,
     "title": "Best headphones ever", "body": "Amazing sound quality...",
     "images": ["https://cdn.../r456_1.jpg"],
     "helpful_count": 234, "created_at": "2025-12-01T10:00:00Z"}
  ]
}</pre>
    <p>Write endpoint:</p>
    <div class="api-block">
        <span class="method post">POST</span> /api/v1/products/{product_id}/reviews
    </div>
    <p><strong>Input:</strong> <code>{"rating": 5, "title": "...", "body": "...", "images": [uploaded_urls]}</code></p>
    <p><strong>Output:</strong> <code>{"review_id": "r789", "status": "pending_moderation"}</code></p>
    <p>Reviews go through an async moderation pipeline (content policy check, spam detection) via a message queue before becoming visible.</p>
</div>

<div class="deep-dive">
    <h4>Inventory Service</h4>
    <p><span class="tag tag-grpc">gRPC (internal)</span></p>
    <p>Internal-only service. Not directly exposed to clients. Called by the Product Service, Cart Service, and Order Service.</p>
    <ul>
        <li><code>CheckStock(product_id, warehouse_id?) ‚Üí {available_quantity, warehouses[]}</code></li>
        <li><code>ReserveStock(product_id, quantity, order_id, ttl_seconds) ‚Üí {success, reservation_id}</code></li>
        <li><code>ConfirmReservation(reservation_id) ‚Üí {success}</code></li>
        <li><code>ReleaseReservation(reservation_id) ‚Üí {success}</code></li>
    </ul>
    <p><strong>Why gRPC:</strong> Internal service-to-service calls benefit from gRPC's binary serialization (protobuf), HTTP/2 multiplexing, and strong typing. Latency is critical since inventory checks are in the hot path for checkout.</p>
    <p>Uses <strong>SQL</strong> for the Inventory DB because stock quantities must be atomically updated to prevent overselling. Optimistic locking with version numbers is used: <code>UPDATE inventory SET quantity = quantity - :qty, version = version + 1 WHERE product_id = :pid AND version = :expected_version AND quantity >= :qty</code>.</p>
</div>

<div class="deep-dive">
    <h4>Recommendation Service</h4>
    <p><span class="tag tag-grpc">gRPC (internal)</span></p>
    <ul>
        <li><code>GetRecommendations(user_id, product_id, context, limit) ‚Üí {products[]}</code></li>
    </ul>
    <p>Combines multiple signals: collaborative filtering ("users who bought X also bought Y"), content-based filtering (similar product attributes), and user browsing/purchase history. Pre-computed recommendation lists are stored in a NoSQL key-value store keyed by user_id and product_id. Real-time ranking adjustments are made by the ML model. This service is designed to be <strong>non-critical</strong> ‚Äî if it fails, the product page still loads without recommendations (circuit breaker pattern).</p>
</div>


<!-- ============================================================ -->
<!-- 5. FLOW 3: CART MANAGEMENT -->
<!-- ============================================================ -->
<h2 id="flow3">5. Flow 3: Cart Management</h2>

<div class="diagram-container">
<pre class="mermaid">
graph TD
    Client["üë§ Client"]
    LB["‚öñÔ∏è Load Balancer"]
    GW["üö™ API Gateway"]
    CS["üõí Cart Service"]
    CDB[("üíæ Cart Store<br/>(NoSQL ‚Äì KV)")]
    PS["üì¶ Product Service"]
    PDB[("üíæ Product DB<br/>(NoSQL ‚Äì Document)")]
    IS["üìä Inventory Service"]
    IDB[("üíæ Inventory DB<br/>(SQL)")]

    Client -->|"HTTPS POST/PUT/DELETE/GET<br/>/api/v1/cart"| LB
    LB --> GW
    GW --> CS
    CS --> CDB
    CS -->|"gRPC: validate price &<br/>product existence"| PS
    PS --> PDB
    CS -->|"gRPC: check stock"| IS
    IS --> IDB

    style Client fill:#e3f2fd,stroke:#1565c0,stroke-width:2px
    style LB fill:#fff3e0,stroke:#e65100,stroke-width:2px
    style GW fill:#fff3e0,stroke:#e65100,stroke-width:2px
    style CS fill:#e8f5e9,stroke:#2e7d32,stroke-width:2px
    style CDB fill:#e8eaf6,stroke:#283593,stroke-width:2px
    style PS fill:#e8f5e9,stroke:#2e7d32,stroke-width:2px
    style PDB fill:#e8eaf6,stroke:#283593,stroke-width:2px
    style IS fill:#e8f5e9,stroke:#2e7d32,stroke-width:2px
    style IDB fill:#e8eaf6,stroke:#283593,stroke-width:2px
</pre>
</div>

<h3>Examples</h3>

<div class="example-card">
    <strong>Example 1 ‚Äì Add item to cart:</strong><br/>
    User clicks "Add to Cart" on "Wireless Headphones X" (product_id: p123, quantity: 1). The client sends <code>HTTPS POST /api/v1/cart/items</code> with body <code>{"product_id": "p123", "quantity": 1}</code>. The Cart Service first calls the Product Service (gRPC: <code>GetProduct(p123)</code>) to validate the product exists and get the current price ($29.99). It then calls the Inventory Service (gRPC: <code>CheckStock(p123)</code>) to verify stock is available (soft check ‚Äî no reservation yet). Both pass, so the Cart Service writes to the Cart Store (NoSQL key-value): key = <code>user_id:u789</code>, value = updated cart JSON with the new item appended. Response: <code>{"cart_id": "c001", "items": [{"product_id": "p123", "name": "Wireless Headphones X", "quantity": 1, "unit_price": 29.99}], "subtotal": 29.99}</code>.
</div>

<div class="example-card">
    <strong>Example 2 ‚Äì Update item quantity:</strong><br/>
    User changes the quantity of headphones from 1 to 3. The client sends <code>HTTPS PUT /api/v1/cart/items/p123</code> with body <code>{"quantity": 3}</code>. The Cart Service checks inventory: <code>CheckStock(p123)</code> returns available_quantity = 47, which is ‚â• 3, so the update proceeds. The cart document is updated in-place in the Cart Store. Response includes updated subtotal: $89.97.
</div>

<div class="example-card">
    <strong>Example 3 ‚Äì Item goes out of stock after being added to cart:</strong><br/>
    User added "Vintage Typewriter Ribbon" (available_quantity: 3) to their cart yesterday. Today, they open their cart, which triggers <code>HTTPS GET /api/v1/cart</code>. The Cart Service revalidates each item by calling <code>CheckStock</code> for every product in the cart. The typewriter ribbon now has available_quantity = 0. The response flags this item: <code>"status": "out_of_stock"</code>. The client renders a warning: "This item is currently unavailable" and disables the checkout button until the user removes or adjusts the item.
</div>

<div class="example-card">
    <strong>Example 4 ‚Äì Guest user cart merge:</strong><br/>
    A guest (unauthenticated) user adds items to a temporary cart stored with a session cookie (<code>session_id: s999</code>). When the guest logs in as user <code>u789</code>, the Cart Service merges the guest cart (keyed by <code>session:s999</code>) into the authenticated user's cart (keyed by <code>user:u789</code>). Duplicate items have their quantities summed. The guest cart entry is then deleted.
</div>

<h3>Component Deep Dive</h3>

<div class="deep-dive">
    <h4>Cart Service</h4>
    <p><span class="tag tag-http">HTTP</span></p>
    <div class="api-block">
        <span class="method get">GET</span> /api/v1/cart ‚Üí returns full cart with revalidated items<br/>
        <span class="method post">POST</span> /api/v1/cart/items ‚Üí body: {"product_id", "quantity"} ‚Üí adds item<br/>
        <span class="method put">PUT</span> /api/v1/cart/items/{product_id} ‚Üí body: {"quantity"} ‚Üí updates quantity<br/>
        <span class="method delete">DELETE</span> /api/v1/cart/items/{product_id} ‚Üí removes item<br/>
    </div>
    <p><strong>Output (GET):</strong></p>
    <pre>{
  "cart_id": "c001",
  "items": [
    {"product_id": "p123", "name": "Wireless Headphones X",
     "quantity": 1, "unit_price": 29.99, "image_url": "...",
     "status": "in_stock"}
  ],
  "subtotal": 29.99,
  "item_count": 1
}</pre>
    <p>The Cart Service is stateless. All cart state is persisted in the Cart Store (NoSQL key-value). On every <code>GET</code>, it revalidates product data (prices may have changed) and stock availability.</p>
</div>

<div class="deep-dive">
    <h4>Cart Store (NoSQL ‚Äì Key-Value)</h4>
    <p>A key-value store chosen because the access pattern is simple: one cart per user, retrieved by <code>user_id</code>. No complex queries or joins. The value is a JSON document containing the list of items. Key: <code>user:{user_id}</code> or <code>session:{session_id}</code>. TTL: 90 days for authenticated users, 30 days for guest sessions. See <a href="#schema">Schema section</a> for full details.</p>
</div>


<!-- ============================================================ -->
<!-- 6. FLOW 4: CHECKOUT & ORDER PLACEMENT -->
<!-- ============================================================ -->
<h2 id="flow4">6. Flow 4: Checkout &amp; Order Placement</h2>

<div class="diagram-container">
<pre class="mermaid">
graph TD
    Client["üë§ Client"]
    LB["‚öñÔ∏è Load Balancer"]
    GW["üö™ API Gateway"]
    OS_SVC["üßæ Order Service"]
    ODB[("üíæ Order DB<br/>(SQL ‚Äì ACID)")]
    IS["üìä Inventory Service"]
    IDB[("üíæ Inventory DB<br/>(SQL)")]
    PAY["üí≥ Payment Service"]
    EXT_PAY["üè¶ External Payment<br/>Gateway"]
    MQ{{"üì¨ Message Queue"}}
    NS["üîî Notification Service"]
    WS["üè≠ Warehouse Service"]
    CS["üõí Cart Service"]
    CDB[("üíæ Cart Store")]

    Client -->|"HTTPS POST<br/>/api/v1/orders"| LB
    LB --> GW
    GW --> OS_SVC

    OS_SVC -->|"1. gRPC: ReserveStock"| IS
    IS --> IDB
    OS_SVC -->|"2. gRPC: ProcessPayment"| PAY
    PAY -->|"HTTPS"| EXT_PAY
    OS_SVC -->|"3. Write order"| ODB
    OS_SVC -->|"4. Clear cart"| CS
    CS --> CDB
    OS_SVC -->|"5. Publish events"| MQ
    MQ -->|"order.confirmed"| NS
    MQ -->|"order.confirmed"| WS

    style Client fill:#e3f2fd,stroke:#1565c0,stroke-width:2px
    style LB fill:#fff3e0,stroke:#e65100,stroke-width:2px
    style GW fill:#fff3e0,stroke:#e65100,stroke-width:2px
    style OS_SVC fill:#e8f5e9,stroke:#2e7d32,stroke-width:2px
    style ODB fill:#e8eaf6,stroke:#283593,stroke-width:2px
    style IS fill:#e8f5e9,stroke:#2e7d32,stroke-width:2px
    style IDB fill:#e8eaf6,stroke:#283593,stroke-width:2px
    style PAY fill:#e8f5e9,stroke:#2e7d32,stroke-width:2px
    style EXT_PAY fill:#fce4ec,stroke:#c62828,stroke-width:2px
    style MQ fill:#f8d7da,stroke:#c62828,stroke-width:2px
    style NS fill:#e8f5e9,stroke:#2e7d32,stroke-width:2px
    style WS fill:#e8f5e9,stroke:#2e7d32,stroke-width:2px
    style CS fill:#e8f5e9,stroke:#2e7d32,stroke-width:2px
    style CDB fill:#e8eaf6,stroke:#283593,stroke-width:2px
</pre>
</div>

<h3>Examples</h3>

<div class="example-card">
    <strong>Example 1 ‚Äì Successful order placement (happy path):</strong><br/>
    User reviews their cart (1√ó Wireless Headphones X at $29.99) and clicks "Place Order". The client sends <code>HTTPS POST /api/v1/orders</code> with body <code>{"shipping_address_id": "addr_01", "payment_method_id": "pm_visa_01"}</code>. The Order Service orchestrates a <strong>Saga</strong>:
    <ol>
        <li><strong>Reserve inventory:</strong> gRPC <code>ReserveStock(p123, qty=1, ttl=600s)</code> ‚Üí success, <code>reservation_id: res_001</code>. The reservation has a 10-minute TTL; if the order fails, the stock is auto-released.</li>
        <li><strong>Process payment:</strong> gRPC <code>ProcessPayment(order_id=ord_5001, amount=32.49 [incl. tax+shipping], payment_method=pm_visa_01)</code> ‚Üí Payment Service calls the external payment gateway over HTTPS ‚Üí success, <code>transaction_id: txn_7890</code>.</li>
        <li><strong>Create order record:</strong> INSERT into Order DB (SQL) with status <code>CONFIRMED</code>, linking order_items, payment, and shipping address. This is done within a database transaction for ACID guarantees.</li>
        <li><strong>Clear cart:</strong> gRPC call to Cart Service to remove ordered items from the user's cart.</li>
        <li><strong>Publish event:</strong> Publish <code>order.confirmed</code> event to the Message Queue with order details. The Notification Service consumes this and sends an order confirmation email + push notification. The Warehouse Service consumes it and initiates the pick-pack-ship workflow.</li>
    </ol>
    Response to client: <code>{"order_id": "ord_5001", "status": "CONFIRMED", "estimated_delivery": "2025-02-18"}</code>.
</div>

<div class="example-card">
    <strong>Example 2 ‚Äì Payment failure (compensating transaction):</strong><br/>
    User places an order for a $500 TV. The Saga starts: (1) Inventory reservation succeeds (<code>res_002</code>). (2) Payment processing fails ‚Äî the external gateway returns <code>DECLINED</code> (insufficient funds). The Order Service executes the <strong>compensating transaction</strong>: it calls <code>ReleaseReservation(res_002)</code> to release the inventory back. The order is created with status <code>PAYMENT_FAILED</code>. The client receives <code>{"error": "payment_declined", "message": "Your payment method was declined. Please try another."}</code>. Cart items are NOT cleared, so the user can retry.
</div>

<div class="example-card">
    <strong>Example 3 ‚Äì Inventory insufficient at checkout:</strong><br/>
    User added "Vintage Typewriter Ribbon" (qty: 2) to their cart an hour ago. They click "Place Order". The Order Service calls <code>ReserveStock(p456, qty=2)</code>, but only 1 unit remains. The reservation fails. The order is not created. The client receives <code>{"error": "insufficient_stock", "message": "Only 1 unit of 'Vintage Typewriter Ribbon' is available.", "available_quantity": 1}</code>. The user is redirected back to the cart to adjust the quantity.
</div>

<div class="example-card">
    <strong>Example 4 ‚Äì Idempotent retry (network timeout):</strong><br/>
    User clicks "Place Order", but the response times out due to a network blip. The client automatically retries the same request with an <code>Idempotency-Key: idem_abc123</code> header. The Order Service looks up this idempotency key in its store. It finds that the order was already successfully created (ord_5002). Instead of creating a duplicate order, it returns the existing order: <code>{"order_id": "ord_5002", "status": "CONFIRMED"}</code>. No double-charge occurs.
</div>

<h3>Component Deep Dive</h3>

<div class="deep-dive">
    <h4>Order Service</h4>
    <p><span class="tag tag-http">HTTP</span></p>
    <div class="api-block">
        <span class="method post">POST</span> /api/v1/orders ‚Üí body: {"shipping_address_id", "payment_method_id"} ‚Üí place order<br/>
        <span class="method get">GET</span> /api/v1/orders ‚Üí query: ?page=&amp;status= ‚Üí list user's orders<br/>
        <span class="method get">GET</span> /api/v1/orders/{order_id} ‚Üí get order details
    </div>
    <p><strong>Saga Orchestrator:</strong> The Order Service acts as the orchestrator of a <strong>choreography-based Saga pattern</strong> for the distributed transaction spanning inventory, payment, and order creation. Each step has a corresponding compensating action:</p>
    <table>
        <tr><th>Step</th><th>Action</th><th>Compensating Action</th></tr>
        <tr><td>1</td><td>Reserve inventory</td><td>Release reservation</td></tr>
        <tr><td>2</td><td>Process payment</td><td>Refund payment</td></tr>
        <tr><td>3</td><td>Create order record</td><td>Mark order as CANCELLED</td></tr>
    </table>
    <p>If any step fails, all prior steps are compensated in reverse order.</p>
    <p><strong>Idempotency:</strong> The client must include an <code>Idempotency-Key</code> header. The Order Service stores the key and result for 24 hours. Duplicate requests with the same key return the cached result without re-executing the Saga.</p>
</div>

<div class="deep-dive">
    <h4>Payment Service</h4>
    <p><span class="tag tag-grpc">gRPC (internal)</span></p>
    <ul>
        <li><code>ProcessPayment(order_id, amount, currency, payment_method_id) ‚Üí {success, transaction_id, error_code?}</code></li>
        <li><code>RefundPayment(transaction_id, amount) ‚Üí {success, refund_id}</code></li>
    </ul>
    <p>Acts as an abstraction layer over external payment gateways. Communicates with the external gateway via <strong>HTTPS</strong> (as required by PCI-DSS). Stores payment records in the Order DB (same SQL database, separate <code>payments</code> table) for auditability. All sensitive card data is tokenized ‚Äî the Payment Service only handles tokens, never raw card numbers.</p>
</div>

<div class="deep-dive">
    <h4>Message Queue (Order Events)</h4>
    <p>After an order is confirmed, the Order Service publishes an <code>order.confirmed</code> event to the message queue. Multiple consumers subscribe to this topic:</p>
    <ul>
        <li><strong>Notification Service:</strong> Sends confirmation email, push notification, and SMS.</li>
        <li><strong>Warehouse Service:</strong> Initiates the pick-pack-ship workflow at the nearest fulfillment center.</li>
        <li><strong>Analytics Service:</strong> Records the sale for reporting and recommendation model training.</li>
    </ul>
    <p>See <a href="#mq-deep">Message Queue Deep Dive</a> for queue mechanics.</p>
</div>


<!-- ============================================================ -->
<!-- 7. FLOW 5: ORDER FULFILLMENT & TRACKING -->
<!-- ============================================================ -->
<h2 id="flow5">7. Flow 5: Order Fulfillment &amp; Tracking</h2>

<div class="diagram-container">
<pre class="mermaid">
graph TD
    Client["üë§ Client"]
    LB["‚öñÔ∏è Load Balancer"]
    GW["üö™ API Gateway"]
    OS_SVC["üßæ Order Service"]
    ODB[("üíæ Order DB<br/>(SQL)")]
    TS["üöö Tracking Service"]
    TDB[("üíæ Tracking DB<br/>(NoSQL ‚Äì Timeseries)")]
    MQ{{"üì¨ Message Queue"}}
    NS["üîî Notification Service"]
    SP["üì¶ Shipping Partner<br/>(External)"]

    SP -->|"Webhook POST<br/>/internal/tracking/update"| TS
    TS -->|"Write tracking event"| TDB
    TS -->|"Update order status"| OS_SVC
    OS_SVC --> ODB
    TS -->|"Publish status change"| MQ
    MQ --> NS
    NS -->|"Push notification / Email"| Client

    Client -->|"HTTPS GET<br/>/api/v1/orders/{id}/tracking"| LB
    LB --> GW
    GW --> TS
    TS --> TDB
    GW --> OS_SVC
    OS_SVC --> ODB

    style Client fill:#e3f2fd,stroke:#1565c0,stroke-width:2px
    style LB fill:#fff3e0,stroke:#e65100,stroke-width:2px
    style GW fill:#fff3e0,stroke:#e65100,stroke-width:2px
    style OS_SVC fill:#e8f5e9,stroke:#2e7d32,stroke-width:2px
    style ODB fill:#e8eaf6,stroke:#283593,stroke-width:2px
    style TS fill:#e8f5e9,stroke:#2e7d32,stroke-width:2px
    style TDB fill:#e8eaf6,stroke:#283593,stroke-width:2px
    style MQ fill:#f8d7da,stroke:#c62828,stroke-width:2px
    style NS fill:#e8f5e9,stroke:#2e7d32,stroke-width:2px
    style SP fill:#fce4ec,stroke:#c62828,stroke-width:2px
</pre>
</div>

<h3>Examples</h3>

<div class="example-card">
    <strong>Example 1 ‚Äì Shipping partner sends tracking update:</strong><br/>
    The shipping partner's system sends a webhook <code>POST /internal/tracking/update</code> with payload <code>{"tracking_number": "TRK-12345", "status": "IN_TRANSIT", "location": "Memphis, TN", "timestamp": "2025-02-14T08:30:00Z"}</code>. The Tracking Service receives this, writes the event to the Tracking DB (time-series NoSQL ‚Äî append-only, ordered by timestamp), and calls the Order Service (gRPC) to update the order status from <code>SHIPPED</code> to <code>IN_TRANSIT</code>. The Tracking Service then publishes a <code>tracking.updated</code> event to the Message Queue. The Notification Service consumes this and sends a push notification to the user: "Your order is in transit! Currently in Memphis, TN."
</div>

<div class="example-card">
    <strong>Example 2 ‚Äì User checks tracking status:</strong><br/>
    User opens the app and navigates to "My Orders" ‚Üí clicks on order <code>ord_5001</code> ‚Üí taps "Track Package". The client sends <code>HTTPS GET /api/v1/orders/ord_5001/tracking</code>. The API Gateway routes to the Tracking Service, which queries the Tracking DB for all events with <code>order_id = ord_5001</code>, sorted by timestamp descending. The response includes the full timeline: Order Placed ‚Üí Processing ‚Üí Shipped (carrier pickup) ‚Üí In Transit (Memphis, TN) ‚Üí Out for Delivery. The client renders this as a visual timeline with timestamps and locations.
</div>

<div class="example-card">
    <strong>Example 3 ‚Äì Delivery confirmation:</strong><br/>
    The shipping partner sends a final webhook: <code>{"tracking_number": "TRK-12345", "status": "DELIVERED", "location": "Customer Doorstep", "signature": "J. Smith", "timestamp": "2025-02-16T14:22:00Z"}</code>. The Tracking Service updates the Tracking DB and calls the Order Service to set status to <code>DELIVERED</code>. The Order Service also starts a 30-day return eligibility timer. A <code>tracking.delivered</code> event is published. The Notification Service sends: "Your order has been delivered! How was your experience?" with a link to leave a review.
</div>

<h3>Component Deep Dive</h3>

<div class="deep-dive">
    <h4>Tracking Service</h4>
    <p><span class="tag tag-http">HTTP</span> (webhook + client-facing)</p>
    <div class="api-block">
        <span class="method get">GET</span> /api/v1/orders/{order_id}/tracking ‚Üí get tracking timeline<br/>
        <span class="method post">POST</span> /internal/tracking/update ‚Üí webhook from shipping partner (authenticated via API key + IP whitelist)
    </div>
    <p><strong>Input (webhook):</strong> <code>{"tracking_number", "status", "location", "timestamp", "signature?"}</code></p>
    <p><strong>Output (GET):</strong></p>
    <pre>{
  "order_id": "ord_5001",
  "tracking_number": "TRK-12345",
  "carrier": "FastShip",
  "current_status": "IN_TRANSIT",
  "estimated_delivery": "2025-02-16",
  "events": [
    {"status": "IN_TRANSIT", "location": "Memphis, TN",
     "timestamp": "2025-02-14T08:30:00Z"},
    {"status": "SHIPPED", "location": "Fulfillment Center, CA",
     "timestamp": "2025-02-13T16:00:00Z"},
    {"status": "PROCESSING", "location": "Warehouse",
     "timestamp": "2025-02-13T10:00:00Z"}
  ]
}</pre>
</div>

<div class="deep-dive">
    <h4>Tracking DB (NoSQL ‚Äì Time-Series)</h4>
    <p>Stores tracking events as an append-only, time-ordered log. Each event is immutable once written. Access pattern is primarily: <em>"Get all events for a given order_id, sorted by timestamp."</em> This is a time-series workload ‚Äî high write throughput, sequential reads, no updates. A time-series or wide-column NoSQL store is ideal.</p>
    <p><strong>Why not SQL:</strong> Tracking events are append-only with no transactional requirements. The write volume from millions of shipments across many carriers demands horizontal scalability that time-series NoSQL provides naturally.</p>
</div>

<div class="deep-dive">
    <h4>Why Webhooks Instead of Polling for Shipping Updates</h4>
    <p>Shipping partners push updates via webhooks rather than our system polling them. Reasons:</p>
    <ul>
        <li><strong>Efficiency:</strong> Polling millions of tracking numbers every few minutes would be extremely wasteful ‚Äî most statuses haven't changed.</li>
        <li><strong>Timeliness:</strong> Webhooks provide near-real-time updates as soon as the status changes.</li>
        <li><strong>Reduced load:</strong> No need to maintain a polling scheduler or manage rate limits against carrier APIs.</li>
    </ul>
    <p><strong>Why SSE or Polling is NOT used for client-side real-time tracking:</strong> Order tracking updates happen infrequently (a few times over days). Keeping a persistent SSE or WebSocket connection open for days would waste server resources. Instead, push notifications alert the user of status changes, and the user can pull the latest tracking data on-demand via a standard <code>GET</code> request. If a user is actively watching the tracking page, the client can do short polling (every 30 seconds) as a simple, low-overhead approach.</p>
</div>

<div class="deep-dive">
    <h4>Notification Service</h4>
    <p><span class="tag tag-queue">Message Queue Consumer</span></p>
    <p>Consumes events from the message queue and dispatches notifications through multiple channels:</p>
    <ul>
        <li><strong>Email:</strong> Order confirmations, shipping updates, delivery confirmation.</li>
        <li><strong>Push Notification:</strong> Real-time mobile alerts (via APNs for iOS, FCM for Android).</li>
        <li><strong>SMS:</strong> Critical alerts (delivery, payment issues) for users who opted in.</li>
    </ul>
    <p>The Notification Service is purely asynchronous and event-driven. It never blocks the critical path (order placement, checkout). It has its own retry logic: if an email fails to send, the message is returned to the queue and retried with exponential backoff (max 3 retries).</p>
</div>


<!-- ============================================================ -->
<!-- 8. FLOW 6: SELLER PRODUCT MANAGEMENT -->
<!-- ============================================================ -->
<h2 id="flow6">8. Flow 6: Seller Product Management</h2>

<div class="diagram-container">
<pre class="mermaid">
graph TD
    Seller["üë§ Seller"]
    LB["‚öñÔ∏è Load Balancer"]
    GW["üö™ API Gateway"]
    SLS["üè™ Seller Service"]
    PS["üì¶ Product Service"]
    PDB[("üíæ Product DB<br/>(NoSQL ‚Äì Document)")]
    IS["üìä Inventory Service"]
    IDB[("üíæ Inventory DB<br/>(SQL)")]
    OS[("üóÉÔ∏è Object Storage")]
    MQ{{"üì¨ Message Queue"}}
    IDX["üîÑ Search Indexer"]
    SI[("üìá Search Index")]

    Seller -->|"HTTPS POST/PUT<br/>/api/v1/seller/products"| LB
    LB --> GW
    GW --> SLS
    SLS -->|"Create/update product"| PS
    PS --> PDB
    SLS -->|"Upload images"| OS
    SLS -->|"Set initial stock"| IS
    IS --> IDB
    PS -->|"Publish product.created<br/>/ product.updated"| MQ
    MQ --> IDX
    IDX -->|"Update index"| SI

    style Seller fill:#e3f2fd,stroke:#1565c0,stroke-width:2px
    style LB fill:#fff3e0,stroke:#e65100,stroke-width:2px
    style GW fill:#fff3e0,stroke:#e65100,stroke-width:2px
    style SLS fill:#e8f5e9,stroke:#2e7d32,stroke-width:2px
    style PS fill:#e8f5e9,stroke:#2e7d32,stroke-width:2px
    style PDB fill:#e8eaf6,stroke:#283593,stroke-width:2px
    style IS fill:#e8f5e9,stroke:#2e7d32,stroke-width:2px
    style IDB fill:#e8eaf6,stroke:#283593,stroke-width:2px
    style OS fill:#e8eaf6,stroke:#283593,stroke-width:2px
    style MQ fill:#f8d7da,stroke:#c62828,stroke-width:2px
    style IDX fill:#e8f5e9,stroke:#2e7d32,stroke-width:2px
    style SI fill:#fce4ec,stroke:#c62828,stroke-width:2px
</pre>
</div>

<h3>Examples</h3>

<div class="example-card">
    <strong>Example 1 ‚Äì Seller lists a new product:</strong><br/>
    A seller logs into the seller portal and fills in product details: name "Organic Green Tea ‚Äì 100 bags", category "Grocery &gt; Tea", price $12.99, 5 product images, description, and attributes (weight: 250g, organic: true). They click "Publish". The client sends <code>HTTPS POST /api/v1/seller/products</code> with a multipart form. The Seller Service validates the seller's account status (verified, not suspended). Images are uploaded to Object Storage and their URLs are recorded. The Product Service creates a new document in the Product DB. The Seller Service sets the initial inventory (quantity: 500) via the Inventory Service. The Product Service publishes a <code>product.created</code> event to the Message Queue. The Search Indexer consumes this event and adds the new product to the Search Index. Within a few seconds, the tea is searchable by customers.
</div>

<div class="example-card">
    <strong>Example 2 ‚Äì Seller updates price:</strong><br/>
    The seller wants to run a sale and changes the price from $12.99 to $9.99. They send <code>HTTPS PUT /api/v1/seller/products/p789</code> with body <code>{"price": 9.99}</code>. The Product Service updates the document in the Product DB and invalidates the Product Cache for <code>p789</code>. A <code>product.updated</code> event is published. The Search Indexer updates the price in the Search Index. Users who have this product in their cart will see the updated price on their next cart view (since the Cart Service revalidates prices on every GET).
</div>

<div class="example-card">
    <strong>Example 3 ‚Äì Seller updates inventory:</strong><br/>
    The seller received a new shipment and wants to add 200 units. They send <code>HTTPS PUT /api/v1/seller/inventory/p789</code> with body <code>{"quantity_add": 200}</code>. The Inventory Service atomically increments the quantity: <code>UPDATE inventory SET quantity = quantity + 200 WHERE product_id = 'p789' AND seller_id = 's001'</code>. If the product was previously out of stock, a <code>product.back_in_stock</code> event is published to notify users who had this item in their wishlist.
</div>

<h3>Component Deep Dive</h3>

<div class="deep-dive">
    <h4>Seller Service</h4>
    <p><span class="tag tag-http">HTTP</span></p>
    <div class="api-block">
        <span class="method post">POST</span> /api/v1/seller/products ‚Üí create new product listing<br/>
        <span class="method put">PUT</span> /api/v1/seller/products/{product_id} ‚Üí update product details<br/>
        <span class="method get">GET</span> /api/v1/seller/products?page=&amp;status= ‚Üí list seller's products<br/>
        <span class="method put">PUT</span> /api/v1/seller/inventory/{product_id} ‚Üí update inventory<br/>
        <span class="method get">GET</span> /api/v1/seller/analytics ‚Üí sales dashboard data
    </div>
    <p>The Seller Service handles seller authentication (separate from buyer auth), product CRUD, and delegates to the Product Service, Inventory Service, and Object Storage. It also enforces business rules: sellers must be verified, products must pass content policy checks before being published, and pricing must meet minimum requirements.</p>
</div>

<div class="deep-dive">
    <h4>Search Indexer (Async)</h4>
    <p><span class="tag tag-queue">Message Queue Consumer</span></p>
    <p>An asynchronous worker that consumes <code>product.created</code>, <code>product.updated</code>, and <code>product.deleted</code> events from the message queue. For each event, it transforms the product data into a search document and upserts it into the Search Index. This decouples product writes from search index updates, meaning a product write is fast (just the NoSQL insert) while the search index update happens asynchronously within seconds.</p>
    <p><strong>Why async instead of synchronous indexing:</strong> Synchronous indexing would add latency to every product write and create tight coupling between the Product DB and Search Index. If the Search Index is temporarily down, product writes would fail. Async decoupling ensures product writes always succeed, and the Search Indexer can catch up from the message queue when the index recovers.</p>
</div>


<!-- ============================================================ -->
<!-- 9. COMBINED OVERALL DIAGRAM -->
<!-- ============================================================ -->
<h2 id="combined">9. Combined Overall Diagram</h2>

<p>This diagram integrates all six flows into a single view showing how every component interacts:</p>

<div class="diagram-container">
<pre class="mermaid">
graph TD
    subgraph "Clients"
        Buyer["üë§ Buyer (Browser/App)"]
        Seller["üë§ Seller (Portal)"]
    end

    subgraph "Edge Layer"
        CDN["üåê CDN"]
        LB["‚öñÔ∏è Load Balancer"]
    end

    subgraph "Gateway Layer"
        GW["üö™ API Gateway<br/>(Auth, Rate Limit, Routing)"]
    end

    subgraph "Application Services"
        SS["üîç Search Service"]
        PS["üì¶ Product Service"]
        CS["üõí Cart Service"]
        OS_SVC["üßæ Order Service"]
        PAY["üí≥ Payment Service"]
        IS["üìä Inventory Service"]
        RS["‚≠ê Review Service"]
        REC["ü§ñ Recommendation Svc"]
        TS["üöö Tracking Service"]
        NS["üîî Notification Service"]
        SLS["üè™ Seller Service"]
        IDX["üîÑ Search Indexer"]
    end

    subgraph "Async Layer"
        MQ{{"üì¨ Message Queue"}}
    end

    subgraph "Data Layer"
        SC[("Search Cache")]
        PC[("Product Cache")]
        SI[("üìá Search Index<br/>(Inverted Index)")]
        PDB[("Product DB<br/>(NoSQL Doc)")]
        CDB[("Cart Store<br/>(NoSQL KV)")]
        ODB[("Order DB<br/>(SQL)")]
        IDB[("Inventory DB<br/>(SQL)")]
        RDB[("Review DB<br/>(NoSQL Doc)")]
        TDB[("Tracking DB<br/>(NoSQL TS)")]
        ObjS[("Object Storage")]
    end

    subgraph "External"
        EXT_PAY["üè¶ Payment Gateway"]
        SP["üì¶ Shipping Partner"]
    end

    Buyer --> CDN
    Buyer --> LB
    Seller --> LB
    CDN --> ObjS
    LB --> GW

    GW --> SS
    GW --> PS
    GW --> CS
    GW --> OS_SVC
    GW --> RS
    GW --> REC
    GW --> TS
    GW --> SLS

    SS --> SC
    SS --> SI
    SS --> PS
    PS --> PC
    PS --> PDB

    CS --> CDB
    CS --> PS
    CS --> IS

    OS_SVC --> ODB
    OS_SVC --> IS
    OS_SVC --> PAY
    OS_SVC --> CS
    PAY --> EXT_PAY

    IS --> IDB

    RS --> RDB

    TS --> TDB
    TS --> OS_SVC
    SP --> TS

    SLS --> PS
    SLS --> IS
    SLS --> ObjS

    OS_SVC --> MQ
    PS --> MQ
    TS --> MQ
    MQ --> NS
    MQ --> IDX
    IDX --> SI

    style Buyer fill:#e3f2fd,stroke:#1565c0,stroke-width:2px
    style Seller fill:#e3f2fd,stroke:#1565c0,stroke-width:2px
    style CDN fill:#f3e5f5,stroke:#6a1b9a,stroke-width:2px
    style LB fill:#fff3e0,stroke:#e65100,stroke-width:2px
    style GW fill:#fff3e0,stroke:#e65100,stroke-width:2px
    style MQ fill:#f8d7da,stroke:#c62828,stroke-width:2px
    style EXT_PAY fill:#fce4ec,stroke:#c62828,stroke-width:2px
    style SP fill:#fce4ec,stroke:#c62828,stroke-width:2px
</pre>
</div>

<h3>End-to-End Examples on the Combined Diagram</h3>

<div class="example-card">
    <strong>Example A ‚Äì Full buyer journey (search ‚Üí view ‚Üí cart ‚Üí checkout ‚Üí track):</strong><br/>
    <ol>
        <li><strong>Search:</strong> A buyer searches for "running shoes". The request flows: Buyer ‚Üí LB ‚Üí GW ‚Üí Search Service ‚Üí Search Cache (miss) ‚Üí Search Index ‚Üí Product Service (batch fetch) ‚Üí Product Cache / Product DB. Results returned with images served from CDN ‚Üê Object Storage.</li>
        <li><strong>View:</strong> Buyer clicks on "UltraRun Pro Shoes". Request: GW ‚Üí Product Service (cache hit), Review Service (top reviews from Review DB), Inventory Service (stock check from Inventory DB), Recommendation Service (similar products). All aggregated and returned.</li>
        <li><strong>Cart:</strong> Buyer clicks "Add to Cart". Request: GW ‚Üí Cart Service ‚Üí validates with Product Service and Inventory Service ‚Üí writes to Cart Store (NoSQL KV).</li>
        <li><strong>Checkout:</strong> Buyer places order. Request: GW ‚Üí Order Service ‚Üí Inventory Service (ReserveStock) ‚Üí Payment Service ‚Üí External Payment Gateway (HTTPS) ‚Üí Order DB (SQL INSERT) ‚Üí Cart Service (clear cart) ‚Üí Message Queue (order.confirmed event). Notification Service sends confirmation email. Warehouse Service starts fulfillment.</li>
        <li><strong>Tracking:</strong> Days later, the Shipping Partner sends a webhook to Tracking Service with "DELIVERED" status ‚Üí Tracking DB (time-series write) ‚Üí Order Service (update status in Order DB) ‚Üí Message Queue (tracking.delivered) ‚Üí Notification Service ‚Üí push notification to buyer. Buyer opens app: GW ‚Üí Tracking Service ‚Üí Tracking DB ‚Üí returns full timeline.</li>
    </ol>
</div>

<div class="example-card">
    <strong>Example B ‚Äì Seller lists a product, buyer discovers and purchases it:</strong><br/>
    <ol>
        <li><strong>Seller lists:</strong> Seller submits a new product "Bamboo Cutting Board" via the Seller Portal. Request: Seller ‚Üí LB ‚Üí GW ‚Üí Seller Service ‚Üí Product Service (writes to Product DB) + Object Storage (images) + Inventory Service (initial stock: 100 units, writes to Inventory DB). Product Service publishes <code>product.created</code> to Message Queue. Search Indexer consumes event and adds product to Search Index.</li>
        <li><strong>Buyer discovers:</strong> 5 seconds later, a buyer searches "cutting board". The Search Index now includes the new bamboo cutting board. Buyer sees it in search results and clicks to view the product detail page.</li>
        <li><strong>Buyer purchases:</strong> Buyer adds to cart and checks out. The Inventory Service reserves 1 unit (99 remaining). Payment is processed. Order confirmed. Seller sees the sale in their analytics dashboard via <code>GET /api/v1/seller/analytics</code>.</li>
    </ol>
</div>


<!-- ============================================================ -->
<!-- 10. DATABASE SCHEMA -->
<!-- ============================================================ -->
<h2 id="schema">10. Database Schema</h2>

<!-- ===== SQL TABLES ===== -->
<h3>SQL Tables</h3>

<div class="card">
    <h4>orders</h4>
    <p><span class="tag tag-sql">SQL</span> ‚Äî Chosen for ACID compliance. Orders involve financial transactions that must be consistent and durable. Partial writes or lost records are unacceptable.</p>
    <table>
        <tr><th>Column</th><th>Type</th><th>Key</th><th>Description</th></tr>
        <tr><td><code>order_id</code></td><td>UUID</td><td>PK</td><td>Unique order identifier</td></tr>
        <tr><td><code>user_id</code></td><td>UUID</td><td>FK ‚Üí users</td><td>Buyer who placed the order</td></tr>
        <tr><td><code>status</code></td><td>ENUM</td><td></td><td>PENDING, CONFIRMED, PROCESSING, SHIPPED, IN_TRANSIT, DELIVERED, CANCELLED, RETURNED</td></tr>
        <tr><td><code>subtotal</code></td><td>DECIMAL(12,2)</td><td></td><td>Sum of item prices</td></tr>
        <tr><td><code>tax_amount</code></td><td>DECIMAL(12,2)</td><td></td><td>Calculated tax</td></tr>
        <tr><td><code>shipping_cost</code></td><td>DECIMAL(12,2)</td><td></td><td>Shipping fee</td></tr>
        <tr><td><code>total_amount</code></td><td>DECIMAL(12,2)</td><td></td><td>subtotal + tax + shipping</td></tr>
        <tr><td><code>shipping_address</code></td><td>JSONB</td><td></td><td>Snapshot of address at order time (denormalized ‚Äî see note below)</td></tr>
        <tr><td><code>idempotency_key</code></td><td>VARCHAR(64)</td><td>UNIQUE</td><td>Prevents duplicate order creation</td></tr>
        <tr><td><code>created_at</code></td><td>TIMESTAMP</td><td></td><td>Order creation time</td></tr>
        <tr><td><code>updated_at</code></td><td>TIMESTAMP</td><td></td><td>Last status update time</td></tr>
    </table>
    <p><strong>Indexes:</strong></p>
    <ul>
        <li><strong>B-tree index on <code>(user_id, created_at DESC)</code>:</strong> Supports the "My Orders" page query: <code>SELECT * FROM orders WHERE user_id = ? ORDER BY created_at DESC LIMIT 20</code>. B-tree is ideal for range queries with ordering.</li>
        <li><strong>B-tree index on <code>(status, updated_at)</code>:</strong> Used by internal admin dashboards and the Warehouse Service to query orders by status (e.g., all CONFIRMED orders awaiting fulfillment).</li>
        <li><strong>Hash index on <code>idempotency_key</code>:</strong> Fast exact-match lookup for duplicate detection. Hash index is chosen because we only need equality checks, never range queries.</li>
    </ul>
    <p><strong>Sharding:</strong> Sharded by <code>user_id</code> (hash-based). This ensures all orders for a given user reside on the same shard, making "My Orders" queries single-shard. Cross-shard queries (e.g., "all orders with status CONFIRMED") are handled by scatter-gather, which is acceptable for admin/batch use cases.</p>
    <p><strong>Read events:</strong> User opens "My Orders" page; user views order detail; admin dashboard; warehouse fulfillment system.</p>
    <p><strong>Write events:</strong> User places order (INSERT); shipping status update changes order status (UPDATE); cancellation or return (UPDATE).</p>
    <div class="note">
        <strong>Denormalization ‚Äì <code>shipping_address</code>:</strong> The shipping address is stored as a JSON snapshot within the order rather than as a foreign key to an addresses table. This is intentional: if the user later changes their address, the order must retain the address it was shipped to. This denormalization avoids incorrect historical data and eliminates a JOIN on every order read.
    </div>
</div>

<div class="card">
    <h4>order_items</h4>
    <p><span class="tag tag-sql">SQL</span> ‚Äî Part of the same SQL database as <code>orders</code> to support transactional integrity (order + items inserted in a single transaction).</p>
    <table>
        <tr><th>Column</th><th>Type</th><th>Key</th><th>Description</th></tr>
        <tr><td><code>order_item_id</code></td><td>UUID</td><td>PK</td><td>Unique line item ID</td></tr>
        <tr><td><code>order_id</code></td><td>UUID</td><td>FK ‚Üí orders</td><td>Parent order</td></tr>
        <tr><td><code>product_id</code></td><td>UUID</td><td></td><td>Product purchased (not FK ‚Äî product in separate NoSQL DB)</td></tr>
        <tr><td><code>seller_id</code></td><td>UUID</td><td></td><td>Seller who sold this item</td></tr>
        <tr><td><code>product_name</code></td><td>VARCHAR(500)</td><td></td><td>Snapshot of product name at order time</td></tr>
        <tr><td><code>unit_price</code></td><td>DECIMAL(12,2)</td><td></td><td>Price per unit at order time</td></tr>
        <tr><td><code>quantity</code></td><td>INT</td><td></td><td>Quantity ordered</td></tr>
        <tr><td><code>image_url</code></td><td>VARCHAR(500)</td><td></td><td>Product thumbnail URL at order time</td></tr>
    </table>
    <p><strong>Indexes:</strong></p>
    <ul>
        <li><strong>B-tree index on <code>order_id</code>:</strong> All items for a given order are fetched together. The index supports the JOIN: <code>SELECT * FROM order_items WHERE order_id = ?</code>.</li>
        <li><strong>B-tree index on <code>seller_id</code>:</strong> Supports seller analytics queries: "all items sold by seller X in the last month."</li>
    </ul>
    <p><strong>Sharding:</strong> Co-located with <code>orders</code> by <code>user_id</code> (the order_item rows are sharded to the same shard as their parent order using the order's user_id). This ensures order + order_items queries are single-shard.</p>
    <div class="note">
        <strong>Denormalization ‚Äì <code>product_name</code>, <code>unit_price</code>, <code>image_url</code>:</strong> These are snapshots of the product data at the time of purchase. If the seller later renames the product or changes the price, the order history must still reflect what the buyer actually paid. This is a critical denormalization for historical accuracy in e-commerce.
    </div>
    <p><strong>Read events:</strong> User views order details; seller views sales report.</p>
    <p><strong>Write events:</strong> Order placement (INSERT, within the same transaction as the order).</p>
</div>

<div class="card">
    <h4>payments</h4>
    <p><span class="tag tag-sql">SQL</span> ‚Äî Financial data requires ACID. Co-located with orders for transactional writes.</p>
    <table>
        <tr><th>Column</th><th>Type</th><th>Key</th><th>Description</th></tr>
        <tr><td><code>payment_id</code></td><td>UUID</td><td>PK</td><td>Unique payment ID</td></tr>
        <tr><td><code>order_id</code></td><td>UUID</td><td>FK ‚Üí orders</td><td>Associated order</td></tr>
        <tr><td><code>amount</code></td><td>DECIMAL(12,2)</td><td></td><td>Charged amount</td></tr>
        <tr><td><code>currency</code></td><td>CHAR(3)</td><td></td><td>ISO 4217 currency code (USD, EUR, etc.)</td></tr>
        <tr><td><code>payment_method</code></td><td>VARCHAR(50)</td><td></td><td>credit_card, debit_card, gift_card, etc.</td></tr>
        <tr><td><code>payment_token</code></td><td>VARCHAR(255)</td><td></td><td>Tokenized payment reference (never raw card numbers)</td></tr>
        <tr><td><code>status</code></td><td>ENUM</td><td></td><td>PENDING, COMPLETED, FAILED, REFUNDED</td></tr>
        <tr><td><code>transaction_id</code></td><td>VARCHAR(255)</td><td></td><td>External gateway transaction reference</td></tr>
        <tr><td><code>created_at</code></td><td>TIMESTAMP</td><td></td><td>Payment initiation time</td></tr>
    </table>
    <p><strong>Indexes:</strong> B-tree on <code>order_id</code> (lookup payment for an order). B-tree on <code>transaction_id</code> (reconciliation with external gateway).</p>
    <p><strong>Read events:</strong> User views order details (payment status); finance team reconciliation.</p>
    <p><strong>Write events:</strong> Order placement (INSERT); payment status update from gateway callback (UPDATE).</p>
</div>

<div class="card">
    <h4>inventory</h4>
    <p><span class="tag tag-sql">SQL</span> ‚Äî Strong consistency is critical. Overselling must be prevented through atomic updates and row-level locking.</p>
    <table>
        <tr><th>Column</th><th>Type</th><th>Key</th><th>Description</th></tr>
        <tr><td><code>inventory_id</code></td><td>UUID</td><td>PK</td><td>Unique inventory record</td></tr>
        <tr><td><code>product_id</code></td><td>UUID</td><td></td><td>Product identifier</td></tr>
        <tr><td><code>seller_id</code></td><td>UUID</td><td></td><td>Seller who owns this stock</td></tr>
        <tr><td><code>warehouse_id</code></td><td>UUID</td><td></td><td>Fulfillment center location</td></tr>
        <tr><td><code>quantity</code></td><td>INT</td><td></td><td>Available units</td></tr>
        <tr><td><code>reserved_quantity</code></td><td>INT</td><td></td><td>Units reserved for pending orders</td></tr>
        <tr><td><code>version</code></td><td>BIGINT</td><td></td><td>Optimistic lock version</td></tr>
        <tr><td><code>updated_at</code></td><td>TIMESTAMP</td><td></td><td>Last modification time</td></tr>
    </table>
    <p><strong>Indexes:</strong></p>
    <ul>
        <li><strong>Composite B-tree index on <code>(product_id, warehouse_id)</code>:</strong> Primary access pattern: "What's the stock for product X at warehouse Y?" Also supports aggregating across warehouses: <code>SELECT SUM(quantity) FROM inventory WHERE product_id = ?</code>.</li>
        <li><strong>B-tree index on <code>seller_id</code>:</strong> Seller inventory management dashboard.</li>
    </ul>
    <p><strong>Sharding:</strong> Sharded by <code>product_id</code> (hash-based). All inventory records for a single product across warehouses are on the same shard. This ensures the reservation operation (which must check and update stock atomically) is a single-shard operation.</p>
    <p><strong>Optimistic Locking:</strong> The <code>version</code> column enables optimistic concurrency control: <code>UPDATE inventory SET quantity = quantity - 1, reserved_quantity = reserved_quantity + 1, version = version + 1 WHERE product_id = ? AND warehouse_id = ? AND version = ? AND quantity >= 1</code>. If the affected row count is 0, the operation is retried (another transaction modified the row concurrently).</p>
    <p><strong>Read events:</strong> Product detail page (stock status); cart validation; checkout reservation check.</p>
    <p><strong>Write events:</strong> Order placement (reserve stock); order cancellation (release stock); seller adds stock; warehouse receives shipment.</p>
</div>

<div class="card">
    <h4>users</h4>
    <p><span class="tag tag-sql">SQL</span> ‚Äî User accounts involve authentication and can be referenced by many other tables. Relational integrity and consistency matter.</p>
    <table>
        <tr><th>Column</th><th>Type</th><th>Key</th><th>Description</th></tr>
        <tr><td><code>user_id</code></td><td>UUID</td><td>PK</td><td>Unique user identifier</td></tr>
        <tr><td><code>email</code></td><td>VARCHAR(255)</td><td>UNIQUE</td><td>Login email</td></tr>
        <tr><td><code>password_hash</code></td><td>VARCHAR(255)</td><td></td><td>Bcrypt-hashed password</td></tr>
        <tr><td><code>name</code></td><td>VARCHAR(200)</td><td></td><td>Display name</td></tr>
        <tr><td><code>role</code></td><td>ENUM</td><td></td><td>BUYER, SELLER, ADMIN</td></tr>
        <tr><td><code>created_at</code></td><td>TIMESTAMP</td><td></td><td>Registration time</td></tr>
    </table>
    <p><strong>Indexes:</strong> Hash index on <code>email</code> (login lookup is always exact-match).</p>
    <p><strong>Sharding:</strong> Sharded by <code>user_id</code> (hash-based). Co-located with orders for efficient JOINs.</p>
    <p><strong>Read events:</strong> Login; display user profile; order placement (fetch user details).</p>
    <p><strong>Write events:</strong> Registration (INSERT); profile update (UPDATE).</p>
</div>

<!-- ===== NoSQL TABLES ===== -->
<h3>NoSQL Tables</h3>

<div class="card">
    <h4>products (NoSQL ‚Äì Document Store)</h4>
    <p><span class="tag tag-nosql">NoSQL ‚Äì Document</span> ‚Äî Products have highly variable attributes. A laptop has fields like "RAM", "CPU", "screen size" while a t-shirt has "size", "color", "material". A fixed SQL schema cannot accommodate this variety without hundreds of nullable columns or a clumsy EAV pattern. A document store allows each product to have a flexible, nested attribute structure.</p>
    <table>
        <tr><th>Field</th><th>Type</th><th>Key</th><th>Description</th></tr>
        <tr><td><code>product_id</code></td><td>String</td><td>Partition Key</td><td>Unique product identifier</td></tr>
        <tr><td><code>seller_id</code></td><td>String</td><td></td><td>Seller who listed this product</td></tr>
        <tr><td><code>name</code></td><td>String</td><td></td><td>Product title</td></tr>
        <tr><td><code>description</code></td><td>String</td><td></td><td>Detailed description (may include HTML)</td></tr>
        <tr><td><code>category</code></td><td>String[]</td><td></td><td>Category path, e.g., ["Electronics", "Headphones", "Wireless"]</td></tr>
        <tr><td><code>price</code></td><td>Number</td><td></td><td>Current price</td></tr>
        <tr><td><code>images</code></td><td>String[]</td><td></td><td>Array of image URLs (CDN paths)</td></tr>
        <tr><td><code>attributes</code></td><td>Map</td><td></td><td>Flexible key-value attributes, e.g., {"color": "black", "weight_g": 250}</td></tr>
        <tr><td><code>avg_rating</code></td><td>Number</td><td></td><td>Denormalized average rating (updated async)</td></tr>
        <tr><td><code>review_count</code></td><td>Number</td><td></td><td>Denormalized total review count</td></tr>
        <tr><td><code>status</code></td><td>String</td><td></td><td>ACTIVE, INACTIVE, PENDING_REVIEW</td></tr>
        <tr><td><code>created_at</code></td><td>String (ISO 8601)</td><td></td><td>Listing creation time</td></tr>
        <tr><td><code>updated_at</code></td><td>String (ISO 8601)</td><td></td><td>Last update time</td></tr>
    </table>
    <div class="note">
        <strong>Denormalization ‚Äì <code>avg_rating</code> and <code>review_count</code>:</strong> These values are denormalized from the reviews collection. Without this, every product page or search result would require an expensive aggregation query across potentially thousands of reviews. Instead, whenever a new review is submitted, a background worker (consuming from the message queue) recomputes the average and count and updates the product document. The tradeoff is a brief delay (seconds) before the rating reflects the latest review, which is acceptable (eventual consistency).
    </div>
    <p><strong>Sharding:</strong> Sharded by <code>product_id</code> (hash-based). Ensures even data distribution since product IDs are UUIDs.</p>
    <p><strong>Read events:</strong> Product detail page view; search result rendering; cart item validation.</p>
    <p><strong>Write events:</strong> Seller creates product (INSERT); seller updates product (UPDATE); async rating update from review pipeline (UPDATE).</p>
</div>

<div class="card">
    <h4>cart (NoSQL ‚Äì Key-Value Store)</h4>
    <p><span class="tag tag-nosql">NoSQL ‚Äì Key-Value</span> ‚Äî Cart access is always by a single key (<code>user_id</code> or <code>session_id</code>). No joins, no complex queries. A key-value store provides the lowest latency and simplest model for this use case.</p>
    <table>
        <tr><th>Field</th><th>Type</th><th>Key</th><th>Description</th></tr>
        <tr><td><code>user_id</code> / <code>session_id</code></td><td>String</td><td>Partition Key</td><td>User or session identifier</td></tr>
        <tr><td><code>items</code></td><td>Array</td><td></td><td>[{"product_id", "quantity", "added_at"}]</td></tr>
        <tr><td><code>updated_at</code></td><td>String</td><td></td><td>Last cart modification time</td></tr>
    </table>
    <p><strong>Sharding:</strong> Automatically sharded by partition key (user_id/session_id).</p>
    <p><strong>TTL:</strong> 90 days for authenticated users, 30 days for guest sessions.</p>
    <p><strong>Read events:</strong> User opens cart page; checkout flow reads cart items.</p>
    <p><strong>Write events:</strong> User adds/removes/updates item; cart merge on login; cart cleared after order placement.</p>
</div>

<div class="card">
    <h4>reviews (NoSQL ‚Äì Document Store)</h4>
    <p><span class="tag tag-nosql">NoSQL ‚Äì Document</span> ‚Äî Reviews have variable content (text, images, videos). The primary access pattern is by <code>product_id</code> (get all reviews for a product). No joins needed. Horizontal scalability for high read volume (popular products may have thousands of reviews).</p>
    <table>
        <tr><th>Field</th><th>Type</th><th>Key</th><th>Description</th></tr>
        <tr><td><code>review_id</code></td><td>String</td><td>Unique ID</td><td>Unique review identifier</td></tr>
        <tr><td><code>product_id</code></td><td>String</td><td>Partition Key</td><td>Product being reviewed</td></tr>
        <tr><td><code>user_id</code></td><td>String</td><td></td><td>Reviewer</td></tr>
        <tr><td><code>rating</code></td><td>Number (1-5)</td><td></td><td>Star rating</td></tr>
        <tr><td><code>title</code></td><td>String</td><td></td><td>Review title</td></tr>
        <tr><td><code>body</code></td><td>String</td><td></td><td>Review text</td></tr>
        <tr><td><code>images</code></td><td>String[]</td><td></td><td>Optional review images</td></tr>
        <tr><td><code>helpful_count</code></td><td>Number</td><td></td><td>"Was this helpful?" upvote count</td></tr>
        <tr><td><code>verified_purchase</code></td><td>Boolean</td><td></td><td>Whether reviewer bought the product</td></tr>
        <tr><td><code>status</code></td><td>String</td><td></td><td>APPROVED, PENDING_MODERATION, REJECTED</td></tr>
        <tr><td><code>created_at</code></td><td>String (ISO 8601)</td><td>Sort Key</td><td>Review creation time (used for sorting)</td></tr>
    </table>
    <p><strong>Sharding:</strong> Sharded by <code>product_id</code>. All reviews for a product are on the same shard, enabling efficient single-shard queries for the product detail page.</p>
    <p><strong>Secondary index on <code>(product_id, helpful_count DESC)</code>:</strong> Supports "Most Helpful" sorting without a full scan and re-sort.</p>
    <p><strong>Read events:</strong> Product detail page (fetch top reviews); user views all reviews with pagination/sorting.</p>
    <p><strong>Write events:</strong> User submits a review (INSERT); user marks a review as helpful (UPDATE: increment helpful_count); moderation pipeline updates status (UPDATE).</p>
</div>

<div class="card">
    <h4>tracking_events (NoSQL ‚Äì Time-Series / Wide-Column)</h4>
    <p><span class="tag tag-nosql">NoSQL ‚Äì Time-Series</span> ‚Äî Tracking events are append-only, time-ordered, and never updated. The sole query pattern is: "Get all events for order X, sorted by time." This is a textbook time-series workload.</p>
    <table>
        <tr><th>Field</th><th>Type</th><th>Key</th><th>Description</th></tr>
        <tr><td><code>order_id</code></td><td>String</td><td>Partition Key</td><td>Order being tracked</td></tr>
        <tr><td><code>timestamp</code></td><td>String (ISO 8601)</td><td>Sort Key</td><td>When the event occurred</td></tr>
        <tr><td><code>status</code></td><td>String</td><td></td><td>PROCESSING, SHIPPED, IN_TRANSIT, OUT_FOR_DELIVERY, DELIVERED</td></tr>
        <tr><td><code>location</code></td><td>String</td><td></td><td>Geographic location (city, state)</td></tr>
        <tr><td><code>carrier</code></td><td>String</td><td></td><td>Shipping carrier name</td></tr>
        <tr><td><code>tracking_number</code></td><td>String</td><td></td><td>Carrier tracking number</td></tr>
        <tr><td><code>details</code></td><td>String</td><td></td><td>Human-readable status note</td></tr>
    </table>
    <p><strong>Sharding:</strong> Sharded by <code>order_id</code>. Each order's tracking events form a small time-series partition.</p>
    <p><strong>Read events:</strong> User views tracking page for an order.</p>
    <p><strong>Write events:</strong> Shipping partner sends webhook update (INSERT ‚Äî append-only).</p>
</div>

<div class="card">
    <h4>user_history (NoSQL ‚Äì Key-Value)</h4>
    <p><span class="tag tag-nosql">NoSQL ‚Äì Key-Value</span> ‚Äî Stores browsing and purchase history per user for the Recommendation Service. Simple key-value access by user_id. High write volume (every page view, search, and purchase is logged).</p>
    <table>
        <tr><th>Field</th><th>Type</th><th>Key</th><th>Description</th></tr>
        <tr><td><code>user_id</code></td><td>String</td><td>Partition Key</td><td>User identifier</td></tr>
        <tr><td><code>recent_views</code></td><td>Array</td><td></td><td>Last 100 viewed product IDs with timestamps</td></tr>
        <tr><td><code>recent_searches</code></td><td>Array</td><td></td><td>Last 50 search queries</td></tr>
        <tr><td><code>recent_purchases</code></td><td>Array</td><td></td><td>Last 200 purchased product IDs</td></tr>
    </table>
    <p><strong>Read events:</strong> Recommendation Service generates recommendations.</p>
    <p><strong>Write events:</strong> Every product view, search, and purchase appends to the user's history (async via message queue to avoid impacting hot-path latency).</p>
</div>

<div class="card">
    <h4>Search Index (Inverted Index)</h4>
    <p><span class="tag tag-nosql">Search Index ‚Äì Inverted Index</span> ‚Äî Not a traditional database, but a specialized index for full-text search. Each product document is tokenized and indexed. The inverted index maps tokens to posting lists of product IDs. Supports ranking (TF-IDF, BM25), faceted search, and filters.</p>
    <p><strong>Indexed fields:</strong></p>
    <ul>
        <li><code>name</code> ‚Äî Full-text inverted index (tokenized, stemmed, with synonyms)</li>
        <li><code>description</code> ‚Äî Full-text inverted index</li>
        <li><code>category</code> ‚Äî Keyword index (exact match for faceted filtering)</li>
        <li><code>brand</code> ‚Äî Keyword index</li>
        <li><code>price</code> ‚Äî Numeric range index (for price filter queries)</li>
        <li><code>avg_rating</code> ‚Äî Numeric range index (for rating filter)</li>
    </ul>
    <p><strong>Sharding:</strong> Sharded by product_id (hash-based) across multiple index nodes. Each node holds a subset of the index. Search queries are scatter-gathered across all shards, and results are merged and ranked.</p>
    <p><strong>Read events:</strong> User performs a search query.</p>
    <p><strong>Write events:</strong> Search Indexer processes <code>product.created</code> / <code>product.updated</code> / <code>product.deleted</code> events from the message queue.</p>
</div>


<!-- ============================================================ -->
<!-- 11. CDN & CACHING DEEP DIVE -->
<!-- ============================================================ -->
<h2 id="cdn-cache">11. CDN &amp; Caching Deep Dive</h2>

<h3>CDN (Content Delivery Network)</h3>
<div class="card">
    <p><strong>Why a CDN is appropriate:</strong> An e-commerce platform like Amazon serves billions of product images, thumbnails, JavaScript bundles, CSS files, and fonts daily. Without a CDN, every image request would hit the origin Object Storage, causing high latency for users far from the data center and enormous bandwidth costs. A CDN is not just appropriate ‚Äî it is essential.</p>

    <h4>What the CDN Serves</h4>
    <ul>
        <li><strong>Product images:</strong> Multiple resolutions (thumbnail: 200√ó200, medium: 600√ó600, large: 1200√ó1200). Images are stored in Object Storage and cached at CDN edge nodes globally.</li>
        <li><strong>Static website assets:</strong> JavaScript bundles, CSS stylesheets, fonts, favicon. These are deployed with content-hash file names for aggressive caching.</li>
        <li><strong>Category landing pages:</strong> Pre-rendered HTML for popular category pages (e.g., "Electronics > Laptops") to reduce server load.</li>
    </ul>

    <h4>CDN Strategy</h4>
    <ul>
        <li><strong>Pull-based (lazy):</strong> The CDN does not pre-populate. On the first request for an asset, the CDN fetches it from the origin (Object Storage) and caches it at the edge. Subsequent requests are served from the edge cache.</li>
        <li><strong>Cache-Control headers:</strong> Product images: <code>Cache-Control: public, max-age=86400, immutable</code> (24 hours; image URLs include a version hash so changed images get new URLs). Static assets: <code>Cache-Control: public, max-age=31536000, immutable</code> (1 year; content-hashed filenames).</li>
        <li><strong>Invalidation:</strong> When a seller updates a product image, a new URL is generated (with a new hash). The old URL continues to serve the old image from cache until it expires, but the product document now points to the new URL. This avoids the need for explicit cache invalidation.</li>
    </ul>
</div>

<h3>In-Memory Caches</h3>

<div class="card">
    <h4>Search Cache</h4>
    <table>
        <tr><th>Property</th><th>Value</th><th>Rationale</th></tr>
        <tr><td><strong>Caching Strategy</strong></td><td>Cache-Aside (Lazy Loading)</td><td>Search results are only cached after a query is executed. There's no way to predict all possible search queries in advance, so populating on-demand is the only practical approach.</td></tr>
        <tr><td><strong>Cache Key</strong></td><td><code>hash(query + filters + sort + page)</code></td><td>Deterministic key based on all query parameters. Same query with different filters = different cache entry.</td></tr>
        <tr><td><strong>Eviction Policy</strong></td><td>LRU (Least Recently Used)</td><td>Popular searches ("iPhone", "headphones") are accessed frequently and stay in cache. Niche searches are evicted first.</td></tr>
        <tr><td><strong>Expiration Policy (TTL)</strong></td><td>2 minutes</td><td>Search results can become stale quickly (new products listed, prices changed, stock levels changed). A short TTL ensures freshness while still absorbing bursts of identical queries.</td></tr>
        <tr><td><strong>Population Trigger</strong></td><td>Cache miss during a user search</td><td>After a cache miss, the search result is computed from the Search Index and written to the cache before returning.</td></tr>
        <tr><td><strong>Estimated Hit Rate</strong></td><td>40-60%</td><td>Head queries ("laptop", "shoes") account for a large fraction of total searches and benefit enormously from caching. Long-tail queries miss but are individually inexpensive.</td></tr>
    </table>
</div>

<div class="card">
    <h4>Product Cache</h4>
    <table>
        <tr><th>Property</th><th>Value</th><th>Rationale</th></tr>
        <tr><td><strong>Caching Strategy</strong></td><td>Cache-Aside (Lazy Loading) with Write-Through on updates</td><td>Products are loaded into cache on first access. When a seller updates a product, the Product Service writes through to both the DB and the cache, ensuring the cache is always up-to-date for popular products. This hybrid approach avoids stale cache entries for products that were recently changed.</td></tr>
        <tr><td><strong>Cache Key</strong></td><td><code>product:{product_id}</code></td><td>Simple, deterministic key.</td></tr>
        <tr><td><strong>Eviction Policy</strong></td><td>LRU (Least Recently Used)</td><td>Popular products (bestsellers, trending items) stay warm. Niche products that haven't been viewed recently are evicted.</td></tr>
        <tr><td><strong>Expiration Policy (TTL)</strong></td><td>10 minutes</td><td>Longer than Search Cache because product data changes less frequently than search rankings. But short enough to pick up price changes and stock updates reasonably quickly, even if the write-through fails.</td></tr>
        <tr><td><strong>Population Trigger</strong></td><td>Cache miss during product page view or search result assembly; write-through on product update.</td><td></td></tr>
        <tr><td><strong>Estimated Hit Rate</strong></td><td>70-85%</td><td>Product views follow a power-law distribution: a small percentage of products (bestsellers) receive the vast majority of views. These stay permanently warm in cache.</td></tr>
    </table>
</div>

<div class="card">
    <h4>Cart Cache (Optional ‚Äî Built Into Cart Store)</h4>
    <p>The Cart Store itself is a NoSQL key-value store, which already provides sub-millisecond reads. An additional in-memory cache layer on top of the Cart Store is <strong>not necessary</strong>. The key-value store already serves as a fast-access data layer. Adding another cache would add complexity without meaningful latency improvement, since the Cart Store is already optimized for single-key lookups.</p>
</div>

<div class="card">
    <h4>Session Cache</h4>
    <table>
        <tr><th>Property</th><th>Value</th><th>Rationale</th></tr>
        <tr><td><strong>Caching Strategy</strong></td><td>Write-Through</td><td>Session data is written to the cache immediately when a user logs in or updates their session. Every request reads from the cache for authentication.</td></tr>
        <tr><td><strong>Cache Key</strong></td><td><code>session:{session_token}</code></td><td>Maps session token ‚Üí user_id, role, expiration.</td></tr>
        <tr><td><strong>Eviction Policy</strong></td><td>TTL-based (no LRU needed)</td><td>Sessions have natural expiration times. No need for LRU since session tokens are unique and don't compete for space the way product data does.</td></tr>
        <tr><td><strong>Expiration Policy (TTL)</strong></td><td>24 hours (sliding window)</td><td>Session expires after 24 hours of inactivity. Each authenticated request resets the TTL.</td></tr>
        <tr><td><strong>Population Trigger</strong></td><td>User login; token refresh.</td><td></td></tr>
    </table>
</div>


<!-- ============================================================ -->
<!-- 12. MESSAGE QUEUE DEEP DIVE -->
<!-- ============================================================ -->
<h2 id="mq-deep">12. Message Queue Deep Dive</h2>

<div class="card">
    <h3>Why a Message Queue</h3>
    <p>Several operations in the system are <strong>asynchronous by nature</strong> ‚Äî they don't need to complete before the user gets a response, and they benefit from being decoupled from the hot path:</p>
    <ul>
        <li><strong>Notifications:</strong> Sending an email or push notification can take seconds and may fail transiently. It should never block the "Place Order" response.</li>
        <li><strong>Search Indexing:</strong> Updating the search index after a product change is important but not urgent (a few seconds of staleness is acceptable).</li>
        <li><strong>Warehouse Fulfillment:</strong> The pick-pack-ship workflow is a long-running process that should be initiated but not waited on.</li>
        <li><strong>Analytics:</strong> Recording events for recommendations and dashboards is non-critical.</li>
        <li><strong>Review Moderation:</strong> Content policy checks run asynchronously after a review is submitted.</li>
    </ul>

    <h3>Why Not Direct Service-to-Service Calls</h3>
    <ul>
        <li><strong>Tight coupling:</strong> If the Order Service directly calls the Notification Service and the Notification Service is down, the order placement fails ‚Äî unacceptable.</li>
        <li><strong>No buffering:</strong> During a traffic spike (e.g., flash sale), direct calls can overwhelm downstream services. The message queue acts as a buffer.</li>
        <li><strong>No retry:</strong> If a notification email fails to send, there's no built-in retry with direct calls. The queue provides at-least-once delivery with retries.</li>
    </ul>

    <h3>Architecture</h3>
    <p>The message queue follows a <strong>topic-based publish/subscribe</strong> model with <strong>consumer groups</strong>:</p>

    <h4>Topics and Events</h4>
    <table>
        <tr><th>Topic</th><th>Publisher</th><th>Consumers</th><th>Event Payload (key fields)</th></tr>
        <tr><td><code>order.confirmed</code></td><td>Order Service</td><td>Notification Service, Warehouse Service, Analytics Service</td><td>order_id, user_id, items[], total_amount, shipping_address</td></tr>
        <tr><td><code>order.cancelled</code></td><td>Order Service</td><td>Notification Service, Inventory Service (release stock), Analytics Service</td><td>order_id, user_id, reason</td></tr>
        <tr><td><code>tracking.updated</code></td><td>Tracking Service</td><td>Notification Service, Order Service</td><td>order_id, status, location, timestamp</td></tr>
        <tr><td><code>product.created</code></td><td>Product Service</td><td>Search Indexer</td><td>product_id, name, description, category, price, images</td></tr>
        <tr><td><code>product.updated</code></td><td>Product Service</td><td>Search Indexer, Product Cache (invalidation)</td><td>product_id, changed_fields</td></tr>
        <tr><td><code>review.submitted</code></td><td>Review Service</td><td>Moderation Service, Rating Aggregator (updates avg_rating in Product DB)</td><td>review_id, product_id, rating, text</td></tr>
        <tr><td><code>user.activity</code></td><td>API Gateway / various</td><td>Recommendation Service (updates user_history)</td><td>user_id, event_type (view/search/purchase), product_id?, query?</td></tr>
    </table>

    <h4>How Messages Are Produced</h4>
    <p>After the Order Service commits the order to the SQL database, it publishes a message to the <code>order.confirmed</code> topic. To ensure the message is published if and only if the order is committed, we use the <strong>Transactional Outbox Pattern</strong>:</p>
    <ol>
        <li>The Order Service writes the order row AND an outbox event row in the same database transaction.</li>
        <li>A separate <strong>Outbox Relay</strong> process polls the outbox table (or uses change data capture) and publishes pending messages to the message queue.</li>
        <li>After successful publishing, the outbox row is marked as published.</li>
    </ol>
    <p>This guarantees that no events are lost even if the message queue is temporarily unavailable ‚Äî the outbox relay will retry.</p>

    <h4>How Messages Are Consumed</h4>
    <ul>
        <li>Each consumer group (e.g., "notification-group", "warehouse-group") independently reads from the topic.</li>
        <li><strong>At-least-once delivery:</strong> A message is delivered at least once to each consumer group. Consumers must be idempotent.</li>
        <li><strong>Acknowledgment:</strong> After a consumer processes a message, it commits an acknowledgment (offset). If the consumer crashes before acknowledging, the message is redelivered.</li>
        <li><strong>Dead Letter Queue (DLQ):</strong> Messages that fail after 3 retries are moved to a DLQ for manual investigation.</li>
        <li><strong>Ordering:</strong> Messages within the same partition (keyed by order_id or product_id) are processed in order. This ensures, for example, that a "product.created" event is processed before a "product.updated" event for the same product.</li>
    </ul>

    <h4>Why Not WebSockets or Server-Sent Events (SSE) for Internal Communication</h4>
    <p>WebSockets and SSE are designed for real-time client-server communication. For <strong>service-to-service async communication</strong>, a message queue is superior because:</p>
    <ul>
        <li>Message queues provide <strong>persistence</strong> ‚Äî messages survive service restarts.</li>
        <li>Message queues provide <strong>at-least-once delivery guarantees</strong> ‚Äî WebSockets/SSE are fire-and-forget.</li>
        <li>Message queues provide <strong>consumer group semantics</strong> ‚Äî multiple independent consumers can each get a copy of every message.</li>
        <li>Message queues provide <strong>backpressure handling</strong> ‚Äî slow consumers don't affect producers.</li>
    </ul>
</div>


<!-- ============================================================ -->
<!-- 13. PROTOCOL DEEP DIVE -->
<!-- ============================================================ -->
<h2 id="protocols">13. Protocol Deep Dive (gRPC, HTTP, Webhooks)</h2>

<div class="card">
    <h3>Client ‚Üí API Gateway: HTTPS (HTTP/1.1 or HTTP/2)</h3>
    <p>All client-facing communication uses HTTPS over TCP. HTTP is chosen over raw TCP because:</p>
    <ul>
        <li>REST APIs map naturally to HTTP methods (GET, POST, PUT, DELETE).</li>
        <li>HTTPS provides encryption (TLS), which is mandatory for transmitting auth tokens, payment info, and personal data.</li>
        <li>Browsers and mobile SDKs have first-class HTTP support.</li>
        <li>HTTP/2 is used where supported for multiplexed requests and header compression.</li>
    </ul>
    <p><strong>Why not WebSockets:</strong> The client-server interaction for e-commerce is predominantly request-response. WebSockets are designed for bidirectional, long-lived connections. The only potential use case (real-time tracking) is better served by polling + push notifications (see Flow 5 for reasoning).</p>
    <p><strong>Why not UDP:</strong> All e-commerce operations require reliable, ordered delivery. Loss of an order request or payment response is unacceptable. TCP's reliability guarantees are essential.</p>
</div>

<div class="card">
    <h3>Service ‚Üí Service: gRPC over HTTP/2</h3>
    <p>Internal service-to-service calls (e.g., Order Service ‚Üí Inventory Service, Search Service ‚Üí Product Service) use gRPC. Reasons:</p>
    <ul>
        <li><strong>Performance:</strong> Protocol Buffers (binary serialization) are 5-10x smaller and faster to serialize/deserialize than JSON.</li>
        <li><strong>HTTP/2:</strong> Multiplexed connections, header compression, bidirectional streaming.</li>
        <li><strong>Strong typing:</strong> .proto files define a strict contract between services. Breaking changes are caught at compile time, not at runtime.</li>
        <li><strong>Code generation:</strong> Client and server stubs are auto-generated from .proto files in any language.</li>
    </ul>
    <p><strong>Why not REST for internal:</strong> REST over JSON works but is less efficient for high-throughput internal calls. The overhead of JSON serialization/deserialization and text-based HTTP/1.1 headers is unnecessary when both ends are services we control.</p>
</div>

<div class="card">
    <h3>Shipping Partner ‚Üí Tracking Service: Webhooks (HTTPS POST)</h3>
    <p>Shipping partners push status updates via webhooks. The webhook endpoint is authenticated via API keys and IP whitelisting. See Flow 5 for detailed reasoning on why webhooks were chosen over polling.</p>
</div>

<div class="card">
    <h3>Payment Service ‚Üí External Payment Gateway: HTTPS</h3>
    <p>PCI-DSS mandates that all payment data is transmitted over encrypted channels. The Payment Service communicates with external payment processors via HTTPS POST requests with signed payloads. Mutual TLS (mTLS) is used for additional authentication.</p>
</div>


<!-- ============================================================ -->
<!-- 14. SCALING CONSIDERATIONS -->
<!-- ============================================================ -->
<h2 id="scaling">14. Scaling Considerations</h2>

<div class="card">
    <h3>Load Balancers</h3>
    <p>Load balancers are placed at two levels:</p>
    <ol>
        <li><strong>External Load Balancer (L7):</strong> Between clients (browsers/apps) and the API Gateway. This is the single entry point for all traffic. It performs:
            <ul>
                <li>TLS termination (offloads SSL from backend).</li>
                <li>Health checking of API Gateway instances.</li>
                <li>Geographic routing (route to nearest regional cluster).</li>
                <li>Round-robin or least-connections load balancing.</li>
                <li>DDoS protection and connection limiting.</li>
            </ul>
        </li>
        <li><strong>Internal Load Balancers (L4/L7):</strong> Between the API Gateway and each microservice. Each service (Search Service, Product Service, Cart Service, etc.) runs multiple stateless instances. An internal load balancer distributes requests across instances. These can be simpler (L4, TCP-level) since TLS is already terminated. They use health checks and round-robin distribution.</li>
    </ol>

    <div class="diagram-container">
    <pre class="mermaid">
    graph LR
        C["Clients"] --> ELB["External LB (L7)<br/>TLS Termination"]
        ELB --> GW1["API Gateway #1"]
        ELB --> GW2["API Gateway #2"]
        ELB --> GW3["API Gateway #N"]
        GW1 --> ILB_S["Internal LB<br/>(Search)"]
        GW1 --> ILB_O["Internal LB<br/>(Orders)"]
        ILB_S --> S1["Search #1"]
        ILB_S --> S2["Search #2"]
        ILB_S --> S3["Search #N"]
        ILB_O --> O1["Order #1"]
        ILB_O --> O2["Order #2"]

        style ELB fill:#fff3e0,stroke:#e65100,stroke-width:2px
        style ILB_S fill:#fff3e0,stroke:#e65100,stroke-width:2px
        style ILB_O fill:#fff3e0,stroke:#e65100,stroke-width:2px
    </pre>
    </div>

    <h3>Horizontal Scaling of Stateless Services</h3>
    <p>All application services (Search, Product, Cart, Order, Review, Tracking, Seller, Notification, Recommendation) are <strong>stateless</strong>. They store no local state ‚Äî all state is in databases, caches, or the message queue. This means any instance can handle any request, and instances can be added or removed freely.</p>
    <ul>
        <li><strong>Auto-scaling:</strong> Each service is configured with auto-scaling rules based on CPU utilization (target: 60-70%) and request queue depth. During a flash sale (e.g., Prime Day), the Order Service and Inventory Service may scale from 50 to 500 instances within minutes.</li>
        <li><strong>Pre-scaling:</strong> For known traffic spikes (Black Friday, Prime Day), services are pre-scaled hours in advance based on historical data.</li>
    </ul>

    <h3>Database Scaling</h3>
    <ul>
        <li><strong>SQL (Order DB, Inventory DB):</strong>
            <ul>
                <li><strong>Read replicas:</strong> Each SQL master has 2-5 read replicas. "My Orders" reads can hit replicas (eventual consistency is acceptable for a list view). Order placement writes always hit the primary.</li>
                <li><strong>Sharding:</strong> As described in the schema section ‚Äî Order DB sharded by user_id, Inventory DB sharded by product_id. Sharding distributes both data volume and write load.</li>
                <li><strong>Connection pooling:</strong> Each service instance maintains a connection pool to the database, limiting the total number of connections and reducing connection overhead.</li>
            </ul>
        </li>
        <li><strong>NoSQL (Product DB, Cart Store, Review DB, Tracking DB):</strong>
            <ul>
                <li>NoSQL databases are inherently horizontally scalable. Adding nodes to the cluster automatically redistributes data (consistent hashing).</li>
                <li>Replication factor of 3 for durability and read throughput.</li>
            </ul>
        </li>
        <li><strong>Search Index:</strong> Sharded across multiple nodes. Each shard is replicated for redundancy. During traffic spikes, search replicas can be scaled up to absorb read load.</li>
    </ul>

    <h3>Cache Scaling</h3>
    <ul>
        <li>In-memory cache is deployed as a <strong>distributed cluster</strong> (consistent hashing across cache nodes). Adding cache nodes redistributes keys with minimal disruption.</li>
        <li>Cache clusters are deployed per-region to minimize latency.</li>
    </ul>

    <h3>Message Queue Scaling</h3>
    <ul>
        <li>Topics are partitioned across multiple brokers. More partitions = higher throughput.</li>
        <li>Consumer groups can be scaled by adding more consumer instances (up to the number of partitions).</li>
        <li>During peak events, partitions can be increased in advance.</li>
    </ul>

    <h3>Multi-Region Deployment</h3>
    <ul>
        <li><strong>Active-active</strong> across 3+ geographic regions (e.g., US-East, US-West, EU-West, AP-Southeast).</li>
        <li>Each region has a full deployment of all services, caches, and databases.</li>
        <li>SQL databases use <strong>cross-region replication</strong> with a primary region for writes. Read-heavy workloads are served locally.</li>
        <li>The CDN serves users from the nearest edge node (200+ edge locations globally).</li>
        <li>DNS-based geographic routing directs users to the nearest regional cluster.</li>
    </ul>
</div>


<!-- ============================================================ -->
<!-- 15. TRADEOFFS & DEEP DIVES -->
<!-- ============================================================ -->
<h2 id="tradeoffs">15. Tradeoffs &amp; Deep Dives</h2>

<div class="card">
    <h3>1. Strong Consistency vs. Eventual Consistency</h3>
    <table>
        <tr><th>Component</th><th>Consistency Model</th><th>Rationale</th></tr>
        <tr><td>Inventory / Orders / Payments</td><td><strong>Strong consistency</strong></td><td>Financial data and stock levels cannot tolerate stale reads. Overselling a product or double-charging a user has real financial consequences. We accept higher write latency (synchronous replication) for correctness.</td></tr>
        <tr><td>Search Index</td><td><strong>Eventual consistency</strong> (seconds)</td><td>A product listed 3 seconds ago not appearing in search results is acceptable. The async indexing pipeline trades immediate consistency for decoupled, scalable writes.</td></tr>
        <tr><td>Product Cache</td><td><strong>Eventual consistency</strong> (seconds to minutes)</td><td>A product's cached price being slightly stale is acceptable because the actual price is validated at checkout time. Cache TTL and write-through mitigate staleness.</td></tr>
        <tr><td>Reviews / Ratings</td><td><strong>Eventual consistency</strong></td><td>The avg_rating on a product page updating a few seconds after a new review is submitted is imperceptible to users.</td></tr>
    </table>
</div>

<div class="card">
    <h3>2. SQL vs. NoSQL Choices</h3>
    <p><strong>Tradeoff:</strong> SQL provides ACID guarantees, relational integrity, and powerful querying but is harder to scale horizontally. NoSQL provides flexible schemas, horizontal scalability, and high throughput but sacrifices joins and transactions.</p>
    <ul>
        <li><strong>SQL for orders, payments, inventory:</strong> These entities are transactional (must not lose data, must not be inconsistent). Orders and order_items must be inserted atomically. Payment records must be audit-trail-complete. Inventory updates must be atomic (no overselling). SQL's transactions are non-negotiable here.</li>
        <li><strong>NoSQL for products, reviews, cart, tracking:</strong> Products have variable schemas (attributes differ by category). Reviews are append-heavy with simple access patterns (by product_id). Cart is a simple key-value lookup. Tracking events are append-only time-series. None of these require cross-entity transactions, and all benefit from NoSQL's horizontal scalability.</li>
    </ul>
</div>

<div class="card">
    <h3>3. Saga Pattern vs. Two-Phase Commit (2PC)</h3>
    <p><strong>Chosen: Saga Pattern.</strong> The checkout flow spans multiple services (Inventory, Payment, Order). We chose the Saga pattern over 2PC because:</p>
    <ul>
        <li><strong>2PC requires all participants to be available</strong> during the commit phase. If the Payment Gateway is slow, the entire transaction blocks, holding locks on inventory rows. This is unacceptable at scale.</li>
        <li><strong>Sagas are non-blocking.</strong> Each step commits independently. If a later step fails, compensating transactions undo prior steps asynchronously.</li>
        <li><strong>2PC is not supported across different databases.</strong> Our inventory is in SQL, products in NoSQL ‚Äî 2PC doesn't span heterogeneous data stores.</li>
    </ul>
    <p><strong>Tradeoff:</strong> Sagas provide <strong>eventual consistency</strong> rather than strict atomicity. There's a brief window where inventory is reserved but payment hasn't completed. The TTL on inventory reservations (10 minutes) handles the failure case ‚Äî if payment never completes, the reservation auto-expires.</p>
</div>

<div class="card">
    <h3>4. Synchronous vs. Asynchronous Order Processing</h3>
    <p><strong>Chosen: Synchronous for the critical path, asynchronous for non-critical.</strong></p>
    <ul>
        <li><strong>Synchronous (user waits):</strong> Reserve inventory ‚Üí Process payment ‚Üí Create order ‚Üí Return confirmation. These must complete before the user gets a response, because the user needs to know if their order succeeded.</li>
        <li><strong>Asynchronous (user doesn't wait):</strong> Send notifications, update search index, initiate warehouse fulfillment, record analytics. These happen after the order is confirmed via the message queue.</li>
    </ul>
    <p><strong>Tradeoff:</strong> The synchronous path has higher latency (~1-3 seconds) due to the payment gateway call. But correctness (confirming payment before confirming the order) outweighs speed here.</p>
</div>

<div class="card">
    <h3>5. Microservices vs. Monolith</h3>
    <p><strong>Chosen: Microservices.</strong> At Amazon's scale, independent deployability, team autonomy, and per-service scaling are essential. The Search team can deploy 10x/day without affecting the Order team. The Inventory Service can scale independently during flash sales.</p>
    <p><strong>Tradeoff:</strong> Microservices add operational complexity: service discovery, distributed tracing, network latency between services, data consistency challenges across service boundaries. This complexity is justified at scale but would be premature for a startup.</p>
</div>

<div class="card">
    <h3>6. Denormalization Tradeoffs</h3>
    <ul>
        <li><strong><code>shipping_address</code> in orders:</strong> Denormalized for historical accuracy. Tradeoff: if we need to update an address retroactively (extremely rare), we'd need to update every order that used it. Acceptable because order addresses should never be retroactively changed.</li>
        <li><strong><code>product_name</code>, <code>unit_price</code> in order_items:</strong> Denormalized for point-in-time correctness. Tradeoff: if a product is rebranded, old orders still show the old name. This is desired behavior (a receipt should show what was purchased at the time).</li>
        <li><strong><code>avg_rating</code>, <code>review_count</code> in products:</strong> Denormalized to avoid expensive aggregation on every product page view. Tradeoff: a brief delay (seconds) before a new review is reflected in the average. Acceptable for UX.</li>
    </ul>
</div>

<div class="card">
    <h3>7. Transactional Outbox Pattern</h3>
    <p>The outbox pattern ensures exactly-once event publishing even when the message queue is unavailable. <strong>Tradeoff:</strong> it adds a polling mechanism (or CDC) and an outbox table that must be maintained. The operational complexity is offset by the guarantee that no order events are ever lost ‚Äî which is critical for notifications, warehouse fulfillment, and analytics.</p>
</div>


<!-- ============================================================ -->
<!-- 16. ALTERNATIVE APPROACHES -->
<!-- ============================================================ -->
<h2 id="alternatives">16. Alternative Approaches</h2>

<div class="card">
    <h3>1. GraphQL Instead of REST</h3>
    <p><strong>What it is:</strong> A single endpoint where clients specify exactly which fields they need in a query language.</p>
    <p><strong>Why considered:</strong> The product detail page requires data from multiple services (product, reviews, inventory, recommendations). GraphQL would allow the client to request all of this in a single query, reducing over-fetching and the number of round trips.</p>
    <p><strong>Why not chosen:</strong></p>
    <ul>
        <li><strong>Caching complexity:</strong> REST responses are easily cached at the CDN/proxy level by URL. GraphQL POST requests with dynamic query bodies are much harder to cache.</li>
        <li><strong>API Gateway aggregation:</strong> Our API Gateway already aggregates parallel internal calls for the product detail page, achieving a similar result to GraphQL's single-request model.</li>
        <li><strong>Rate limiting difficulty:</strong> With REST, rate limiting is straightforward (per endpoint). With GraphQL, a single query can be arbitrarily expensive, making rate limiting complex.</li>
        <li><strong>Operational maturity:</strong> REST tooling, monitoring, and debugging are more mature in most organizations.</li>
    </ul>
</div>

<div class="card">
    <h3>2. Event Sourcing for Order Management</h3>
    <p><strong>What it is:</strong> Instead of storing the current state of an order (status: SHIPPED), store an immutable log of all events (OrderPlaced, PaymentProcessed, Shipped, Delivered) and derive the current state by replaying events.</p>
    <p><strong>Why considered:</strong> Event sourcing provides a complete audit trail, easy debugging ("replay the events to see what happened"), and natural integration with event-driven architectures.</p>
    <p><strong>Why not chosen:</strong></p>
    <ul>
        <li><strong>Complexity:</strong> Event sourcing requires event stores, projections (materialized views), and snapshot management. The learning curve and operational overhead are significant.</li>
        <li><strong>Query complexity:</strong> "Show me all orders with status SHIPPED" requires a projection (materialized view), not a simple SQL query. This adds latency and infrastructure.</li>
        <li><strong>Not needed:</strong> The order lifecycle is simple (6-8 states). A status column with an audit log table achieves 90% of the benefit with 10% of the complexity.</li>
    </ul>
    <p><strong>Where we do use event-like patterns:</strong> The Tracking DB (Flow 5) is essentially an event log ‚Äî append-only tracking events. And the Transactional Outbox is an event log for reliable event publishing. So we selectively apply event-sourcing ideas where they fit naturally.</p>
</div>

<div class="card">
    <h3>3. CQRS (Command Query Responsibility Segregation)</h3>
    <p><strong>What it is:</strong> Separate the write model (optimized for writes, normalized) from the read model (optimized for reads, denormalized).</p>
    <p><strong>Why considered:</strong> The read and write patterns for orders are very different. Writes are infrequent (order placement). Reads are frequent (order history, order details) and benefit from denormalization.</p>
    <p><strong>Why not fully adopted:</strong></p>
    <ul>
        <li>We already partially apply CQRS: the Search Index is essentially a read-optimized view of product data, separate from the Product DB (write model). The Product Cache is another read-optimized layer.</li>
        <li>Full CQRS for orders would require a separate read database kept in sync via events. The added complexity is not justified because order reads are not at search-level volume, and SQL read replicas provide sufficient read scalability.</li>
    </ul>
</div>

<div class="card">
    <h3>4. Server-Sent Events (SSE) for Real-Time Order Tracking</h3>
    <p><strong>What it is:</strong> A persistent one-way connection from server to client for pushing updates.</p>
    <p><strong>Why considered:</strong> Users watching their package's tracking page could receive instant updates without refreshing.</p>
    <p><strong>Why not chosen:</strong></p>
    <ul>
        <li>Tracking updates happen a few times over several <em>days</em>. Keeping an SSE connection open for days is wasteful.</li>
        <li>Users are not typically staring at the tracking page for hours. They check it briefly and leave.</li>
        <li>Push notifications (via APNs/FCM) deliver real-time alerts without requiring the app to be open.</li>
        <li>For the rare user who is actively watching the tracking page, simple polling (every 30 seconds) is adequate and simpler to implement.</li>
    </ul>
</div>

<div class="card">
    <h3>5. Serverless Functions for Some Services</h3>
    <p><strong>What it is:</strong> Deploy individual functions (e.g., Search Indexer, Notification sender) as serverless functions that auto-scale to zero.</p>
    <p><strong>Why considered:</strong> The Search Indexer and Notification Service have bursty workloads. Serverless would auto-scale perfectly and reduce costs during quiet periods.</p>
    <p><strong>Why not chosen as primary architecture:</strong></p>
    <ul>
        <li><strong>Cold start latency:</strong> Serverless functions have cold start times (100ms-2s) that are unacceptable for hot-path services like Search and Checkout.</li>
        <li><strong>Vendor lock-in:</strong> Serverless platforms are highly vendor-specific.</li>
        <li><strong>Debugging complexity:</strong> Distributed tracing across serverless functions is harder than across long-lived service instances.</li>
    </ul>
    <p><strong>Where serverless could be used:</strong> It's a valid choice for the Search Indexer and Notification workers ‚Äî these are message-queue consumers with bursty workloads and no latency requirements. This is an architectural decision teams can make independently.</p>
</div>

<div class="card">
    <h3>6. Pessimistic Locking for Inventory Instead of Optimistic Locking</h3>
    <p><strong>What it is:</strong> <code>SELECT ... FOR UPDATE</code> to lock the inventory row before reading, preventing concurrent modifications.</p>
    <p><strong>Why not chosen:</strong></p>
    <ul>
        <li>Pessimistic locks hold the lock for the entire transaction duration. If a payment call takes 2 seconds, the inventory row is locked for 2 seconds, blocking all other orders for that product.</li>
        <li>Optimistic locking (version check on UPDATE) only blocks briefly during the actual UPDATE. If the version has changed, the operation retries. Under normal contention, retries are rare. Under high contention (flash sale on a single product), retries may increase, but this is handled by retry logic with jitter.</li>
    </ul>
    <p><strong>Note:</strong> We actually avoid the contention problem entirely by separating the inventory reservation from the payment call. The reservation is a quick atomic UPDATE that succeeds or fails in milliseconds, without holding a lock during the multi-second payment flow.</p>
</div>


<!-- ============================================================ -->
<!-- 17. ADDITIONAL INFORMATION -->
<!-- ============================================================ -->
<h2 id="additional">17. Additional Information</h2>

<div class="card">
    <h3>Circuit Breaker Pattern</h3>
    <p>Non-critical services (Recommendation Service, Review Service) are wrapped in circuit breakers. If a service fails 5 times in 10 seconds, the circuit opens and subsequent calls fail fast (return empty data) instead of timing out. The circuit half-opens after 30 seconds to test recovery. This prevents cascading failures: a Recommendation Service outage must never take down the checkout flow.</p>
</div>

<div class="card">
    <h3>Idempotency</h3>
    <p>All mutating operations include idempotency keys to handle retries safely:</p>
    <ul>
        <li><strong>Order placement:</strong> <code>Idempotency-Key</code> header prevents duplicate orders.</li>
        <li><strong>Payment processing:</strong> <code>transaction_id</code> is used as an idempotency key with the external gateway.</li>
        <li><strong>Inventory reservation:</strong> <code>order_id</code> acts as an idempotency key ‚Äî the same order can't reserve stock twice.</li>
        <li><strong>Message queue consumers:</strong> All consumers are idempotent ‚Äî processing the same message twice produces the same result (e.g., sending a notification uses the <code>event_id</code> to deduplicate).</li>
    </ul>
</div>

<div class="card">
    <h3>Rate Limiting</h3>
    <p>The API Gateway implements rate limiting at multiple levels:</p>
    <ul>
        <li><strong>Per-user:</strong> 100 requests/second (prevents abuse by individual users).</li>
        <li><strong>Per-IP:</strong> 500 requests/second (prevents DDoS from a single source).</li>
        <li><strong>Per-endpoint:</strong> Critical endpoints like <code>POST /orders</code> have stricter limits (10/minute per user) to prevent accidental order floods.</li>
    </ul>
    <p>Algorithm: <strong>Token Bucket</strong> ‚Äî allows short bursts while enforcing an average rate.</p>
</div>

<div class="card">
    <h3>Distributed Tracing &amp; Observability</h3>
    <p>Every request is assigned a <code>trace_id</code> at the API Gateway, propagated through all internal service calls (via gRPC metadata / HTTP headers). This enables end-to-end tracing of a single user request across 5-10 services. Combined with structured logging and metrics (latency percentiles, error rates, throughput per service), this provides full observability into the distributed system.</p>
</div>

<div class="card">
    <h3>Data Backup &amp; Disaster Recovery</h3>
    <ul>
        <li><strong>SQL databases:</strong> Continuous WAL (Write-Ahead Log) archiving + daily full backups. Point-in-time recovery within the last 35 days.</li>
        <li><strong>NoSQL databases:</strong> Continuous replication (factor of 3). Daily snapshots to object storage in a separate region.</li>
        <li><strong>Object Storage:</strong> Cross-region replication for all product images and media.</li>
        <li><strong>RPO (Recovery Point Objective):</strong> &lt; 1 second for SQL (synchronous replication within region). &lt; 5 minutes for cross-region.</li>
        <li><strong>RTO (Recovery Time Objective):</strong> &lt; 5 minutes for automated failover within a region. &lt; 30 minutes for cross-region failover.</li>
    </ul>
</div>

<div class="card">
    <h3>Security Considerations</h3>
    <ul>
        <li><strong>TLS everywhere:</strong> All client-facing and internal communications are encrypted.</li>
        <li><strong>JWT tokens:</strong> Short-lived (15 minutes) with refresh tokens (7 days). Stored in HTTP-only, Secure cookies.</li>
        <li><strong>PCI-DSS compliance:</strong> Payment data is tokenized. The Payment Service operates in an isolated, audited network segment.</li>
        <li><strong>Input validation:</strong> All user inputs are validated and sanitized at the API Gateway and again at each service.</li>
        <li><strong>RBAC:</strong> Role-based access control separates buyer, seller, and admin permissions.</li>
    </ul>
</div>

<div class="card">
    <h3>Inventory Reservation TTL</h3>
    <p>When an order is placed, inventory is reserved with a 10-minute TTL. If the payment fails or the order is abandoned, the reservation automatically expires and the stock becomes available again. This prevents inventory from being locked indefinitely by abandoned checkout flows. The TTL is implemented using a scheduled job that runs every minute to release expired reservations: <code>UPDATE inventory SET quantity = quantity + reserved_qty, reserved_quantity = reserved_quantity - reserved_qty WHERE reservation_expires_at &lt; NOW()</code>.</p>
</div>


<!-- ============================================================ -->
<!-- 18. VENDOR SECTION -->
<!-- ============================================================ -->
<h2 id="vendors">18. Vendor Section</h2>

<p>The design above is vendor-agnostic. Below are potential vendor choices with rationale for each component:</p>

<div class="card">
    <table>
        <tr><th>Component</th><th>Potential Vendors</th><th>Rationale</th></tr>
        <tr>
            <td><strong>SQL Database</strong><br/>(Orders, Payments, Inventory, Users)</td>
            <td>PostgreSQL, MySQL (Aurora), CockroachDB, Google Cloud Spanner</td>
            <td><strong>PostgreSQL</strong> is the most feature-rich open-source SQL DB (JSONB, CTEs, partial indexes). <strong>CockroachDB / Spanner</strong> add distributed SQL with horizontal scaling, ideal for global deployment. <strong>Aurora</strong> offers managed PostgreSQL/MySQL with automatic replication and failover.</td>
        </tr>
        <tr>
            <td><strong>NoSQL Document Store</strong><br/>(Products, Reviews)</td>
            <td>MongoDB, Amazon DynamoDB, Couchbase</td>
            <td><strong>MongoDB</strong> offers rich querying on flexible documents and secondary indexes. <strong>DynamoDB</strong> provides single-digit-millisecond latency at any scale with managed operations. <strong>Couchbase</strong> adds built-in full-text search and caching.</td>
        </tr>
        <tr>
            <td><strong>NoSQL Key-Value Store</strong><br/>(Cart, User History)</td>
            <td>Amazon DynamoDB, Redis (with persistence), Aerospike</td>
            <td><strong>DynamoDB</strong> for fully managed, auto-scaling KV with TTL support. <strong>Redis</strong> with AOF persistence for sub-millisecond reads. <strong>Aerospike</strong> for hybrid memory/SSD architecture at scale.</td>
        </tr>
        <tr>
            <td><strong>Time-Series / Wide-Column</strong><br/>(Tracking Events)</td>
            <td>Apache Cassandra, ScyllaDB, TimescaleDB, InfluxDB</td>
            <td><strong>Cassandra/ScyllaDB</strong> for massive write throughput and time-series-style partitioning. <strong>TimescaleDB</strong> if you want SQL compatibility on top of time-series data. <strong>InfluxDB</strong> for purpose-built time-series ingestion.</td>
        </tr>
        <tr>
            <td><strong>Search Index</strong></td>
            <td>Elasticsearch, OpenSearch, Apache Solr, Typesense</td>
            <td><strong>Elasticsearch / OpenSearch</strong> are the industry standards for full-text search with faceted filtering, relevance tuning, and horizontal scaling. <strong>Typesense</strong> is a simpler, faster alternative for smaller catalogs.</td>
        </tr>
        <tr>
            <td><strong>In-Memory Cache</strong></td>
            <td>Redis, Memcached, KeyDB</td>
            <td><strong>Redis</strong> supports rich data structures (sorted sets for leaderboards, hashes for session data) and clustering. <strong>Memcached</strong> is simpler and slightly faster for pure key-value caching but lacks persistence and data structures.</td>
        </tr>
        <tr>
            <td><strong>Message Queue / Event Streaming</strong></td>
            <td>Apache Kafka, Amazon SQS/SNS, RabbitMQ, Apache Pulsar, NATS</td>
            <td><strong>Kafka</strong> is the gold standard for high-throughput event streaming with consumer groups, partitions, and log retention. <strong>Pulsar</strong> offers multi-tenancy and tiered storage. <strong>RabbitMQ</strong> is simpler for traditional message queuing. <strong>SQS/SNS</strong> for fully managed, no-ops pub/sub.</td>
        </tr>
        <tr>
            <td><strong>Object Storage</strong></td>
            <td>Amazon S3, Google Cloud Storage, Azure Blob Storage, MinIO</td>
            <td><strong>S3</strong> is the de-facto standard for object storage ‚Äî virtually unlimited capacity, 11 nines of durability, lifecycle policies. <strong>MinIO</strong> for S3-compatible self-hosted storage.</td>
        </tr>
        <tr>
            <td><strong>CDN</strong></td>
            <td>CloudFront, Cloudflare, Akamai, Fastly</td>
            <td><strong>CloudFront</strong> integrates natively with S3. <strong>Cloudflare</strong> offers excellent DDoS protection and edge compute. <strong>Akamai</strong> has the largest edge network globally. <strong>Fastly</strong> offers real-time cache purging.</td>
        </tr>
        <tr>
            <td><strong>API Gateway</strong></td>
            <td>Kong, AWS API Gateway, Envoy, NGINX, Traefik</td>
            <td><strong>Kong</strong> and <strong>Envoy</strong> are open-source, extensible, and support both HTTP and gRPC routing. <strong>AWS API Gateway</strong> for managed, serverless API management.</td>
        </tr>
        <tr>
            <td><strong>Container Orchestration</strong></td>
            <td>Kubernetes (EKS, GKE, AKS), Docker Swarm, Nomad</td>
            <td><strong>Kubernetes</strong> is the industry standard for running microservices at scale ‚Äî auto-scaling, rolling deployments, service discovery, health checks. All major cloud providers offer managed Kubernetes.</td>
        </tr>
    </table>
</div>


</div> <!-- end container -->
</body>
</html>