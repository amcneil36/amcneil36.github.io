<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>System Design: TurboTax</title>
<script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
<style>
  :root {
    --bg: #0d1117;
    --card-bg: #161b22;
    --border: #30363d;
    --text: #e6edf3;
    --text-secondary: #8b949e;
    --accent: #58a6ff;
    --accent2: #3fb950;
    --accent3: #d2a8ff;
    --accent4: #f0883e;
    --accent5: #ff7b72;
    --code-bg: #1c2128;
  }
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: var(--bg);
    color: var(--text);
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
    line-height: 1.7;
    padding: 2rem;
    max-width: 1200px;
    margin: 0 auto;
  }
  h1 {
    font-size: 2.4rem;
    color: var(--accent);
    border-bottom: 2px solid var(--border);
    padding-bottom: 0.8rem;
    margin-bottom: 2rem;
  }
  h2 {
    font-size: 1.8rem;
    color: var(--accent3);
    margin-top: 3rem;
    margin-bottom: 1rem;
    border-bottom: 1px solid var(--border);
    padding-bottom: 0.4rem;
  }
  h3 {
    font-size: 1.35rem;
    color: var(--accent2);
    margin-top: 2rem;
    margin-bottom: 0.8rem;
  }
  h4 {
    font-size: 1.1rem;
    color: var(--accent4);
    margin-top: 1.5rem;
    margin-bottom: 0.5rem;
  }
  p, li {
    color: var(--text);
    margin-bottom: 0.6rem;
  }
  ul, ol {
    padding-left: 1.8rem;
    margin-bottom: 1rem;
  }
  .card {
    background: var(--card-bg);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 1.5rem;
    margin: 1.2rem 0;
  }
  .example-card {
    background: #1a2332;
    border-left: 4px solid var(--accent);
    border-radius: 0 8px 8px 0;
    padding: 1.2rem 1.5rem;
    margin: 1rem 0;
  }
  .example-card strong { color: var(--accent); }
  .warn-card {
    background: #2a1f0e;
    border-left: 4px solid var(--accent4);
    border-radius: 0 8px 8px 0;
    padding: 1.2rem 1.5rem;
    margin: 1rem 0;
  }
  .warn-card strong { color: var(--accent4); }
  .mermaid {
    background: #ffffff;
    border-radius: 8px;
    padding: 1.5rem;
    margin: 1.2rem 0;
    text-align: center;
  }
  table {
    width: 100%;
    border-collapse: collapse;
    margin: 1rem 0;
    background: var(--card-bg);
    border-radius: 8px;
    overflow: hidden;
  }
  th {
    background: #21262d;
    color: var(--accent);
    padding: 0.8rem 1rem;
    text-align: left;
    font-weight: 600;
  }
  td {
    padding: 0.7rem 1rem;
    border-top: 1px solid var(--border);
  }
  code {
    background: var(--code-bg);
    color: var(--accent5);
    padding: 0.15rem 0.4rem;
    border-radius: 4px;
    font-size: 0.9em;
  }
  .tag {
    display: inline-block;
    padding: 0.15rem 0.55rem;
    border-radius: 12px;
    font-size: 0.8em;
    font-weight: 600;
    margin-right: 0.3rem;
  }
  .tag-sql { background: #1a3a2a; color: #3fb950; }
  .tag-nosql { background: #2a1a3a; color: #d2a8ff; }
  .tag-cache { background: #3a2a1a; color: #f0883e; }
  .tag-pk { background: #1a2a3a; color: #58a6ff; }
  .tag-fk { background: #3a1a2a; color: #ff7b72; }
  .tag-idx { background: #2a3a1a; color: #7ee787; }
  hr { border: 0; border-top: 1px solid var(--border); margin: 2rem 0; }
  .toc { columns: 2; column-gap: 2rem; }
  .toc li { break-inside: avoid; }
  @media (max-width: 768px) { .toc { columns: 1; } body { padding: 1rem; } }
</style>
</head>
<body>

<h1>üèõÔ∏è System Design: TurboTax (Online Tax Preparation &amp; Filing)</h1>

<div class="card">
<strong>Overview:</strong> TurboTax is an online tax preparation platform that guides users through a step-by-step interview to prepare and electronically file their federal and state tax returns. The system must handle document uploads, real-time tax calculations, e-filing with the IRS/state agencies, and payment processing ‚Äî all while safeguarding extremely sensitive financial and personal data (SSNs, income figures, bank account numbers).
</div>

<h2>üìë Table of Contents</h2>
<ol class="toc">
  <li><a href="#fr" style="color:var(--accent);">Functional Requirements</a></li>
  <li><a href="#nfr" style="color:var(--accent);">Non-Functional Requirements</a></li>
  <li><a href="#flow1" style="color:var(--accent);">Flow 1 ‚Äî Tax Interview &amp; Auto-Save</a></li>
  <li><a href="#flow2" style="color:var(--accent);">Flow 2 ‚Äî Document Upload &amp; OCR</a></li>
  <li><a href="#flow3" style="color:var(--accent);">Flow 3 ‚Äî Tax Calculation &amp; Review</a></li>
  <li><a href="#flow4" style="color:var(--accent);">Flow 4 ‚Äî E-Filing &amp; Status Tracking</a></li>
  <li><a href="#flow5" style="color:var(--accent);">Flow 5 ‚Äî Payment Processing</a></li>
  <li><a href="#combined" style="color:var(--accent);">Combined Overall Diagram</a></li>
  <li><a href="#schema" style="color:var(--accent);">Database Schema</a></li>
  <li><a href="#caching" style="color:var(--accent);">CDN &amp; Caching Strategy</a></li>
  <li><a href="#scaling" style="color:var(--accent);">Scaling Considerations</a></li>
  <li><a href="#tradeoffs" style="color:var(--accent);">Tradeoffs &amp; Deep Dives</a></li>
  <li><a href="#alternatives" style="color:var(--accent);">Alternative Approaches</a></li>
  <li><a href="#additional" style="color:var(--accent);">Additional Considerations</a></li>
  <li><a href="#vendors" style="color:var(--accent);">Vendor Recommendations</a></li>
</ol>

<hr>

<!-- ============================================================ -->
<h2 id="fr">1. Functional Requirements</h2>
<!-- ============================================================ -->
<ol>
  <li><strong>User Authentication &amp; Account Management:</strong> Users can register, log in with multi-factor authentication (MFA), and manage their profile (name, SSN, address, filing status).</li>
  <li><strong>Guided Tax Interview:</strong> Users complete a step-by-step adaptive questionnaire that dynamically selects the next question based on prior answers (e.g., "Do you own a home?" ‚Üí show mortgage-interest deduction questions).</li>
  <li><strong>Auto-Save:</strong> User progress is saved automatically so they can resume later from exactly where they left off.</li>
  <li><strong>Document Upload &amp; OCR:</strong> Users can upload tax documents (W-2, 1099-INT, 1099-NEC, 1098, etc.) and have key fields auto-extracted via OCR.</li>
  <li><strong>Data Import:</strong> Users can import tax data directly from participating employers and financial institutions via API integrations.</li>
  <li><strong>Real-Time Tax Calculation:</strong> As users provide data, the system computes their estimated federal and state taxes (owed or refund) in real time.</li>
  <li><strong>Error &amp; Audit Risk Checks:</strong> The system validates the return for errors, missing fields, and potential audit flags before submission.</li>
  <li><strong>E-Filing:</strong> Users can electronically file their federal and state returns. The system transmits the return to the IRS/state agency via the Modernized e-File (MeF) protocol.</li>
  <li><strong>Filing Status Tracking:</strong> Users can track the status of their e-filed return (submitted ‚Üí accepted/rejected).</li>
  <li><strong>Payment Processing:</strong> Users pay for the TurboTax service tier (Free, Deluxe, Premier, Self-Employed). They can also arrange to pay taxes owed or set up direct-deposit for refunds.</li>
  <li><strong>Multi-Year Support:</strong> Users can access and amend returns from previous tax years.</li>
  <li><strong>Notifications:</strong> Users receive email/push notifications for filing confirmations, status updates, and deadline reminders.</li>
</ol>

<hr>

<!-- ============================================================ -->
<h2 id="nfr">2. Non-Functional Requirements</h2>
<!-- ============================================================ -->
<div class="card">
<table>
  <tr><th>Requirement</th><th>Target</th><th>Rationale</th></tr>
  <tr><td><strong>Availability</strong></td><td>99.99% during tax season (Jan 1 ‚Äì Apr 15)</td><td>Any downtime during tax season causes massive revenue loss and user frustration, especially near the April 15 deadline.</td></tr>
  <tr><td><strong>Latency</strong></td><td>Page load &lt; 1s; Tax calculation &lt; 2s</td><td>Users expect a responsive interview experience. Slow calculations erode confidence.</td></tr>
  <tr><td><strong>Scalability</strong></td><td>10M+ concurrent users at peak (April 14-15)</td><td>Usage is highly seasonal ‚Äî near-zero in summer, massive spike at the tax deadline.</td></tr>
  <tr><td><strong>Security &amp; Compliance</strong></td><td>SOC 2, IRS Pub 4557, PCI DSS, FedRAMP</td><td>Handles SSNs, bank accounts, and financial data. IRS mandates specific security controls for e-file providers.</td></tr>
  <tr><td><strong>Encryption</strong></td><td>AES-256 at rest; TLS 1.3 in transit</td><td>All PII and financial data must be encrypted end-to-end.</td></tr>
  <tr><td><strong>Data Durability</strong></td><td>99.9999999% (eleven 9s)</td><td>Losing a user's tax return data is catastrophic ‚Äî legal and financial liability.</td></tr>
  <tr><td><strong>Consistency</strong></td><td>Strong consistency for tax calculations &amp; filings</td><td>Tax calculations must be deterministic and correct. E-filing must not produce duplicates.</td></tr>
  <tr><td><strong>Audit Logging</strong></td><td>Immutable, 7-year retention</td><td>IRS requires records of e-filed returns and system access for 7 years.</td></tr>
  <tr><td><strong>Data Residency</strong></td><td>US-only data centers</td><td>Tax data must reside within the United States per IRS regulations.</td></tr>
</table>
</div>

<hr>

<!-- ============================================================ -->
<h2 id="flow1">3. Flow 1 ‚Äî Tax Interview &amp; Auto-Save</h2>
<!-- ============================================================ -->

<p>This is the core user experience ‚Äî a guided, adaptive questionnaire that walks the user through their tax situation section by section (Personal Info ‚Üí Income ‚Üí Deductions ‚Üí Credits ‚Üí Review).</p>

<div class="mermaid">
graph LR
    Client["üñ•Ô∏è Client<br/>(Web/Mobile)"]
    LB["‚öñÔ∏è Load Balancer"]
    GW["üö™ API Gateway<br/>(Auth + Rate Limit)"]
    IS["üìù Interview<br/>Service"]
    QE["üß† Question<br/>Engine<br/>(Rules Engine)"]
    Cache["‚ö° Cache<br/>(Question Defs<br/>+ Tax Rules)"]
    DB[("üíæ SQL DB<br/>(Answers +<br/>Returns)")]

    Client -- "HTTPS GET<br/>/interview/next-question" --> LB
    LB --> GW
    GW --> IS
    IS -- "Fetch rules &<br/>question defs" --> Cache
    Cache -. "Cache miss" .-> QE
    QE -- "Read question<br/>definitions" --> DB
    IS -- "Read user<br/>answers" --> DB

    Client -- "HTTPS PATCH<br/>/interview/answers<br/>(auto-save)" --> LB
    LB --> GW
    GW --> IS
    IS -- "Write/update<br/>answers" --> DB

    style Client fill:#1a73e8,stroke:#1565c0,color:#fff
    style LB fill:#e8710a,stroke:#c75e00,color:#fff
    style GW fill:#7b1fa2,stroke:#6a1b9a,color:#fff
    style IS fill:#2e7d32,stroke:#1b5e20,color:#fff
    style QE fill:#c62828,stroke:#b71c1c,color:#fff
    style Cache fill:#ef6c00,stroke:#e65100,color:#fff
    style DB fill:#283593,stroke:#1a237e,color:#fff
</div>

<h3>Flow 1 ‚Äî Examples</h3>

<div class="example-card">
<strong>Example 1 ‚Äî Normal Interview Progression:</strong><br/>
User Jane opens TurboTax and begins a new 2025 federal return. Her client sends <code>HTTPS GET /api/v1/interview/next-question?return_id=R123&section=personal_info</code> to the Load Balancer, which routes it through the API Gateway (validates her JWT + MFA token) to the Interview Service. The Interview Service checks the Cache for question definitions; they are cached, so it immediately retrieves question Q1 ("What is your filing status?"). Jane selects "Single" and the client fires <code>HTTPS PATCH /api/v1/interview/answers</code> with body <code>{return_id: "R123", question_id: "Q1", answer: "single"}</code>. The Interview Service writes this answer to the SQL DB. On the next GET, the Question Engine evaluates Jane's answers so far, determines she doesn't need spousal questions, and skips to Q5 ("Did you have any W-2 income?").
</div>

<div class="example-card">
<strong>Example 2 ‚Äî Auto-Save on Inactivity / Navigation:</strong><br/>
User Tom is mid-interview in the Deductions section. He has partially filled in three fields but hasn't clicked "Next" yet. Every 10 seconds of inactivity (debounced), the client batches all unsaved field changes and sends <code>HTTPS PATCH /api/v1/interview/answers</code> with body <code>{return_id: "R456", answers: [{question_id: "Q42", answer: "15000"}, {question_id: "Q43", answer: "3200"}, {question_id: "Q44", answer: ""}]}</code>. The Interview Service writes these as draft answers (even blank ones, to record the user reached those questions). Tom closes his laptop. Two days later, he reopens TurboTax ‚Äî the client sends <code>HTTPS GET /api/v1/interview/resume?return_id=R456</code>, which returns his last section, last question, and all saved answers, restoring his exact state.
</div>

<div class="example-card">
<strong>Example 3 ‚Äî Branching Logic (Edge Case):</strong><br/>
User Maria answers "Yes" to "Did you sell any stocks or cryptocurrency?" (Q30). The Question Engine evaluates rule: <code>IF Q30 == "yes" THEN queue = [Q31_capital_gains_type, Q32_cost_basis, Q33_holding_period, ...]</code>. But Maria had also previously answered "Yes" to "Did you receive any 1099-B forms?" (Q15), so the engine also cross-references that if both Q15 and Q30 are "yes," it should skip the manual capital-gains entry questions and instead prompt her to upload her 1099-B (redirecting to Flow 2). The Interview Service returns <code>{next_action: "upload_document", document_type: "1099-B", reason: "You indicated you have a 1099-B. Uploading it will auto-fill your capital gains."}</code>.
</div>

<h3>Flow 1 ‚Äî Component Deep Dive</h3>

<h4>Client (Web / Mobile)</h4>
<div class="card">
<p>A single-page application (React/Next.js for web; native iOS/Android apps) that renders the interview UI. It handles:</p>
<ul>
  <li>Rendering questions dynamically based on the Interview Service response</li>
  <li>Client-side validation (e.g., SSN format, numeric-only fields) before sending to the server</li>
  <li>Debounced auto-save (PATCH every 10s of inactivity or on navigation away)</li>
  <li>Local state management to minimize unnecessary API calls</li>
</ul>
<p><strong>Protocol:</strong> HTTPS (TLS 1.3) for all communication.</p>
</div>

<h4>Load Balancer</h4>
<div class="card">
<p>Layer-7 (application-layer) load balancer that distributes incoming HTTPS requests across Interview Service instances using a <strong>round-robin</strong> strategy (since the Interview Service is stateless). It also performs:</p>
<ul>
  <li>TLS termination</li>
  <li>Health checks on downstream service instances</li>
  <li>Connection draining during deployments</li>
</ul>
</div>

<h4>API Gateway</h4>
<div class="card">
<p>Centralized entry point that handles cross-cutting concerns before forwarding to the appropriate microservice:</p>
<ul>
  <li><strong>Authentication:</strong> Validates JWT tokens and MFA status. Rejects unauthenticated requests with 401.</li>
  <li><strong>Rate Limiting:</strong> Per-user rate limits (e.g., 100 req/min) to prevent abuse.</li>
  <li><strong>Request Routing:</strong> Routes <code>/interview/*</code> to Interview Service, <code>/documents/*</code> to Document Service, etc.</li>
  <li><strong>Audit Logging:</strong> Logs every request (user ID, endpoint, timestamp) to an immutable audit log.</li>
</ul>
</div>

<h4>Interview Service</h4>
<div class="card">
<p>The core service managing the tax interview workflow. It is <strong>stateless</strong> ‚Äî all state is stored in the database.</p>
<table>
  <tr><th>Endpoint</th><th>Method</th><th>Input</th><th>Output</th></tr>
  <tr><td><code>/interview/next-question</code></td><td>GET</td><td>Query: <code>return_id</code>, <code>section</code> (optional)</td><td>Next question object: <code>{question_id, text, type, options, validation_rules}</code></td></tr>
  <tr><td><code>/interview/answers</code></td><td>PATCH</td><td>Body: <code>{return_id, answers: [{question_id, answer}]}</code></td><td><code>{saved: true, timestamp}</code></td></tr>
  <tr><td><code>/interview/resume</code></td><td>GET</td><td>Query: <code>return_id</code></td><td><code>{section, question_id, answers: [...], completion_pct}</code></td></tr>
  <tr><td><code>/interview/section-summary</code></td><td>GET</td><td>Query: <code>return_id</code>, <code>section</code></td><td>All answers in a section for review</td></tr>
</table>
<p><strong>Protocol:</strong> HTTPS (REST). All responses use JSON. PATCH is chosen for answer updates because we are doing partial updates to the answers collection ‚Äî not replacing the entire resource.</p>
</div>

<h4>Question Engine (Rules Engine)</h4>
<div class="card">
<p>An embedded or sidecar rules engine that determines which question to show next. It evaluates conditional logic trees stored as JSON in the question-definition documents. Example rule:</p>
<pre><code>{
  "if": {"question_id": "Q30", "equals": "yes"},
  "and": {"question_id": "Q15", "equals": "yes"},
  "then": {"action": "redirect_to_upload", "doc_type": "1099-B"},
  "else": {"next_question": "Q31"}
}</code></pre>
<p>The engine loads question definitions from the Cache (or falls back to DB on cache miss). It is <strong>deterministic</strong> ‚Äî given the same set of answers, it always produces the same next question.</p>
</div>

<h4>Cache (Question Definitions + Tax Rules)</h4>
<div class="card">
<p>An in-memory cache storing question definitions and tax rules. These are <strong>read-heavy, write-rare</strong> datasets ‚Äî question definitions change only when the product team updates the interview flow, and tax rules change once per tax year.</p>
<ul>
  <li><strong>Caching Strategy:</strong> Read-through cache. On a cache miss, the service reads from DB and populates the cache.</li>
  <li><strong>Eviction Policy:</strong> LRU (Least Recently Used) ‚Äî evicts the least-accessed entries when memory is full.</li>
  <li><strong>Expiration (TTL):</strong> 24 hours. Tax rules and question definitions are stable within a day. A forced cache invalidation mechanism exists for emergency updates.</li>
  <li><strong>Why Cache:</strong> Tax rules and question definitions are read on every single question transition for every user. Without caching, the DB would be hammered with identical reads millions of times per day during tax season.</li>
</ul>
</div>

<h4>SQL Database (Answers + Returns)</h4>
<div class="card">
<p>Stores user answers, tax return metadata, and session progress. SQL is chosen because:</p>
<ul>
  <li>Tax data requires <strong>ACID transactions</strong> (e.g., saving multiple answers atomically)</li>
  <li>Strong consistency is mandatory ‚Äî a partially saved answer set could produce incorrect tax calculations</li>
  <li>Complex queries are needed for tax calculation (JOINs across answers, returns, and user tables)</li>
</ul>
<p>See the <a href="#schema" style="color:var(--accent);">Schema section</a> for full table definitions.</p>
</div>

<hr>

<!-- ============================================================ -->
<h2 id="flow2">4. Flow 2 ‚Äî Document Upload &amp; OCR Processing</h2>
<!-- ============================================================ -->

<p>Users upload tax documents (W-2, 1099, 1098, etc.) which are stored in object storage. An asynchronous OCR pipeline extracts key fields, which are then used to pre-fill interview answers.</p>

<div class="mermaid">
graph LR
    Client["üñ•Ô∏è Client"]
    LB["‚öñÔ∏è Load Balancer"]
    GW["üö™ API Gateway"]
    DS["üìÑ Document<br/>Service"]
    ObjStore[("üì¶ Object<br/>Storage<br/>(Encrypted)")]
    MQ["üì¨ Message<br/>Queue"]
    OCR["üîç OCR<br/>Worker Pool"]
    DB[("üíæ SQL DB")]
    IS["üìù Interview<br/>Service"]

    Client -- "HTTPS POST<br/>/documents/upload<br/>(multipart)" --> LB
    LB --> GW
    GW --> DS
    DS -- "Store encrypted<br/>document" --> ObjStore
    DS -- "Enqueue<br/>OCR job" --> MQ
    DS -- "Write doc<br/>metadata" --> DB
    MQ -- "Dequeue<br/>job" --> OCR
    OCR -- "Download<br/>document" --> ObjStore
    OCR -- "Write extracted<br/>data" --> DB
    OCR -- "Notify: data<br/>ready" --> IS
    IS -- "Pre-fill<br/>answers" --> DB

    Client -- "HTTPS GET<br/>/documents/{id}/status" --> LB

    style Client fill:#1a73e8,stroke:#1565c0,color:#fff
    style LB fill:#e8710a,stroke:#c75e00,color:#fff
    style GW fill:#7b1fa2,stroke:#6a1b9a,color:#fff
    style DS fill:#00695c,stroke:#004d40,color:#fff
    style ObjStore fill:#4e342e,stroke:#3e2723,color:#fff
    style MQ fill:#ad1457,stroke:#880e4f,color:#fff
    style OCR fill:#c62828,stroke:#b71c1c,color:#fff
    style DB fill:#283593,stroke:#1a237e,color:#fff
    style IS fill:#2e7d32,stroke:#1b5e20,color:#fff
</div>

<h3>Flow 2 ‚Äî Examples</h3>

<div class="example-card">
<strong>Example 1 ‚Äî Successful W-2 Upload &amp; OCR:</strong><br/>
User Jane photographs her W-2 form and uploads it. The client sends <code>HTTPS POST /api/v1/documents/upload</code> with multipart form data: <code>{return_id: "R123", document_type: "W-2", file: &lt;binary&gt;}</code>. The Document Service encrypts the file with AES-256, stores it in Object Storage, writes a metadata row to the SQL DB (<code>document_id: D789, status: "processing"</code>), and enqueues an OCR job on the Message Queue: <code>{document_id: "D789", storage_key: "encrypted/R123/D789.pdf", doc_type: "W-2"}</code>. The client receives <code>202 Accepted {document_id: "D789", status: "processing"}</code>. An OCR Worker picks up the job, downloads the encrypted document from Object Storage, decrypts it in memory, runs OCR to extract: employer name, EIN, wages (Box 1), federal tax withheld (Box 2), etc. The worker writes extracted data to the DB and marks the document as <code>"completed"</code>. The worker also notifies the Interview Service, which creates pre-filled answer entries (e.g., Q20=wages ‚Üí "85000", Q21=fed_withheld ‚Üí "17500"). When Jane returns to the interview, these fields are already populated.
</div>

<div class="example-card">
<strong>Example 2 ‚Äî OCR Failure (Low Confidence):</strong><br/>
User Tom uploads a blurry photograph of his 1099-INT. The OCR Worker processes it but achieves only 45% confidence on the interest income field (below the 80% threshold). The worker writes <code>status: "needs_review"</code> to the DB, along with the best-guess extracted value and the confidence score. When Tom's client polls <code>HTTPS GET /api/v1/documents/D790/status</code>, it receives <code>{status: "needs_review", fields: [{name: "interest_income", value: "1,234", confidence: 0.45}]}</code>. The UI highlights the low-confidence field in yellow and asks Tom to verify or correct it manually.
</div>

<div class="example-card">
<strong>Example 3 ‚Äî Data Import (No OCR Needed):</strong><br/>
User Maria clicks "Import W-2 from employer." The client sends <code>HTTPS POST /api/v1/documents/import</code> with <code>{return_id: "R789", source: "employer_api", employer_id: "EMP_456"}</code>. The Document Service calls the employer's payroll API (a pre-integrated partner), receives structured W-2 data in JSON, writes it directly to the DB as both a document record and pre-filled interview answers. No OCR is needed because the data arrives structured. Status immediately returns <code>"completed"</code>.
</div>

<h3>Flow 2 ‚Äî Component Deep Dive</h3>

<h4>Document Service</h4>
<div class="card">
<table>
  <tr><th>Endpoint</th><th>Method</th><th>Input</th><th>Output</th></tr>
  <tr><td><code>/documents/upload</code></td><td>POST</td><td>Multipart: <code>return_id</code>, <code>document_type</code>, <code>file</code></td><td><code>202 Accepted {document_id, status: "processing"}</code></td></tr>
  <tr><td><code>/documents/import</code></td><td>POST</td><td>Body: <code>{return_id, source, employer_id}</code></td><td><code>200 OK {document_id, status: "completed", fields: [...]}</code></td></tr>
  <tr><td><code>/documents/{id}/status</code></td><td>GET</td><td>Path: <code>document_id</code></td><td><code>{status, fields: [{name, value, confidence}]}</code></td></tr>
  <tr><td><code>/documents/{id}</code></td><td>DELETE</td><td>Path: <code>document_id</code></td><td><code>204 No Content</code></td></tr>
</table>
<p><strong>Protocol:</strong> HTTPS (REST). POST for uploads (creating a new resource). 202 is returned because OCR processing is asynchronous.</p>
<p>The Document Service encrypts every file before storing it in Object Storage. It never stores unencrypted PII at rest.</p>
</div>

<h4>Object Storage (Encrypted)</h4>
<div class="card">
<p>A blob/object storage system for tax document files (PDFs, images). All objects are encrypted with AES-256 using per-user encryption keys managed by a Key Management Service (KMS). Documents are organized by <code>{tax_year}/{user_id}/{document_id}.enc</code>. Objects are immutable once written ‚Äî no in-place updates. Lifecycle policy deletes documents 7 years after the tax year (IRS retention requirement).</p>
</div>

<h4>Message Queue (OCR Jobs)</h4>
<div class="card">
<p>An asynchronous message queue decouples the Document Service from the OCR Worker Pool. This is essential because:</p>
<ul>
  <li><strong>OCR is CPU-intensive and slow</strong> (2-10 seconds per document) ‚Äî we can't block the user's HTTP request.</li>
  <li><strong>Rate smoothing:</strong> During peak upload periods, the queue buffers jobs so OCR workers aren't overwhelmed.</li>
  <li><strong>Reliability:</strong> If an OCR worker crashes mid-processing, the message remains in the queue (visibility timeout) and is retried by another worker.</li>
  <li><strong>Scalability:</strong> OCR workers can auto-scale independently based on queue depth.</li>
</ul>
<p><strong>Message format:</strong> <code>{document_id, storage_key, doc_type, return_id, enqueued_at}</code></p>
<p><strong>Delivery guarantee:</strong> At-least-once delivery. OCR workers are idempotent ‚Äî processing the same document twice produces the same result and the second write is a no-op (upsert).</p>
<p><strong>Why not pub/sub?</strong> This is a job-processing pattern, not a fan-out pattern. Each OCR job should be processed by exactly one worker, not broadcast to many consumers. A message queue with competing consumers is the right fit.</p>
<p><strong>Why not synchronous processing?</strong> Users shouldn't wait 10+ seconds for an HTTP response. The async pattern returns 202 immediately and lets the user continue the interview while OCR runs in the background.</p>
</div>

<h4>OCR Worker Pool</h4>
<div class="card">
<p>A pool of stateless workers that dequeue OCR jobs, process documents, and write results. Each worker:</p>
<ol>
  <li>Dequeues a message from the queue</li>
  <li>Downloads the encrypted document from Object Storage</li>
  <li>Decrypts it in memory (never writes plaintext to disk)</li>
  <li>Runs OCR with document-type-specific templates (e.g., W-2 template knows where Box 1, Box 2, etc. are located)</li>
  <li>Assigns confidence scores to each extracted field</li>
  <li>Writes extracted data to the SQL DB</li>
  <li>Sends an internal event to the Interview Service to pre-fill answers</li>
  <li>Deletes the message from the queue (acknowledges processing)</li>
</ol>
<p>Workers auto-scale based on queue depth. During peak upload periods (January, when W-2s are issued), the pool may scale to hundreds of workers.</p>
</div>

<hr>

<!-- ============================================================ -->
<h2 id="flow3">5. Flow 3 ‚Äî Tax Calculation &amp; Review</h2>
<!-- ============================================================ -->

<p>As users complete sections, the system calculates their estimated tax liability or refund. A full calculation is triggered when the user reaches the Review section.</p>

<div class="mermaid">
graph LR
    Client["üñ•Ô∏è Client"]
    LB["‚öñÔ∏è Load Balancer"]
    GW["üö™ API Gateway"]
    CS["üßÆ Calculation<br/>Service"]
    Cache["‚ö° Cache<br/>(Tax Rules)"]
    DB[("üíæ SQL DB")]
    VS["‚úÖ Validation<br/>Service"]
    AuditLog[("üìú Audit Log<br/>(Immutable)")]

    Client -- "HTTPS POST<br/>/tax/calculate" --> LB
    LB --> GW
    GW --> CS
    CS -- "Read all<br/>answers" --> DB
    CS -- "Fetch tax<br/>rules & rates" --> Cache
    CS -- "Compute<br/>taxes" --> CS
    CS -- "Write<br/>calculation<br/>result" --> DB
    CS -- "Log calculation<br/>details" --> AuditLog

    Client -- "HTTPS POST<br/>/tax/validate" --> LB
    LB --> GW
    GW --> VS
    VS -- "Read return +<br/>answers" --> DB
    VS -- "Fetch<br/>validation rules" --> Cache
    VS -- "Return<br/>errors/warnings" --> Client

    style Client fill:#1a73e8,stroke:#1565c0,color:#fff
    style LB fill:#e8710a,stroke:#c75e00,color:#fff
    style GW fill:#7b1fa2,stroke:#6a1b9a,color:#fff
    style CS fill:#00838f,stroke:#006064,color:#fff
    style Cache fill:#ef6c00,stroke:#e65100,color:#fff
    style DB fill:#283593,stroke:#1a237e,color:#fff
    style VS fill:#558b2f,stroke:#33691e,color:#fff
    style AuditLog fill:#4e342e,stroke:#3e2723,color:#fff
</div>

<h3>Flow 3 ‚Äî Examples</h3>

<div class="example-card">
<strong>Example 1 ‚Äî Incremental Calculation (Refund):</strong><br/>
User Jane finishes the Income section and clicks "Continue." The client sends <code>HTTPS POST /api/v1/tax/calculate</code> with body <code>{return_id: "R123", scope: "federal"}</code>. The Calculation Service reads all of Jane's answers from the SQL DB: filing_status=single, W-2 wages=$85,000, federal_tax_withheld=$17,500, standard_deduction=$14,600. It fetches 2025 tax brackets from the Cache: 10% on first $11,600, 12% on $11,601-$47,150, 22% on $47,151-$100,525. It computes: taxable_income = $85,000 - $14,600 = $70,400. Tax = $1,160 + $4,266 + $5,115 = $10,541. Since Jane had $17,500 withheld, her estimated refund is $6,959. The service writes this to the DB and returns <code>{federal_tax: 10541, withheld: 17500, estimated_refund: 6959}</code>. The entire calculation, logged to the immutable Audit Log, completes in ~800ms.
</div>

<div class="example-card">
<strong>Example 2 ‚Äî Validation Errors (Missing Data):</strong><br/>
User Tom clicks "Review &amp; File." The client first calls <code>HTTPS POST /api/v1/tax/validate</code> with <code>{return_id: "R456"}</code>. The Validation Service reads Tom's return and discovers: (1) SSN is missing for a dependent he listed, (2) his 1099-NEC income is present but he didn't answer the self-employment tax questions, (3) a charitable donation of $50,000 exceeds 60% of his AGI, which is an audit flag. The service returns <code>{valid: false, errors: [{code: "MISSING_SSN", field: "dependent_2_ssn", severity: "error"}, {code: "INCOMPLETE_SECTION", section: "self_employment", severity: "error"}], warnings: [{code: "AUDIT_FLAG", message: "Charitable donations exceed 60% of AGI", severity: "warning"}]}</code>. The UI highlights the errors in red (must fix) and warnings in yellow (proceed with caution).
</div>

<div class="example-card">
<strong>Example 3 ‚Äî State Tax Calculation:</strong><br/>
User Maria lives in California and works in California. After federal calculation, the client sends <code>HTTPS POST /api/v1/tax/calculate</code> with <code>{return_id: "R789", scope: "state", state: "CA"}</code>. The Calculation Service fetches California-specific tax rules from the Cache (CA has its own brackets, credits like the California Earned Income Tax Credit, and doesn't conform to all federal deductions). It computes the CA tax separately and returns <code>{state: "CA", state_tax: 4200, state_withheld: 5000, estimated_state_refund: 800}</code>.
</div>

<h3>Flow 3 ‚Äî Component Deep Dive</h3>

<h4>Calculation Service</h4>
<div class="card">
<table>
  <tr><th>Endpoint</th><th>Method</th><th>Input</th><th>Output</th></tr>
  <tr><td><code>/tax/calculate</code></td><td>POST</td><td>Body: <code>{return_id, scope: "federal"|"state", state?}</code></td><td><code>{taxable_income, tax_owed, withheld, credits, estimated_refund_or_owed}</code></td></tr>
</table>
<p><strong>Protocol:</strong> HTTPS (REST). POST because this is a command that triggers computation and stores the result ‚Äî it is not idempotent (each call may produce different results as the user updates answers).</p>
<p>The service is <strong>stateless and deterministic</strong>. Given the same inputs (answers + tax rules), it always produces the same output. Tax rules are versioned per tax year and fetched from the Cache. The calculation logic implements IRS tax forms programmatically (Form 1040, Schedule A, Schedule C, etc.).</p>
<p><strong>Why not client-side calculation?</strong> Tax rules are complex and proprietary. Putting them client-side would expose business logic and create correctness risks (users could tamper with calculations).</p>
</div>

<h4>Validation Service</h4>
<div class="card">
<table>
  <tr><th>Endpoint</th><th>Method</th><th>Input</th><th>Output</th></tr>
  <tr><td><code>/tax/validate</code></td><td>POST</td><td>Body: <code>{return_id}</code></td><td><code>{valid: bool, errors: [...], warnings: [...]}</code></td></tr>
</table>
<p><strong>Protocol:</strong> HTTPS (REST). POST because validation has side effects (logs validation results for auditing).</p>
<p>The Validation Service runs three types of checks:</p>
<ol>
  <li><strong>Completeness checks:</strong> Are all required fields filled in?</li>
  <li><strong>Consistency checks:</strong> Do the numbers add up? (e.g., total income on 1040 matches sum of all income sources)</li>
  <li><strong>Audit risk checks:</strong> Are any values statistical outliers that might trigger an IRS audit? (e.g., home office deduction > 30% of income)</li>
</ol>
</div>

<h4>Audit Log (Immutable)</h4>
<div class="card">
<p>An append-only, immutable log that records every tax calculation performed, including inputs, outputs, tax-rules version, and timestamp. This is required by IRS regulations ‚Äî if a user's return is audited years later, we must be able to reproduce exactly how the return was calculated. The audit log is stored in a write-once storage system with 7-year retention. It is never modified or deleted.</p>
</div>

<hr>

<!-- ============================================================ -->
<h2 id="flow4">6. Flow 4 ‚Äî E-Filing &amp; Status Tracking</h2>
<!-- ============================================================ -->

<p>After review, the user submits their return for e-filing. The system transmits it to the IRS via the Modernized e-File (MeF) system and tracks the status asynchronously.</p>

<div class="mermaid">
graph LR
    Client["üñ•Ô∏è Client"]
    LB["‚öñÔ∏è Load Balancer"]
    GW["üö™ API Gateway"]
    FS["üì® Filing<br/>Service"]
    MQ["üì¨ Message<br/>Queue"]
    FW["üèõÔ∏è Filing<br/>Worker"]
    IRS["üá∫üá∏ IRS MeF<br/>(External)"]
    DB[("üíæ SQL DB")]
    NS["üîî Notification<br/>Service"]
    AuditLog[("üìú Audit Log")]

    Client -- "HTTPS POST<br/>/filing/submit" --> LB
    LB --> GW
    GW --> FS
    FS -- "Idempotency<br/>check" --> DB
    FS -- "Enqueue<br/>filing job" --> MQ
    FS -- "Write filing<br/>record" --> DB
    MQ -- "Dequeue<br/>job" --> FW
    FW -- "Generate XML<br/>& transmit" --> IRS
    IRS -- "ACK /<br/>NACK" --> FW
    FW -- "Update filing<br/>status" --> DB
    FW -- "Log<br/>submission" --> AuditLog
    FW -- "Trigger<br/>notification" --> NS
    NS -- "Email / Push<br/>notification" --> Client

    Client -- "HTTPS GET<br/>/filing/{id}/status" --> LB

    style Client fill:#1a73e8,stroke:#1565c0,color:#fff
    style LB fill:#e8710a,stroke:#c75e00,color:#fff
    style GW fill:#7b1fa2,stroke:#6a1b9a,color:#fff
    style FS fill:#6a1b9a,stroke:#4a148c,color:#fff
    style MQ fill:#ad1457,stroke:#880e4f,color:#fff
    style FW fill:#bf360c,stroke:#8d1c00,color:#fff
    style IRS fill:#1b5e20,stroke:#0d3010,color:#fff
    style DB fill:#283593,stroke:#1a237e,color:#fff
    style NS fill:#f9a825,stroke:#f57f17,color:#000
    style AuditLog fill:#4e342e,stroke:#3e2723,color:#fff
</div>

<h3>Flow 4 ‚Äî Examples</h3>

<div class="example-card">
<strong>Example 1 ‚Äî Successful Federal E-File:</strong><br/>
User Jane reviews her return, confirms everything looks correct, and clicks "File My Return." The client sends <code>HTTPS POST /api/v1/filing/submit</code> with body <code>{return_id: "R123", filing_type: "federal"}</code>. The Filing Service first performs an <strong>idempotency check</strong> ‚Äî it queries the DB to ensure R123 hasn't already been submitted for federal filing (prevents duplicate filings). Finding no prior submission, it writes a <code>filing_records</code> row with <code>status: "queued"</code> and enqueues a filing job on the Message Queue: <code>{filing_id: "F001", return_id: "R123", type: "federal"}</code>. The client receives <code>202 Accepted {filing_id: "F001", status: "queued"}</code>. A Filing Worker picks up the job, generates the IRS-compliant XML (Form 1040 in MeF format), digitally signs it with TurboTax's Electronic Filing Identification Number (EFIN), and transmits it to the IRS MeF system via SOAP/HTTPS. The IRS acknowledges receipt. The worker updates the DB: <code>status: "submitted", irs_submission_id: "IRS-2025-ABC123"</code>. Approximately 24-48 hours later, the IRS sends an acceptance notification. A scheduled polling job picks this up, updates the DB to <code>status: "accepted"</code>, and triggers the Notification Service to send Jane an email: "Your 2025 federal return has been accepted by the IRS."
</div>

<div class="example-card">
<strong>Example 2 ‚Äî IRS Rejection:</strong><br/>
User Tom submits his return. The Filing Worker transmits to the IRS, but 24 hours later, the IRS rejects it with error code <code>IND-031: SSN of primary taxpayer has already been used on a filed return</code>. The polling job updates the DB: <code>status: "rejected", rejection_code: "IND-031", rejection_reason: "SSN already filed"</code>. The Notification Service sends Tom an email and push notification: "Your return was rejected: The SSN has already been used on another return. This may indicate identity theft. Please review and resubmit or contact the IRS." Tom's client shows the rejection with guidance on next steps. After resolving the issue, Tom can resubmit ‚Äî this creates a new filing record (the old one is preserved for audit trail).
</div>

<div class="example-card">
<strong>Example 3 ‚Äî Status Polling by User:</strong><br/>
Three hours after submitting, Jane opens TurboTax to check her filing status. The client sends <code>HTTPS GET /api/v1/filing/F001/status</code>. The Filing Service reads from the DB and returns <code>{filing_id: "F001", status: "submitted", submitted_at: "2025-04-10T14:30:00Z", estimated_response: "24-48 hours"}</code>. The UI shows a progress tracker: Queued ‚úì ‚Üí Submitted ‚úì ‚Üí Accepted (pending).
</div>

<h3>Flow 4 ‚Äî Component Deep Dive</h3>

<h4>Filing Service</h4>
<div class="card">
<table>
  <tr><th>Endpoint</th><th>Method</th><th>Input</th><th>Output</th></tr>
  <tr><td><code>/filing/submit</code></td><td>POST</td><td>Body: <code>{return_id, filing_type: "federal"|"state", state?}</code></td><td><code>202 Accepted {filing_id, status: "queued"}</code></td></tr>
  <tr><td><code>/filing/{id}/status</code></td><td>GET</td><td>Path: <code>filing_id</code></td><td><code>{filing_id, status, submitted_at, irs_submission_id?, rejection_reason?}</code></td></tr>
</table>
<p><strong>Protocol:</strong> HTTPS (REST). POST for submission (creates a filing record). GET for status checks.</p>
<p><strong>Idempotency:</strong> The submit endpoint checks <code>(return_id, filing_type, tax_year)</code> uniqueness. If a filing record already exists with status != "rejected", the endpoint returns <code>409 Conflict</code> to prevent duplicate filings. This is critical ‚Äî accidentally filing the same return twice with the IRS causes major issues.</p>
</div>

<h4>Filing Worker</h4>
<div class="card">
<p>Processes filing jobs from the message queue. Each worker:</p>
<ol>
  <li>Dequeues a filing job</li>
  <li>Reads the complete tax return data from the DB</li>
  <li>Generates IRS-compliant XML per the MeF schema</li>
  <li>Digitally signs the XML with the platform's EFIN credentials</li>
  <li>Transmits to the IRS MeF endpoint via SOAP over HTTPS</li>
  <li>Records the IRS acknowledgment (submission ID) in the DB</li>
  <li>Logs the full transmission details to the Audit Log</li>
</ol>
<p><strong>Why a message queue for filing?</strong> E-filing involves an external system (IRS) with unpredictable latency and rate limits. The queue provides: (1) buffering during the April 15 rush when millions file simultaneously, (2) automatic retry on transient IRS failures, (3) ordering guarantees to prevent out-of-sequence submissions.</p>
<p><strong>Why not WebSockets for status updates?</strong> Filing status changes happen hours or days after submission (IRS response time is 24-48 hours). Maintaining a WebSocket connection for that duration is wasteful. Instead, we use: (1) client-side polling (GET endpoint) for users actively checking, and (2) push notifications (email + mobile push) for async alerts. Polling interval: 30 seconds when the user is on the status page.</p>
</div>

<h4>IRS MeF (External)</h4>
<div class="card">
<p>The IRS Modernized e-File system. TurboTax connects as an <strong>Authorized e-File Provider</strong> using SOAP web services over HTTPS with mutual TLS authentication (client certificate). The IRS provides:</p>
<ul>
  <li><strong>Submission endpoint:</strong> Accepts XML tax returns</li>
  <li><strong>Acknowledgment endpoint:</strong> Returns acceptance/rejection status (polled by our system every 15 minutes)</li>
</ul>
<p>The IRS has <strong>rate limits</strong> (max submissions per minute per EFIN) and <strong>maintenance windows</strong>. Our Filing Workers respect these constraints via the message queue's rate-limiting configuration.</p>
</div>

<h4>Notification Service</h4>
<div class="card">
<p>Sends notifications to users via multiple channels:</p>
<ul>
  <li><strong>Email:</strong> Filing confirmations, acceptance/rejection notices, deadline reminders</li>
  <li><strong>Push (mobile):</strong> Real-time alerts for filing status changes</li>
  <li><strong>In-app:</strong> Badge/banner notifications when the user opens TurboTax</li>
</ul>
<p>The Notification Service is triggered by internal events (filing status change, deadline approaching) via the message queue. It is decoupled from the Filing Worker ‚Äî if notification delivery fails, it doesn't affect the filing process.</p>
</div>

<hr>

<!-- ============================================================ -->
<h2 id="flow5">7. Flow 5 ‚Äî Payment Processing</h2>
<!-- ============================================================ -->

<p>Users pay for their TurboTax service tier. Payment can occur at different points: before filing (pay to unlock features) or at filing time (pay from refund option).</p>

<div class="mermaid">
graph LR
    Client["üñ•Ô∏è Client"]
    LB["‚öñÔ∏è Load Balancer"]
    GW["üö™ API Gateway"]
    PS["üí≥ Payment<br/>Service"]
    PG["üè¶ Payment<br/>Gateway<br/>(External)"]
    DB[("üíæ SQL DB")]
    FS["üì® Filing<br/>Service"]

    Client -- "HTTPS POST<br/>/payments/checkout" --> LB
    LB --> GW
    GW --> PS
    PS -- "Create payment<br/>intent" --> PG
    PG -- "Redirect to<br/>payment form" --> Client
    Client -- "Card details<br/>(direct to gateway)" --> PG
    PG -- "Webhook:<br/>payment result" --> PS
    PS -- "Write payment<br/>record" --> DB
    PS -- "Unlock filing" --> FS

    Client -- "HTTPS POST<br/>/payments/pay-from-refund" --> LB
    LB --> GW
    GW --> PS
    PS -- "Record deferred<br/>payment" --> DB

    style Client fill:#1a73e8,stroke:#1565c0,color:#fff
    style LB fill:#e8710a,stroke:#c75e00,color:#fff
    style GW fill:#7b1fa2,stroke:#6a1b9a,color:#fff
    style PS fill:#00695c,stroke:#004d40,color:#fff
    style PG fill:#1b5e20,stroke:#0d3010,color:#fff
    style DB fill:#283593,stroke:#1a237e,color:#fff
    style FS fill:#6a1b9a,stroke:#4a148c,color:#fff
</div>

<h3>Flow 5 ‚Äî Examples</h3>

<div class="example-card">
<strong>Example 1 ‚Äî Credit Card Payment:</strong><br/>
User Jane selects the "Deluxe" tier ($89). The client sends <code>HTTPS POST /api/v1/payments/checkout</code> with body <code>{return_id: "R123", tier: "deluxe", amount: 89.00, currency: "USD"}</code>. The Payment Service creates a payment intent with the external Payment Gateway, which returns a client secret. The client renders the Payment Gateway's hosted payment form (card details go directly to the gateway ‚Äî TurboTax never sees raw card numbers, maintaining PCI DSS compliance). Jane enters her card. The gateway processes the charge and sends a webhook to the Payment Service: <code>{event: "payment_succeeded", payment_intent_id: "pi_123", amount: 89.00}</code>. The Payment Service writes a payment record to the DB (<code>status: "completed"</code>) and notifies the Filing Service that R123 is now authorized for e-filing.
</div>

<div class="example-card">
<strong>Example 2 ‚Äî Pay From Refund:</strong><br/>
User Tom chooses "Pay from my refund" (TurboTax deducts its fee from his tax refund via a temporary bank account). The client sends <code>HTTPS POST /api/v1/payments/pay-from-refund</code> with <code>{return_id: "R456", tier: "premier", amount: 139.00}</code>. The Payment Service records a deferred payment in the DB (<code>status: "deferred", method: "refund_deduction"</code>). During e-filing, the Filing Worker includes routing information for a temporary bank account (managed by a partner bank) as the refund destination. When the IRS deposits the refund, the partner bank deducts $139 and forwards the remainder to Tom's actual bank account.
</div>

<div class="example-card">
<strong>Example 3 ‚Äî Payment Failure:</strong><br/>
User Maria's card is declined. The Payment Gateway webhook sends <code>{event: "payment_failed", reason: "insufficient_funds"}</code>. The Payment Service writes <code>status: "failed"</code> to the DB and returns the error to the client. The UI prompts Maria to try a different payment method. Filing remains locked until payment succeeds.
</div>

<h3>Flow 5 ‚Äî Component Deep Dive</h3>

<h4>Payment Service</h4>
<div class="card">
<table>
  <tr><th>Endpoint</th><th>Method</th><th>Input</th><th>Output</th></tr>
  <tr><td><code>/payments/checkout</code></td><td>POST</td><td>Body: <code>{return_id, tier, amount, currency}</code></td><td><code>{payment_id, client_secret, gateway_url}</code></td></tr>
  <tr><td><code>/payments/pay-from-refund</code></td><td>POST</td><td>Body: <code>{return_id, tier, amount}</code></td><td><code>{payment_id, status: "deferred"}</code></td></tr>
  <tr><td><code>/payments/webhook</code></td><td>POST</td><td>Body: Gateway webhook payload</td><td><code>200 OK</code></td></tr>
  <tr><td><code>/payments/{id}</code></td><td>GET</td><td>Path: <code>payment_id</code></td><td><code>{payment_id, status, amount, method}</code></td></tr>
</table>
<p><strong>Protocol:</strong> HTTPS (REST). The webhook endpoint receives POST callbacks from the Payment Gateway.</p>
<p><strong>PCI DSS Compliance:</strong> The Payment Service never handles raw card numbers. Card details are submitted directly from the client to the Payment Gateway's hosted form (iframe or redirect). The Payment Service only handles tokenized references (payment intent IDs).</p>
</div>

<hr>

<!-- ============================================================ -->
<h2 id="combined">8. Combined Overall Diagram</h2>
<!-- ============================================================ -->

<p>This diagram combines all five flows into a single unified architecture view.</p>

<div class="mermaid">
graph TB
    Client["üñ•Ô∏è Client<br/>(Web / Mobile)"]
    CDN["üåê CDN<br/>(Static Assets)"]
    LB["‚öñÔ∏è Load Balancer"]
    GW["üö™ API Gateway<br/>(Auth + Rate Limit + Routing)"]

    subgraph Services ["Microservices"]
        IS["üìù Interview<br/>Service"]
        DS["üìÑ Document<br/>Service"]
        CS["üßÆ Calculation<br/>Service"]
        VS["‚úÖ Validation<br/>Service"]
        FS["üì® Filing<br/>Service"]
        PS["üí≥ Payment<br/>Service"]
        NS["üîî Notification<br/>Service"]
    end

    subgraph AsyncWorkers ["Async Worker Pools"]
        OCR["üîç OCR<br/>Workers"]
        FW["üèõÔ∏è Filing<br/>Workers"]
    end

    QE["üß† Question<br/>Engine"]
    MQ_OCR["üì¨ Message Queue<br/>(OCR Jobs)"]
    MQ_FILING["üì¨ Message Queue<br/>(Filing Jobs)"]
    MQ_NOTIF["üì¨ Message Queue<br/>(Notifications)"]

    Cache["‚ö° Cache Layer<br/>(Tax Rules, Questions,<br/>Session Progress)"]
    DB[("üíæ SQL DB<br/>(Primary)")]
    DB_Read[("üíæ SQL DB<br/>(Read Replicas)")]
    ObjStore[("üì¶ Object<br/>Storage")]
    AuditLog[("üìú Immutable<br/>Audit Log")]

    IRS["üá∫üá∏ IRS MeF"]
    PG["üè¶ Payment<br/>Gateway"]
    EmployerAPI["üè¢ Employer<br/>APIs"]

    Client -- "Static assets" --> CDN
    Client -- "API requests<br/>(HTTPS)" --> LB
    LB --> GW

    GW --> IS
    GW --> DS
    GW --> CS
    GW --> VS
    GW --> FS
    GW --> PS

    IS --> QE
    IS --> Cache
    IS --> DB

    DS --> ObjStore
    DS --> MQ_OCR
    DS --> DB
    DS --> EmployerAPI

    MQ_OCR --> OCR
    OCR --> ObjStore
    OCR --> DB

    CS --> Cache
    CS --> DB_Read
    CS --> DB
    CS --> AuditLog

    VS --> Cache
    VS --> DB_Read

    FS --> DB
    FS --> MQ_FILING
    MQ_FILING --> FW
    FW --> IRS
    FW --> DB
    FW --> AuditLog
    FW --> MQ_NOTIF

    MQ_NOTIF --> NS
    NS --> Client

    PS --> PG
    PS --> DB

    DB -- "Replication" --> DB_Read

    style Client fill:#1a73e8,stroke:#1565c0,color:#fff
    style CDN fill:#00897b,stroke:#00695c,color:#fff
    style LB fill:#e8710a,stroke:#c75e00,color:#fff
    style GW fill:#7b1fa2,stroke:#6a1b9a,color:#fff
    style IS fill:#2e7d32,stroke:#1b5e20,color:#fff
    style DS fill:#00695c,stroke:#004d40,color:#fff
    style CS fill:#00838f,stroke:#006064,color:#fff
    style VS fill:#558b2f,stroke:#33691e,color:#fff
    style FS fill:#6a1b9a,stroke:#4a148c,color:#fff
    style PS fill:#00695c,stroke:#004d40,color:#fff
    style NS fill:#f9a825,stroke:#f57f17,color:#000
    style QE fill:#c62828,stroke:#b71c1c,color:#fff
    style OCR fill:#c62828,stroke:#b71c1c,color:#fff
    style FW fill:#bf360c,stroke:#8d1c00,color:#fff
    style MQ_OCR fill:#ad1457,stroke:#880e4f,color:#fff
    style MQ_FILING fill:#ad1457,stroke:#880e4f,color:#fff
    style MQ_NOTIF fill:#ad1457,stroke:#880e4f,color:#fff
    style Cache fill:#ef6c00,stroke:#e65100,color:#fff
    style DB fill:#283593,stroke:#1a237e,color:#fff
    style DB_Read fill:#283593,stroke:#1a237e,color:#fff
    style ObjStore fill:#4e342e,stroke:#3e2723,color:#fff
    style AuditLog fill:#4e342e,stroke:#3e2723,color:#fff
    style IRS fill:#1b5e20,stroke:#0d3010,color:#fff
    style PG fill:#1b5e20,stroke:#0d3010,color:#fff
    style EmployerAPI fill:#1b5e20,stroke:#0d3010,color:#fff
</div>

<h3>Combined Diagram ‚Äî End-to-End Examples</h3>

<div class="example-card">
<strong>Example ‚Äî Complete User Journey (Happy Path):</strong><br/>
<strong>1)</strong> Jane visits turbotax.com. The CDN serves the static HTML/JS/CSS bundle. She logs in ‚Äî the client sends <code>POST /auth/login</code> through the Load Balancer ‚Üí API Gateway, which issues a JWT.<br/>
<strong>2)</strong> Jane starts a new return. The client calls <code>GET /interview/next-question</code>. The API Gateway validates her JWT and routes to the Interview Service, which consults the Question Engine and Cache to determine the first question. Jane progresses through Personal Info, answering questions. Each answer auto-saves via <code>PATCH /interview/answers</code> ‚Üí Interview Service ‚Üí SQL DB.<br/>
<strong>3)</strong> In the Income section, Jane uploads her W-2 photo via <code>POST /documents/upload</code> ‚Üí Document Service ‚Üí Object Storage + Message Queue. An OCR Worker extracts her wage data and pre-fills the income questions. Jane sees the fields auto-populated when she continues.<br/>
<strong>4)</strong> Jane completes all sections. The client triggers <code>POST /tax/calculate</code> ‚Üí Calculation Service reads her answers from the DB (via read replica), fetches tax rules from Cache, computes her $6,959 refund, writes the result to DB and Audit Log.<br/>
<strong>5)</strong> Jane clicks "Review &amp; File." The client calls <code>POST /tax/validate</code> ‚Üí Validation Service checks for errors (none found). Jane then pays $89 via <code>POST /payments/checkout</code> ‚Üí Payment Service ‚Üí Payment Gateway. After payment succeeds (webhook callback), the Payment Service unlocks filing.<br/>
<strong>6)</strong> Jane clicks "File My Return." <code>POST /filing/submit</code> ‚Üí Filing Service writes the filing record and enqueues the job. A Filing Worker generates IRS XML, transmits to IRS MeF, gets an ACK, updates the DB. 24 hours later, the IRS accepts the return. The Filing Worker (via scheduled polling) updates status and enqueues a notification. The Notification Service sends Jane an email: "Your return was accepted! Estimated refund: $6,959."
</div>

<div class="example-card">
<strong>Example ‚Äî Returning User (Resume Session):</strong><br/>
Tom started his return last week and stopped mid-way through Deductions. Today he opens TurboTax. The client sends <code>GET /interview/resume?return_id=R456</code>. The Interview Service reads Tom's progress from the SQL DB: last section = "deductions", last question = Q42, 62% complete. It returns the full state, and the UI drops Tom right where he left off with all prior answers pre-populated. Tom also had a W-2 upload that was still processing when he left ‚Äî the <code>documents</code> table now shows <code>status: "completed"</code>, so his income section is fully filled in from OCR.
</div>

<hr>

<!-- ============================================================ -->
<h2 id="schema">9. Database Schema</h2>
<!-- ============================================================ -->

<h3>SQL Tables</h3>
<p>SQL is used for all core transactional data because tax preparation demands <strong>ACID compliance</strong> (no partial saves), <strong>strong consistency</strong> (tax calculations must always see the latest data), and <strong>complex joins</strong> (calculations join across users, returns, and answers).</p>

<h4>Table: <code>users</code></h4>
<div class="card">
<table>
  <tr><th>Column</th><th>Type</th><th>Key</th><th>Description</th></tr>
  <tr><td><code>user_id</code></td><td>UUID</td><td><span class="tag tag-pk">PK</span></td><td>Unique user identifier</td></tr>
  <tr><td><code>email</code></td><td>VARCHAR(255)</td><td><span class="tag tag-idx">UNIQUE INDEX</span></td><td>Login email (encrypted at rest)</td></tr>
  <tr><td><code>password_hash</code></td><td>VARCHAR(255)</td><td></td><td>bcrypt/argon2 hashed password</td></tr>
  <tr><td><code>full_name</code></td><td>VARCHAR(255)</td><td></td><td>Encrypted at rest</td></tr>
  <tr><td><code>ssn_encrypted</code></td><td>VARBINARY</td><td></td><td>AES-256 encrypted SSN</td></tr>
  <tr><td><code>phone</code></td><td>VARCHAR(20)</td><td></td><td>For MFA</td></tr>
  <tr><td><code>mfa_secret</code></td><td>VARCHAR(255)</td><td></td><td>TOTP secret (encrypted)</td></tr>
  <tr><td><code>created_at</code></td><td>TIMESTAMP</td><td></td><td></td></tr>
  <tr><td><code>updated_at</code></td><td>TIMESTAMP</td><td></td><td></td></tr>
</table>
<p><strong>Why SQL:</strong> User records are updated transactionally (profile updates, password changes) and joined with tax_returns. Strong consistency is needed ‚Äî a user must not be able to create duplicate accounts.</p>
<p><strong>Index:</strong> <span class="tag tag-idx">Hash index</span> on <code>email</code> for O(1) login lookups. Email is the primary lookup key for authentication.</p>
<p><strong>Read:</strong> On every login, on every API request (JWT validation may trigger a user lookup).</p>
<p><strong>Write:</strong> On registration, profile update, password change.</p>
<p><strong>Sharding:</strong> Shard by <code>user_id</code> (hash-based). Users are independent ‚Äî no cross-user queries needed for normal operations. Hashing distributes users evenly across shards.</p>
</div>

<h4>Table: <code>tax_returns</code></h4>
<div class="card">
<table>
  <tr><th>Column</th><th>Type</th><th>Key</th><th>Description</th></tr>
  <tr><td><code>return_id</code></td><td>UUID</td><td><span class="tag tag-pk">PK</span></td><td>Unique return identifier</td></tr>
  <tr><td><code>user_id</code></td><td>UUID</td><td><span class="tag tag-fk">FK ‚Üí users</span></td><td>Owner of this return</td></tr>
  <tr><td><code>tax_year</code></td><td>SMALLINT</td><td></td><td>e.g., 2025</td></tr>
  <tr><td><code>filing_status</code></td><td>ENUM</td><td></td><td>single, married_joint, married_separate, head_of_household, widow</td></tr>
  <tr><td><code>status</code></td><td>ENUM</td><td></td><td>in_progress, ready_to_file, filed, accepted, rejected, amended</td></tr>
  <tr><td><code>current_section</code></td><td>VARCHAR(50)</td><td></td><td>Last section visited (for resume)</td></tr>
  <tr><td><code>current_question_id</code></td><td>VARCHAR(50)</td><td></td><td>Last question visited (for resume)</td></tr>
  <tr><td><code>completion_pct</code></td><td>DECIMAL(5,2)</td><td></td><td>Interview completion percentage</td></tr>
  <tr><td><code>federal_refund_or_owed</code></td><td>DECIMAL(12,2)</td><td></td><td>Positive = refund, negative = owed</td></tr>
  <tr><td><code>state</code></td><td>VARCHAR(2)</td><td></td><td>State abbreviation (e.g., "CA")</td></tr>
  <tr><td><code>state_refund_or_owed</code></td><td>DECIMAL(12,2)</td><td></td><td></td></tr>
  <tr><td><code>tier</code></td><td>ENUM</td><td></td><td>free, deluxe, premier, self_employed</td></tr>
  <tr><td><code>created_at</code></td><td>TIMESTAMP</td><td></td><td></td></tr>
  <tr><td><code>updated_at</code></td><td>TIMESTAMP</td><td></td><td></td></tr>
</table>
<p><strong>Why SQL:</strong> Returns are updated transactionally (status changes, calculation results). They have foreign-key relationships to users and are joined with answers for calculations.</p>
<p><strong>Index:</strong> <span class="tag tag-idx">B-tree index</span> on <code>(user_id, tax_year)</code> ‚Äî the most common query is "get all returns for this user" or "get the 2025 return for this user." B-tree supports both equality and range lookups efficiently.</p>
<p><strong>Denormalization Note:</strong> <code>current_section</code>, <code>current_question_id</code>, and <code>completion_pct</code> are denormalized here (they could be derived from the interview_answers table). This is done because these fields are read on every resume/load and computing them from interview_answers would require scanning all answers and evaluating the question tree ‚Äî an expensive operation that would happen on every page load. The tradeoff is that the Interview Service must update these fields on every answer save, but a single UPDATE is much cheaper than the alternative computation.</p>
<p><strong>Read:</strong> On every interview question load, tax calculation, filing submission, and resume.</p>
<p><strong>Write:</strong> On return creation, every answer save (updates progress fields), calculation completion, filing status change.</p>
<p><strong>Sharding:</strong> Shard by <code>user_id</code> (consistent hashing). This co-locates a user's returns with their user record on the same shard, enabling efficient joins. A user typically has 1-5 returns (one per year), so no hot-shard risk.</p>
</div>

<h4>Table: <code>interview_answers</code></h4>
<div class="card">
<table>
  <tr><th>Column</th><th>Type</th><th>Key</th><th>Description</th></tr>
  <tr><td><code>answer_id</code></td><td>UUID</td><td><span class="tag tag-pk">PK</span></td><td>Unique answer record</td></tr>
  <tr><td><code>return_id</code></td><td>UUID</td><td><span class="tag tag-fk">FK ‚Üí tax_returns</span></td><td>Which return this answer belongs to</td></tr>
  <tr><td><code>section_id</code></td><td>VARCHAR(50)</td><td></td><td>e.g., "personal_info", "income", "deductions"</td></tr>
  <tr><td><code>question_id</code></td><td>VARCHAR(50)</td><td></td><td>Question identifier</td></tr>
  <tr><td><code>answer_value</code></td><td>VARBINARY</td><td></td><td>AES-256 encrypted answer (may contain SSN, income, etc.)</td></tr>
  <tr><td><code>source</code></td><td>ENUM</td><td></td><td>manual, ocr, import (how the data was entered)</td></tr>
  <tr><td><code>confidence</code></td><td>DECIMAL(3,2)</td><td></td><td>OCR confidence score (NULL if manual)</td></tr>
  <tr><td><code>created_at</code></td><td>TIMESTAMP</td><td></td><td></td></tr>
  <tr><td><code>updated_at</code></td><td>TIMESTAMP</td><td></td><td></td></tr>
</table>
<p><strong>Why SQL:</strong> Answers must be written atomically (batch auto-save), and they are heavily joined with tax_returns during calculation. Strong consistency ensures the Calculation Service always sees the latest answers.</p>
<p><strong>Index:</strong> <span class="tag tag-idx">B-tree composite index</span> on <code>(return_id, section_id)</code> ‚Äî the Interview Service loads all answers for a section at once, and the Calculation Service loads all answers for a return. B-tree supports prefix queries (all answers for a return_id) and more specific queries (answers for a return_id + section_id).</p>
<p><strong>Unique Constraint:</strong> <code>(return_id, question_id)</code> ‚Äî each question can only have one answer per return (upsert semantics).</p>
<p><strong>Read:</strong> On every next-question request (to evaluate branching logic), on resume, on tax calculation.</p>
<p><strong>Write:</strong> On every auto-save PATCH, on OCR data extraction, on data import.</p>
<p><strong>Sharding:</strong> Shard by <code>return_id</code> (consistent hashing). All answers for a return are co-located on the same shard, which is critical since tax calculation reads all answers for a return in a single query. Average 100-300 answers per return, so shard sizes are balanced.</p>
</div>

<h4>Table: <code>documents</code></h4>
<div class="card">
<table>
  <tr><th>Column</th><th>Type</th><th>Key</th><th>Description</th></tr>
  <tr><td><code>document_id</code></td><td>UUID</td><td><span class="tag tag-pk">PK</span></td><td>Unique document identifier</td></tr>
  <tr><td><code>return_id</code></td><td>UUID</td><td><span class="tag tag-fk">FK ‚Üí tax_returns</span></td><td>Which return this document belongs to</td></tr>
  <tr><td><code>document_type</code></td><td>ENUM</td><td></td><td>W2, 1099_INT, 1099_NEC, 1099_B, 1098, etc.</td></tr>
  <tr><td><code>storage_key</code></td><td>VARCHAR(512)</td><td></td><td>Path in Object Storage</td></tr>
  <tr><td><code>ocr_status</code></td><td>ENUM</td><td></td><td>pending, processing, completed, needs_review, failed</td></tr>
  <tr><td><code>extracted_data</code></td><td>JSONB (encrypted)</td><td></td><td>OCR-extracted key-value pairs</td></tr>
  <tr><td><code>file_size_bytes</code></td><td>BIGINT</td><td></td><td></td></tr>
  <tr><td><code>mime_type</code></td><td>VARCHAR(50)</td><td></td><td>application/pdf, image/jpeg, etc.</td></tr>
  <tr><td><code>created_at</code></td><td>TIMESTAMP</td><td></td><td></td></tr>
</table>
<p><strong>Why SQL:</strong> Documents are relationally tied to tax_returns and their OCR status is updated transactionally (pending ‚Üí processing ‚Üí completed). The extracted_data JSONB field stores semi-structured OCR results within the relational model.</p>
<p><strong>Index:</strong> <span class="tag tag-idx">B-tree index</span> on <code>(return_id)</code> ‚Äî load all documents for a return. Also <span class="tag tag-idx">B-tree index</span> on <code>(ocr_status)</code> ‚Äî the OCR Worker pool queries for pending documents during retries.</p>
<p><strong>Read:</strong> When client polls document status, when Interview Service checks for OCR-extracted data.</p>
<p><strong>Write:</strong> On document upload, OCR status update, OCR data extraction.</p>
</div>

<h4>Table: <code>filing_records</code></h4>
<div class="card">
<table>
  <tr><th>Column</th><th>Type</th><th>Key</th><th>Description</th></tr>
  <tr><td><code>filing_id</code></td><td>UUID</td><td><span class="tag tag-pk">PK</span></td><td>Unique filing record</td></tr>
  <tr><td><code>return_id</code></td><td>UUID</td><td><span class="tag tag-fk">FK ‚Üí tax_returns</span></td><td></td></tr>
  <tr><td><code>filing_type</code></td><td>ENUM</td><td></td><td>federal, state</td></tr>
  <tr><td><code>status</code></td><td>ENUM</td><td></td><td>queued, submitted, accepted, rejected</td></tr>
  <tr><td><code>irs_submission_id</code></td><td>VARCHAR(100)</td><td></td><td>ID returned by IRS on submission</td></tr>
  <tr><td><code>rejection_code</code></td><td>VARCHAR(50)</td><td></td><td>IRS rejection error code (if rejected)</td></tr>
  <tr><td><code>rejection_reason</code></td><td>TEXT</td><td></td><td>Human-readable rejection message</td></tr>
  <tr><td><code>xml_storage_key</code></td><td>VARCHAR(512)</td><td></td><td>Path to the filed XML in Object Storage</td></tr>
  <tr><td><code>submitted_at</code></td><td>TIMESTAMP</td><td></td><td></td></tr>
  <tr><td><code>responded_at</code></td><td>TIMESTAMP</td><td></td><td>When IRS accepted/rejected</td></tr>
  <tr><td><code>created_at</code></td><td>TIMESTAMP</td><td></td><td></td></tr>
</table>
<p><strong>Why SQL:</strong> Filing records must have ACID guarantees ‚Äî the idempotency check (prevent duplicate filings) requires a consistent, unique constraint. Filing records are also auditable and must be reliably stored.</p>
<p><strong>Unique Constraint:</strong> <code>(return_id, filing_type, tax_year)</code> ‚Äî enforced at the DB level to prevent duplicate filings even under race conditions.</p>
<p><strong>Index:</strong> <span class="tag tag-idx">B-tree index</span> on <code>(return_id)</code> for looking up filing status. <span class="tag tag-idx">B-tree index</span> on <code>(status)</code> for the IRS polling job that queries all <code>status = "submitted"</code> records to check for responses.</p>
<p><strong>Read:</strong> On user status check, by the IRS polling job.</p>
<p><strong>Write:</strong> On filing submission, on IRS response (status update).</p>
</div>

<h4>Table: <code>payments</code></h4>
<div class="card">
<table>
  <tr><th>Column</th><th>Type</th><th>Key</th><th>Description</th></tr>
  <tr><td><code>payment_id</code></td><td>UUID</td><td><span class="tag tag-pk">PK</span></td><td>Unique payment record</td></tr>
  <tr><td><code>user_id</code></td><td>UUID</td><td><span class="tag tag-fk">FK ‚Üí users</span></td><td></td></tr>
  <tr><td><code>return_id</code></td><td>UUID</td><td><span class="tag tag-fk">FK ‚Üí tax_returns</span></td><td></td></tr>
  <tr><td><code>amount</code></td><td>DECIMAL(10,2)</td><td></td><td></td></tr>
  <tr><td><code>currency</code></td><td>VARCHAR(3)</td><td></td><td>"USD"</td></tr>
  <tr><td><code>method</code></td><td>ENUM</td><td></td><td>credit_card, debit_card, refund_deduction</td></tr>
  <tr><td><code>status</code></td><td>ENUM</td><td></td><td>pending, completed, failed, deferred, refunded</td></tr>
  <tr><td><code>gateway_transaction_id</code></td><td>VARCHAR(255)</td><td></td><td>External payment gateway reference</td></tr>
  <tr><td><code>created_at</code></td><td>TIMESTAMP</td><td></td><td></td></tr>
  <tr><td><code>updated_at</code></td><td>TIMESTAMP</td><td></td><td></td></tr>
</table>
<p><strong>Why SQL:</strong> Financial transactions require ACID guarantees. Payment records must be consistent and durable. Also joined with user and return records for business reporting.</p>
<p><strong>Index:</strong> <span class="tag tag-idx">B-tree index</span> on <code>(return_id)</code> ‚Äî check if a return has been paid for before allowing filing.</p>
<p><strong>Read:</strong> On filing attempt (verify payment), on user's payment history.</p>
<p><strong>Write:</strong> On checkout initiation, on payment gateway webhook callback.</p>
</div>

<h3>NoSQL Tables (Document Database)</h3>

<h4>Collection: <code>question_definitions</code></h4>
<div class="card">
<table>
  <tr><th>Field</th><th>Type</th><th>Key</th><th>Description</th></tr>
  <tr><td><code>question_id</code></td><td>String</td><td><span class="tag tag-pk">PK</span></td><td>e.g., "Q30"</td></tr>
  <tr><td><code>tax_year</code></td><td>Number</td><td><span class="tag tag-pk">Sort Key</span></td><td>e.g., 2025</td></tr>
  <tr><td><code>section</code></td><td>String</td><td></td><td>"income", "deductions", etc.</td></tr>
  <tr><td><code>question_text</code></td><td>String</td><td></td><td>The question displayed to the user</td></tr>
  <tr><td><code>answer_type</code></td><td>String</td><td></td><td>"boolean", "currency", "text", "select", "multi_select"</td></tr>
  <tr><td><code>options</code></td><td>Array</td><td></td><td>Dropdown/radio options if applicable</td></tr>
  <tr><td><code>validation_rules</code></td><td>Object</td><td></td><td>e.g., <code>{min: 0, max: 999999, required: true}</code></td></tr>
  <tr><td><code>conditional_logic</code></td><td>Object (nested)</td><td></td><td>Complex branching rules ‚Äî deeply nested JSON</td></tr>
  <tr><td><code>help_text</code></td><td>String</td><td></td><td>Explanatory tooltip text</td></tr>
  <tr><td><code>irs_form_mapping</code></td><td>Object</td><td></td><td>Maps this question to IRS form fields (e.g., Form 1040 Line 1)</td></tr>
</table>
<p><strong>Why NoSQL (Document DB):</strong> Question definitions have deeply nested, variable-structure conditional logic that doesn't fit well into relational columns. Different questions have wildly different shapes (a boolean question has no options; a multi-select question has a complex options array with sub-conditions). A document database stores these naturally as JSON documents without schema migrations when the product team adds new question types. Additionally, questions are <strong>read-only at runtime</strong> (no ACID transactions needed) and are always accessed by primary key (question_id + tax_year), making them a perfect fit for a document store.</p>
<p><strong>Read:</strong> On every interview question load (via Cache ‚Äî DB is fallback).</p>
<p><strong>Write:</strong> Only during tax-season preparation by the product/engineering team (offline updates). Write volume is negligible.</p>
</div>

<h4>Collection: <code>tax_rules</code></h4>
<div class="card">
<table>
  <tr><th>Field</th><th>Type</th><th>Key</th><th>Description</th></tr>
  <tr><td><code>rule_id</code></td><td>String</td><td><span class="tag tag-pk">PK</span></td><td>e.g., "federal_brackets_2025"</td></tr>
  <tr><td><code>tax_year</code></td><td>Number</td><td><span class="tag tag-pk">Sort Key</span></td><td></td></tr>
  <tr><td><code>rule_type</code></td><td>String</td><td></td><td>"bracket", "credit", "deduction", "limit"</td></tr>
  <tr><td><code>applicable_filing_statuses</code></td><td>Array</td><td></td><td>Which filing statuses this rule applies to</td></tr>
  <tr><td><code>conditions</code></td><td>Object</td><td></td><td>When this rule applies</td></tr>
  <tr><td><code>formula</code></td><td>Object</td><td></td><td>The computation formula (brackets, rates, phase-outs)</td></tr>
  <tr><td><code>irs_reference</code></td><td>String</td><td></td><td>IRS publication/section reference</td></tr>
</table>
<p><strong>Why NoSQL (Document DB):</strong> Tax rules have highly variable structures ‚Äî a bracket rule has an array of rate tiers, a credit rule has phase-out logic with income thresholds, a deduction rule has caps and floors. These nested, polymorphic structures are cumbersome in SQL but natural in a document model. Tax rules are also <strong>read-only at runtime</strong> and versioned per tax year.</p>
<p><strong>Read:</strong> On every tax calculation (via Cache ‚Äî DB is fallback).</p>
<p><strong>Write:</strong> Once per year when new tax laws are encoded. Negligible write volume.</p>
</div>

<h4>Collection: <code>audit_log_entries</code></h4>
<div class="card">
<table>
  <tr><th>Field</th><th>Type</th><th>Key</th><th>Description</th></tr>
  <tr><td><code>log_id</code></td><td>UUID</td><td><span class="tag tag-pk">PK</span></td><td></td></tr>
  <tr><td><code>timestamp</code></td><td>ISO 8601</td><td><span class="tag tag-pk">Sort Key</span></td><td></td></tr>
  <tr><td><code>event_type</code></td><td>String</td><td></td><td>"calculation", "filing_submission", "filing_response", "login"</td></tr>
  <tr><td><code>user_id</code></td><td>String</td><td></td><td></td></tr>
  <tr><td><code>return_id</code></td><td>String</td><td></td><td></td></tr>
  <tr><td><code>details</code></td><td>Object</td><td></td><td>Full snapshot of inputs/outputs</td></tr>
</table>
<p><strong>Why NoSQL (Append-Only / Time-Series):</strong> Audit logs are write-once, never updated, never deleted (immutable). They are written at high volume during tax season but rarely read (only during audits or investigations). An append-only NoSQL store or time-series database is optimized for this access pattern ‚Äî high write throughput, efficient time-range queries, and natural partitioning by time.</p>
<p><strong>Read:</strong> Rarely ‚Äî only during IRS audits, internal investigations, or compliance reviews. Queries are by <code>(user_id + time_range)</code> or <code>(return_id + event_type)</code>.</p>
<p><strong>Write:</strong> On every calculation, every filing submission, every filing response, every login. High write volume during tax season.</p>
</div>

<hr>

<!-- ============================================================ -->
<h2 id="caching">10. CDN &amp; Caching Strategy</h2>
<!-- ============================================================ -->

<h3>CDN (Content Delivery Network)</h3>
<div class="card">
<p><strong>Appropriate: Yes.</strong> TurboTax's client-side assets ‚Äî JavaScript bundles, CSS, images, fonts, and even question-text templates ‚Äî are served to millions of users and change infrequently (per deployment). A CDN dramatically reduces latency and load on origin servers.</p>
<ul>
  <li><strong>What's cached:</strong> Static SPA bundles (JS/CSS), images/icons, fonts, help-text content, IRS form templates (PDFs), error-message strings</li>
  <li><strong>What's NOT cached:</strong> Any API responses containing PII or user-specific data. These must always hit the origin.</li>
  <li><strong>Cache invalidation:</strong> Versioned file names (content-hashing, e.g., <code>app.a3f8b2c.js</code>). New deployments produce new filenames, so no explicit cache purging is needed.</li>
  <li><strong>Edge locations:</strong> US-only (since TurboTax serves US taxpayers and data residency requires US hosting).</li>
  <li><strong>TTL:</strong> Long (365 days for hashed assets; 1 hour for index.html).</li>
</ul>
</div>

<h3>In-Memory Cache</h3>
<div class="card">
<p><strong>Appropriate: Yes.</strong> Several data sets are extremely read-heavy and write-rare, making them ideal for caching.</p>

<h4>Cache 1: Tax Rules &amp; Question Definitions</h4>
<table>
  <tr><th>Property</th><th>Value</th></tr>
  <tr><td><strong>What's cached</strong></td><td>Tax rules (brackets, credits, deductions) and question definitions for the current tax year</td></tr>
  <tr><td><strong>Caching strategy</strong></td><td><strong>Read-through cache.</strong> On cache miss, the service reads from the document DB, stores the result in cache, and returns it. This is chosen because the data is read-heavy (every question transition and every calculation reads rules) and write-rare (updated once per year by the product team).</td></tr>
  <tr><td><strong>Population trigger</strong></td><td>Populated on first access (cold start) and via a warm-up job that pre-loads the current tax year's rules into all cache nodes at service startup. Also populated on cache miss.</td></tr>
  <tr><td><strong>Eviction policy</strong></td><td><strong>LRU (Least Recently Used).</strong> If memory fills up, evict least-accessed rules first. In practice, eviction rarely occurs because the dataset (all rules for one tax year) fits comfortably in memory (~50 MB).</td></tr>
  <tr><td><strong>Expiration (TTL)</strong></td><td><strong>24 hours.</strong> This provides a safety net: if a rule is updated (e.g., IRS issues a correction mid-season), all caches will pick up the change within 24 hours. For emergency corrections, a manual cache-flush API exists.</td></tr>
  <tr><td><strong>Why read-through?</strong></td><td>Write-through or write-behind caches are unnecessary because writes happen so rarely (a few times per year by the engineering team). Read-through minimizes complexity.</td></tr>
</table>

<h4>Cache 2: Session Progress (Hot Data)</h4>
<table>
  <tr><th>Property</th><th>Value</th></tr>
  <tr><td><strong>What's cached</strong></td><td>Active user session data: current section, current question, completion %, last-active timestamp</td></tr>
  <tr><td><strong>Caching strategy</strong></td><td><strong>Write-through cache.</strong> Every auto-save writes to both the cache and the DB simultaneously. This ensures the cache always has the latest data for instant resume, while the DB provides durability.</td></tr>
  <tr><td><strong>Population trigger</strong></td><td>Populated when a user starts or resumes an interview session. Updated on every auto-save.</td></tr>
  <tr><td><strong>Eviction policy</strong></td><td><strong>LRU.</strong> During tax season, millions of users have active sessions. LRU evicts sessions that haven't been accessed recently (users who left and haven't returned). Those sessions still exist in the DB and will be re-cached on their next visit.</td></tr>
  <tr><td><strong>Expiration (TTL)</strong></td><td><strong>2 hours.</strong> If a user is idle for 2+ hours, their session data evicts from cache. This prevents stale memory usage. On their next visit, the data is loaded from DB and re-cached.</td></tr>
  <tr><td><strong>Why write-through?</strong></td><td>Session progress is written frequently (every auto-save, every 10 seconds of activity) and read frequently (every page load reads current progress). Write-through ensures the cache is always consistent with the DB without requiring a separate invalidation mechanism.</td></tr>
</table>
</div>

<hr>

<!-- ============================================================ -->
<h2 id="scaling">11. Scaling Considerations</h2>
<!-- ============================================================ -->

<div class="card">
<p>TurboTax has one of the most extreme <strong>seasonal scaling challenges</strong> in the industry. Usage follows this approximate pattern:</p>
<ul>
  <li><strong>May ‚Äì December:</strong> Near-zero traffic (a few users amending prior returns)</li>
  <li><strong>January:</strong> Ramp up as W-2s are issued. ~5% of annual traffic.</li>
  <li><strong>February ‚Äì March:</strong> Steady growth. ~30% of annual traffic.</li>
  <li><strong>April 1-14:</strong> Heavy load. ~35% of annual traffic.</li>
  <li><strong>April 15 (Tax Day):</strong> Massive spike. ~30% of annual traffic concentrated in a single day. Peak QPS can be 100x the February average.</li>
</ul>
</div>

<h3>Load Balancers</h3>
<div class="card">
<p>Load balancers are placed at two levels:</p>
<h4>Layer 1: External Load Balancer (Client ‚Üí API Gateway)</h4>
<ul>
  <li><strong>Position:</strong> Between the client and the API Gateway</li>
  <li><strong>Type:</strong> Layer-7 (HTTP-aware) load balancer with TLS termination</li>
  <li><strong>Algorithm:</strong> <strong>Least connections</strong> ‚Äî routes new requests to the API Gateway instance with the fewest active connections. This is better than round-robin for TurboTax because request durations vary widely (a quick GET vs. a heavy POST with file upload).</li>
  <li><strong>Health checks:</strong> HTTP health checks every 5 seconds. Unhealthy instances are removed from the pool within 15 seconds.</li>
  <li><strong>Auto-scaling trigger:</strong> CPU utilization > 60% or connection count > threshold ‚Üí spin up more API Gateway instances.</li>
  <li><strong>DDoS protection:</strong> Rate limiting and connection limits at this layer.</li>
</ul>

<h4>Layer 2: Internal Load Balancers (API Gateway ‚Üí Each Microservice)</h4>
<ul>
  <li><strong>Position:</strong> Between the API Gateway and each microservice (Interview Service, Calculation Service, Document Service, Filing Service, Payment Service)</li>
  <li><strong>Type:</strong> Layer-4 or Layer-7 internal load balancers (or service mesh sidecar proxies)</li>
  <li><strong>Algorithm:</strong> <strong>Round-robin</strong> for stateless services (Interview, Calculation, Validation). All instances are equivalent.</li>
  <li><strong>Health checks:</strong> gRPC or HTTP health endpoints on each service instance.</li>
</ul>
</div>

<h3>Horizontal Scaling Strategy</h3>
<div class="card">
<table>
  <tr><th>Component</th><th>Scaling Strategy</th><th>Notes</th></tr>
  <tr><td>API Gateway</td><td>Horizontal auto-scaling based on request rate</td><td>Stateless ‚Äî simply add more instances</td></tr>
  <tr><td>Interview Service</td><td>Horizontal auto-scaling based on CPU</td><td>Stateless ‚Äî all state in DB/cache</td></tr>
  <tr><td>Calculation Service</td><td>Horizontal auto-scaling based on CPU</td><td>CPU-intensive (tax computation). May need more instances than other services.</td></tr>
  <tr><td>Document Service</td><td>Horizontal auto-scaling based on request rate</td><td>Burst uploads in January when W-2s are issued</td></tr>
  <tr><td>OCR Workers</td><td>Queue-depth-based auto-scaling</td><td>Scale to 0 in off-season. Scale to hundreds during peak upload periods.</td></tr>
  <tr><td>Filing Service</td><td>Horizontal auto-scaling based on request rate</td><td>Massive spike on April 15</td></tr>
  <tr><td>Filing Workers</td><td>Queue-depth-based auto-scaling</td><td>Must respect IRS rate limits even under heavy load</td></tr>
  <tr><td>SQL DB (Primary)</td><td>Vertical scaling + connection pooling</td><td>Single writer per shard. Connection pooling handles the burst.</td></tr>
  <tr><td>SQL DB (Read Replicas)</td><td>Horizontal (add more replicas)</td><td>Calculation and Validation Services read from replicas to reduce primary load.</td></tr>
  <tr><td>Cache</td><td>Clustered (add more nodes)</td><td>Consistent hashing distributes keys across cache nodes.</td></tr>
  <tr><td>Object Storage</td><td>Virtually unlimited horizontal scaling</td><td>Object storage scales transparently.</td></tr>
  <tr><td>Message Queues</td><td>Partition-based scaling</td><td>Add partitions to handle higher throughput.</td></tr>
</table>
</div>

<h3>Pre-Scaling for Tax Season</h3>
<div class="card">
<p>Given the predictable seasonal spike, the system uses <strong>scheduled pre-scaling</strong> in addition to reactive auto-scaling:</p>
<ul>
  <li><strong>January 1:</strong> Scale all services to 3x baseline capacity (W-2 season begins).</li>
  <li><strong>April 1:</strong> Scale all services to 10x baseline capacity (filing deadline approaches).</li>
  <li><strong>April 14-15:</strong> Scale to 25-50x baseline capacity (absolute peak).</li>
  <li><strong>April 16:</strong> Begin scaling down. Return to baseline by May.</li>
</ul>
<p>This pre-scaling avoids the lag of reactive auto-scaling (which takes minutes to spin up new instances, causing dropped requests during sudden spikes).</p>
</div>

<hr>

<!-- ============================================================ -->
<h2 id="tradeoffs">12. Tradeoffs &amp; Deep Dives</h2>
<!-- ============================================================ -->

<h3>Tradeoff 1: SQL for Transactional Data vs. NoSQL for Everything</h3>
<div class="card">
<p><strong>Decision:</strong> SQL for user data, returns, answers, filings, and payments. NoSQL for question definitions, tax rules, and audit logs.</p>
<p><strong>Why:</strong> Tax preparation is fundamentally a <strong>financial/transactional system</strong>. A partial write (half of a user's answers saved during auto-save) would cause incorrect tax calculations. ACID transactions in SQL prevent this. The downside is that SQL is harder to scale horizontally ‚Äî but with sharding by user_id/return_id, we can achieve the necessary scale for the write path. Read replicas handle the read-heavy Calculation and Validation Services.</p>
<p>NoSQL is used where its strengths shine: deeply nested, schema-flexible documents (question definitions, tax rules) that are read-only at runtime, and high-throughput append-only data (audit logs).</p>
</div>

<h3>Tradeoff 2: Synchronous vs. Asynchronous Processing</h3>
<div class="card">
<p><strong>Decision:</strong> Synchronous for the interview flow and tax calculations. Asynchronous (via message queues) for OCR processing and e-filing.</p>
<p><strong>Why synchronous for interview/calculation:</strong> Users expect instant feedback when answering questions (next question in <100ms) and when calculating taxes (<2 seconds). These operations read from cache and DB and compute in-memory ‚Äî they're fast enough to handle synchronously.</p>
<p><strong>Why asynchronous for OCR:</strong> OCR takes 2-10 seconds per document and is CPU-intensive. Blocking the HTTP request would create a poor user experience and tie up service threads.</p>
<p><strong>Why asynchronous for filing:</strong> IRS submission involves an external system with unpredictable latency, rate limits, and a 24-48 hour response cycle. Synchronous submission is impossible for the full cycle and even the initial transmission benefits from queue-based buffering during the April 15 rush.</p>
</div>

<h3>Tradeoff 3: Encryption Overhead vs. Security</h3>
<div class="card">
<p><strong>Decision:</strong> Encrypt ALL PII and financial data at rest (AES-256) with per-field encryption for the most sensitive fields (SSN, bank account).</p>
<p><strong>Tradeoff:</strong> Encryption adds latency (~1-5ms per encrypt/decrypt operation) and prevents database-level searching on encrypted fields (can't do <code>WHERE ssn = '123-45-6789'</code> on encrypted columns). We mitigate this by: (1) using application-level encryption/decryption (the DB stores ciphertext), (2) maintaining separate lookup indexes where needed (e.g., hash index on email for login), (3) accepting the latency cost as non-negotiable for compliance.</p>
</div>

<h3>Tradeoff 4: Monolith vs. Microservices</h3>
<div class="card">
<p><strong>Decision:</strong> Microservices architecture with separate services for Interview, Document, Calculation, Validation, Filing, Payment, and Notification.</p>
<p><strong>Why:</strong> TurboTax's components have drastically different scaling profiles. The Calculation Service is CPU-bound and needs more compute per request. The Filing Service has spiky traffic concentrated on April 15. OCR Workers need GPU/ML resources. A monolith would require over-provisioning everything to handle the most demanding component. Microservices let each component scale independently.</p>
<p><strong>Downside:</strong> Increased operational complexity (service discovery, distributed tracing, network overhead). Mitigated with a service mesh, centralized logging, and the API Gateway pattern.</p>
</div>

<h3>Tradeoff 5: Client-Side Polling vs. WebSockets vs. Server-Sent Events (SSE) for Filing Status</h3>
<div class="card">
<p><strong>Decision:</strong> Client-side polling for filing status.</p>
<p><strong>Why not WebSockets:</strong> Filing status changes happen 24-48 hours after submission. Maintaining a persistent WebSocket connection for days is wasteful and complex (connection management, reconnection logic, server-side state). WebSockets are designed for high-frequency, bidirectional real-time communication (chat, gaming) ‚Äî not for events that happen once in 48 hours.</p>
<p><strong>Why not SSE (Server-Sent Events):</strong> SSE would be slightly better than WebSockets (unidirectional, lighter protocol), but still maintains a persistent connection. The same argument applies ‚Äî we don't need a persistent connection for an event that happens once in 48 hours.</p>
<p><strong>Why polling works:</strong> Users check their filing status by opening the app and viewing the status page. When on the page, the client polls <code>GET /filing/{id}/status</code> every 30 seconds. When not on the page, push notifications (email + mobile push) alert the user to status changes. This is simple, stateless, and effective.</p>
</div>

<h3>Tradeoff 6: Single DB vs. Read Replicas</h3>
<div class="card">
<p><strong>Decision:</strong> Primary DB for writes + read replicas for the Calculation and Validation Services.</p>
<p><strong>Why:</strong> Tax calculation reads all answers for a return (potentially 200+ rows) and joins with tax_returns. During peak, millions of calculations run per hour. Sending all these reads to the primary DB would overwhelm it. Read replicas handle these read-heavy workloads while the primary handles writes (answer saves, status updates).</p>
<p><strong>Replication lag consideration:</strong> Read replicas may be 10-100ms behind the primary. For the Calculation Service, this is acceptable ‚Äî if a user saves an answer and immediately triggers a calculation, the answer might not be on the replica yet. We handle this by having the Calculation Service read from the <strong>primary</strong> for the specific return being calculated (targeted read-your-writes consistency) while using replicas for reference data lookups.</p>
</div>

<hr>

<!-- ============================================================ -->
<h2 id="alternatives">13. Alternative Approaches</h2>
<!-- ============================================================ -->

<h3>Alternative 1: Client-Side Tax Calculation Engine</h3>
<div class="card">
<p><strong>Approach:</strong> Run the tax calculation engine in the browser (JavaScript/WASM) instead of on the server.</p>
<p><strong>Why rejected:</strong></p>
<ul>
  <li><strong>Security risk:</strong> Tax rules are proprietary intellectual property. Shipping them to the client exposes them to reverse-engineering.</li>
  <li><strong>Correctness risk:</strong> Users could tamper with the calculation logic to manipulate results.</li>
  <li><strong>Maintenance burden:</strong> Every tax rule change requires a client deployment. Server-side changes are instant.</li>
  <li><strong>Compliance:</strong> IRS requires that the e-file provider (TurboTax) validate calculations server-side before submission. Client-side calculation would still need server-side verification, doubling the work.</li>
</ul>
</div>

<h3>Alternative 2: Event-Driven Architecture (Event Sourcing)</h3>
<div class="card">
<p><strong>Approach:</strong> Instead of storing the current state of a tax return (latest answers, latest calculation), store every event that happened: "user_answered_Q1", "user_changed_Q1", "ocr_extracted_W2", etc. Rebuild the current state by replaying events.</p>
<p><strong>Why rejected:</strong></p>
<ul>
  <li><strong>Complexity:</strong> Event sourcing adds significant complexity to what is fundamentally a CRUD application (users fill in forms, we save them).</li>
  <li><strong>Latency:</strong> Rebuilding state from events on every request is slow unless combined with snapshotting, which partially negates the benefits.</li>
  <li><strong>Audit logging suffices:</strong> The immutable audit log already captures the history of all significant events without requiring the entire data model to be event-sourced.</li>
</ul>
<p><strong>Where it could make sense:</strong> If we needed to support "undo" for every field change (a feature TurboTax doesn't offer), event sourcing would be a natural fit.</p>
</div>

<h3>Alternative 3: GraphQL Instead of REST</h3>
<div class="card">
<p><strong>Approach:</strong> Use GraphQL as the API layer instead of REST endpoints.</p>
<p><strong>Why rejected:</strong></p>
<ul>
  <li><strong>TurboTax's API is relatively simple:</strong> Each page loads one question and saves one answer. There's no complex, nested data fetching that GraphQL excels at (like a social media feed with posts, comments, likes, and user profiles nested arbitrarily).</li>
  <li><strong>Security:</strong> GraphQL's flexible query language increases the attack surface. In a tax preparation system, we want to minimize the API surface area, not maximize flexibility.</li>
  <li><strong>Caching:</strong> REST's URL-based caching (CDN, HTTP cache) is simpler than GraphQL's per-field caching.</li>
</ul>
<p><strong>Where it could make sense:</strong> If TurboTax added a complex dashboard with many customizable widgets pulling different data combinations, GraphQL would reduce over-fetching.</p>
</div>

<h3>Alternative 4: NoSQL for Everything (Schemaless)</h3>
<div class="card">
<p><strong>Approach:</strong> Store all data (users, returns, answers, filings, payments) in a NoSQL document database.</p>
<p><strong>Why rejected:</strong></p>
<ul>
  <li><strong>ACID transactions:</strong> NoSQL databases generally don't support multi-document ACID transactions (or do so with significant limitations). Saving a batch of answers atomically, or ensuring a filing record + return status update happen together, requires ACID.</li>
  <li><strong>Data integrity:</strong> Foreign keys and unique constraints (prevent duplicate filings) are enforced at the DB level with SQL. With NoSQL, these would need to be enforced in application code, which is error-prone.</li>
  <li><strong>Correctness over flexibility:</strong> For a tax system, data correctness is paramount. The rigid schema of SQL is a feature, not a bug ‚Äî it prevents invalid data from entering the system.</li>
</ul>
</div>

<h3>Alternative 5: Serverless / Function-as-a-Service Architecture</h3>
<div class="card">
<p><strong>Approach:</strong> Deploy each API endpoint as an individual serverless function that auto-scales to zero.</p>
<p><strong>Why rejected:</strong></p>
<ul>
  <li><strong>Cold starts:</strong> Serverless functions have cold-start latency (100ms-2s), which is unacceptable for a responsive interview experience.</li>
  <li><strong>Execution time limits:</strong> Some serverless platforms impose execution time limits (e.g., 15 minutes). OCR processing and complex tax calculations may exceed these.</li>
  <li><strong>Cost at scale:</strong> During the April 15 peak with millions of concurrent users, serverless per-invocation pricing can be more expensive than reserved instances.</li>
</ul>
<p><strong>Where it could make sense:</strong> Serverless could work well for the Notification Service (sporadic, event-driven workload) and for the off-season API (scale to near-zero when there's almost no traffic).</p>
</div>

<hr>

<!-- ============================================================ -->
<h2 id="additional">14. Additional Considerations</h2>
<!-- ============================================================ -->

<h3>Data Retention &amp; Deletion</h3>
<div class="card">
<ul>
  <li><strong>IRS Requirement:</strong> E-file providers must retain records of submitted returns for 7 years.</li>
  <li><strong>User Request:</strong> Users can request deletion of their account (per privacy laws), but filed return records must be retained in anonymized form for 7 years to satisfy IRS regulations.</li>
  <li><strong>Object Storage Lifecycle:</strong> Documents (W-2 images, etc.) have a 7-year lifecycle policy. After 7 years, they are automatically deleted.</li>
</ul>
</div>

<h3>Disaster Recovery &amp; Backup</h3>
<div class="card">
<ul>
  <li><strong>RPO (Recovery Point Objective):</strong> < 1 minute. Continuous replication with point-in-time recovery for the SQL database.</li>
  <li><strong>RTO (Recovery Time Objective):</strong> < 15 minutes. Automated failover to a secondary data center.</li>
  <li><strong>Multi-region:</strong> Primary + standby data center (both in the US for data residency). Active-passive with automatic failover.</li>
  <li><strong>Backups:</strong> Hourly snapshots of the SQL DB with 30-day retention. Daily backups archived for 7 years.</li>
</ul>
</div>

<h3>Rate Limiting &amp; Abuse Prevention</h3>
<div class="card">
<ul>
  <li><strong>Per-user rate limits:</strong> 100 requests/minute per authenticated user (prevents automated abuse).</li>
  <li><strong>Per-IP rate limits:</strong> 200 requests/minute per IP (prevents unauthenticated abuse/scraping).</li>
  <li><strong>Filing submission limits:</strong> Maximum 3 filing attempts per return per day (prevents accidental duplicate filings during retry storms).</li>
  <li><strong>Document upload limits:</strong> Maximum 50 documents per return, 10 MB per document.</li>
</ul>
</div>

<h3>Observability &amp; Monitoring</h3>
<div class="card">
<ul>
  <li><strong>Distributed tracing:</strong> Every request gets a trace ID that propagates across all services. Critical for debugging slow tax calculations or failed filings.</li>
  <li><strong>Key metrics:</strong> Calculation latency (P50, P95, P99), filing success rate, OCR accuracy rate, queue depth for all message queues, auto-save success rate.</li>
  <li><strong>Alerting:</strong> Page on-call if: filing error rate > 1%, calculation P99 > 5s, queue depth exceeds 10,000 messages, DB replication lag > 500ms.</li>
</ul>
</div>

<h3>Accessibility &amp; Compliance</h3>
<div class="card">
<ul>
  <li><strong>WCAG 2.1 AA compliance:</strong> TurboTax is legally required to be accessible (Section 508). The interview UI must work with screen readers, keyboard navigation, and high-contrast modes.</li>
  <li><strong>Multi-language support:</strong> English and Spanish at minimum (per IRS guidance on serving diverse populations).</li>
</ul>
</div>

<h3>A/B Testing &amp; Experimentation</h3>
<div class="card">
<p>TurboTax heavily A/B tests interview question wording, UI layouts, and upsell placements. The Interview Service supports experiments by accepting an <code>experiment_variant</code> parameter that changes question text, ordering, or presentation. A/B testing infrastructure is a separate concern (not shown in the system design) but integrates via the API Gateway passing experiment assignments to each service.</p>
</div>

<h3>Security Deep Dive</h3>
<div class="card">
<ul>
  <li><strong>Encryption:</strong> TLS 1.3 in transit. AES-256 at rest. Per-field encryption for SSN and bank account numbers using envelope encryption (data key encrypted by master key in KMS).</li>
  <li><strong>Authentication:</strong> JWT with short expiry (15 minutes) + refresh tokens. MFA required for all users (SMS, authenticator app, or security key).</li>
  <li><strong>Session management:</strong> Sessions expire after 30 minutes of inactivity (IRS recommendation). Users must re-authenticate to resume.</li>
  <li><strong>Input validation:</strong> All inputs are validated server-side (never trust the client). SQL injection prevention via parameterized queries. XSS prevention via output encoding.</li>
  <li><strong>PCI DSS:</strong> Card details never touch TurboTax servers (payment gateway's hosted form handles card entry). This minimizes PCI scope.</li>
</ul>
</div>

<hr>

<!-- ============================================================ -->
<h2 id="vendors">15. Vendor Recommendations</h2>
<!-- ============================================================ -->

<div class="card">
<p>The system design above is vendor-agnostic for databases, storage, caches, and message queues. Below are recommended vendors with rationale.</p>

<table>
  <tr><th>Component</th><th>Vendor Options</th><th>Rationale</th></tr>
  <tr><td><strong>SQL Database</strong></td><td>PostgreSQL, Amazon Aurora, CockroachDB</td><td>PostgreSQL is the industry standard for ACID-compliant relational databases. Aurora provides managed PostgreSQL with automated replication and failover. CockroachDB adds distributed SQL with horizontal scaling, which helps with the sharding strategy.</td></tr>
  <tr><td><strong>NoSQL (Document DB)</strong></td><td>MongoDB, Amazon DynamoDB, Azure Cosmos DB</td><td>MongoDB for flexible document schemas (question definitions, tax rules). DynamoDB for its high write throughput on the audit log. Cosmos DB if multi-region consistency tuning is needed.</td></tr>
  <tr><td><strong>In-Memory Cache</strong></td><td>Redis, Memcached, Hazelcast</td><td>Redis is preferred for its support of data structures (hashes for session data), TTL, and cluster mode for horizontal scaling. Memcached is a simpler alternative if only key-value caching is needed.</td></tr>
  <tr><td><strong>Message Queue</strong></td><td>RabbitMQ, Amazon SQS, Apache Kafka</td><td>SQS for simplicity and automatic scaling (ideal for the OCR and filing job queues). RabbitMQ if advanced routing is needed. Kafka if event streaming becomes a requirement (currently overkill for job queues).</td></tr>
  <tr><td><strong>Object Storage</strong></td><td>Amazon S3, Google Cloud Storage, Azure Blob Storage</td><td>All three provide 99.999999999% durability, lifecycle policies for 7-year retention, and encryption at rest. S3 is the most battle-tested for this scale.</td></tr>
  <tr><td><strong>CDN</strong></td><td>CloudFront, Cloudflare, Akamai</td><td>CloudFront integrates tightly with S3 for static assets. Cloudflare offers excellent DDoS protection. Akamai has the largest US edge network, which matters since all users are US-based.</td></tr>
  <tr><td><strong>OCR Engine</strong></td><td>Google Cloud Vision, Amazon Textract, Tesseract (open source)</td><td>Textract has purpose-built document extraction (form parsing) ideal for W-2s and 1099s. Google Cloud Vision has strong general OCR. Tesseract is free but requires more tuning for structured forms.</td></tr>
  <tr><td><strong>Payment Gateway</strong></td><td>Stripe, Braintree, Adyen</td><td>Stripe for its developer-friendly API, hosted payment form (PCI compliance), and webhook reliability. Braintree for PayPal integration. Adyen for enterprise-grade processing.</td></tr>
  <tr><td><strong>Audit Log / Time-Series</strong></td><td>Amazon QLDB, InfluxDB, TimescaleDB</td><td>QLDB provides a cryptographically verifiable, immutable ledger ‚Äî ideal for tax audit logs. TimescaleDB is good if time-range queries on the audit log are frequent.</td></tr>
</table>
</div>

<script>
  mermaid.initialize({ startOnLoad: true, theme: 'default', securityLevel: 'loose' });
</script>

</body>
</html>
