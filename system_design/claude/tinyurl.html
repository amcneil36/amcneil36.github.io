<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>System Design: TinyURL</title>
<style>body{font-family:'Segoe UI',Arial,sans-serif;margin:0;padding:20px;background:#f5f5f5;color:#333}.container{max-width:1200px;margin:0 auto;background:#fff;padding:40px;border-radius:8px;box-shadow:0 2px 10px rgba(0,0,0,.1)}h1{color:#1a73e8;border-bottom:3px solid #1a73e8;padding-bottom:10px}h2{color:#2c3e50;margin-top:40px;border-left:4px solid #1a73e8;padding-left:12px}h3{color:#34495e}h4{color:#555}.diagram{background:#fafafa;border:1px solid #ddd;border-radius:8px;padding:20px;margin:20px 0;overflow-x:auto}.example{background:#e8f5e9;border-left:4px solid #4caf50;padding:15px;margin:15px 0;border-radius:4px}.deep-dive{background:#e3f2fd;border-left:4px solid #2196f3;padding:15px;margin:15px 0;border-radius:4px}.tradeoff{background:#fff3e0;border-left:4px solid #ff9800;padding:15px;margin:15px 0;border-radius:4px}.alternative{background:#fce4ec;border-left:4px solid #e91e63;padding:15px;margin:15px 0;border-radius:4px}table{border-collapse:collapse;width:100%;margin:15px 0}th,td{border:1px solid #ddd;padding:10px 14px;text-align:left}th{background:#1a73e8;color:#fff}tr:nth-child(even){background:#f9f9f9}code{background:#f0f0f0;padding:2px 6px;border-radius:3px;font-size:.9em}.tag{display:inline-block;padding:2px 8px;border-radius:4px;font-size:.85em;margin:2px}.tag-pk{background:#ffeb3b;color:#333}.tag-fk{background:#ce93d8;color:#333}.tag-idx{background:#80cbc4;color:#333}ul,ol{line-height:1.8}svg text{font-family:'Segoe UI',Arial,sans-serif}</style>
</head>
<body>
<div class="container">
<h1>System Design: TinyURL (URL Shortener)</h1>

<h2>Functional Requirements</h2>
<ol>
  <li><strong>Shorten URL</strong> – Given a long URL, generate a unique short URL (e.g., tinyurl.com/abc123).</li>
  <li><strong>Redirect</strong> – When users visit the short URL, redirect them (HTTP 301/302) to the original long URL.</li>
  <li><strong>Custom aliases</strong> – Users can optionally specify a custom short code (e.g., tinyurl.com/my-brand).</li>
  <li><strong>Expiration</strong> – URLs can optionally have an expiration time after which they stop working.</li>
  <li><strong>Analytics</strong> – Track click counts, referrers, geographic data, and device info for each shortened URL.</li>
</ol>

<h2>Non-Functional Requirements</h2>
<ol>
  <li><strong>High availability</strong> – 99.99% uptime; redirect must always work.</li>
  <li><strong>Low latency</strong> – Redirect in &lt;50ms (p99). URL creation in &lt;200ms.</li>
  <li><strong>Scalability</strong> – Handle 1B+ shortened URLs, 100K reads/sec, 1K writes/sec (100:1 read-to-write ratio).</li>
  <li><strong>Uniqueness</strong> – No two long URLs should generate the same short code (unless explicitly the same URL).</li>
  <li><strong>Durability</strong> – Shortened URLs must be persistent and never lost.</li>
</ol>

<!-- ==================== FLOW 1: URL SHORTENING ==================== -->
<h2>Flow 1: Creating a Short URL</h2>
<div class="diagram">
<svg viewBox="0 0 1000 350" xmlns="http://www.w3.org/2000/svg">
  <defs><marker id="a1" viewBox="0 0 10 10" refX="9" refY="5" markerWidth="6" markerHeight="6" orient="auto"><path d="M0 0L10 5L0 10z" fill="#333"/></marker></defs>
  <rect x="10" y="130" width="80" height="50" rx="8" fill="#4caf50" stroke="#388e3c" stroke-width="2"/>
  <text x="50" y="160" text-anchor="middle" fill="#fff" font-size="12" font-weight="bold">User</text>
  <line x1="90" y1="155" x2="160" y2="155" stroke="#333" stroke-width="2" marker-end="url(#a1)"/>
  <text x="125" y="145" text-anchor="middle" fill="#555" font-size="9">POST /shorten</text>
  <rect x="160" y="130" width="80" height="50" rx="8" fill="#ff9800" stroke="#f57c00" stroke-width="2"/>
  <text x="200" y="153" text-anchor="middle" fill="#fff" font-size="10" font-weight="bold">API</text>
  <text x="200" y="165" text-anchor="middle" fill="#fff" font-size="10" font-weight="bold">GW</text>
  <line x1="240" y1="155" x2="310" y2="155" stroke="#333" stroke-width="2" marker-end="url(#a1)"/>
  <rect x="310" y="125" width="120" height="60" rx="8" fill="#2196f3" stroke="#1565c0" stroke-width="2"/>
  <text x="370" y="153" text-anchor="middle" fill="#fff" font-size="11" font-weight="bold">URL Shortener</text>
  <text x="370" y="168" text-anchor="middle" fill="#fff" font-size="11" font-weight="bold">Service</text>
  <!-- To Key Generation Service -->
  <line x1="370" y1="125" x2="370" y2="55" stroke="#333" stroke-width="1.5" marker-end="url(#a1)"/>
  <rect x="315" y="5" width="110" height="50" rx="8" fill="#673ab7" stroke="#4527a0" stroke-width="2"/>
  <text x="370" y="28" text-anchor="middle" fill="#fff" font-size="10" font-weight="bold">Key Gen</text>
  <text x="370" y="43" text-anchor="middle" fill="#fff" font-size="10" font-weight="bold">Service (KGS)</text>
  <!-- KGS to Key DB -->
  <line x1="425" y1="30" x2="500" y2="30" stroke="#333" stroke-width="1.5" marker-end="url(#a1)"/>
  <ellipse cx="550" cy="23" rx="40" ry="10" fill="#ff5722" stroke="#d84315" stroke-width="1.5"/>
  <rect x="510" y="23" width="80" height="22" fill="#ff5722" stroke="#d84315" stroke-width="1.5"/>
  <ellipse cx="550" cy="45" rx="40" ry="10" fill="#e64a19" stroke="#d84315" stroke-width="1.5"/>
  <line x1="510" y1="23" x2="510" y2="45" stroke="#d84315" stroke-width="1.5"/>
  <line x1="590" y1="23" x2="590" y2="45" stroke="#d84315" stroke-width="1.5"/>
  <text x="550" y="38" text-anchor="middle" fill="#fff" font-size="8" font-weight="bold">Key DB</text>
  <!-- URL Service to URL DB -->
  <line x1="430" y1="155" x2="520" y2="155" stroke="#333" stroke-width="2" marker-end="url(#a1)"/>
  <ellipse cx="575" cy="145" rx="45" ry="10" fill="#ff5722" stroke="#d84315" stroke-width="2"/>
  <rect x="530" y="145" width="90" height="30" fill="#ff5722" stroke="#d84315" stroke-width="2"/>
  <ellipse cx="575" cy="175" rx="45" ry="10" fill="#e64a19" stroke="#d84315" stroke-width="2"/>
  <line x1="530" y1="145" x2="530" y2="175" stroke="#d84315" stroke-width="2"/>
  <line x1="620" y1="145" x2="620" y2="175" stroke="#d84315" stroke-width="2"/>
  <text x="575" y="164" text-anchor="middle" fill="#fff" font-size="9" font-weight="bold">URL DB</text>
  <!-- URL Service to Cache -->
  <line x1="370" y1="185" x2="370" y2="250" stroke="#333" stroke-width="1.5" marker-end="url(#a1)"/>
  <ellipse cx="370" cy="260" rx="45" ry="10" fill="#009688" stroke="#00695c" stroke-width="1.5"/>
  <rect x="325" y="260" width="90" height="25" fill="#009688" stroke="#00695c" stroke-width="1.5"/>
  <ellipse cx="370" cy="285" rx="45" ry="10" fill="#00796b" stroke="#00695c" stroke-width="1.5"/>
  <line x1="325" y1="260" x2="325" y2="285" stroke="#00695c" stroke-width="1.5"/>
  <line x1="415" y1="260" x2="415" y2="285" stroke="#00695c" stroke-width="1.5"/>
  <text x="370" y="277" text-anchor="middle" fill="#fff" font-size="8" font-weight="bold">Cache (Redis)</text>
</svg>
</div>

<div class="example">
<h4>Example 1: Auto-generated short code</h4>
<p>Alice submits <strong>POST /api/v1/shorten</strong> with <code>{long_url: "https://www.example.com/very/long/path?param=value"}</code>. The API Gateway authenticates the request and routes to the <strong>URL Shortener Service</strong>. The service calls the <strong>Key Generation Service (KGS)</strong> to get a pre-generated unique 7-character key (e.g., "aB3xY9k"). The KGS maintains a pool of pre-generated keys in the <strong>Key DB</strong> — it marks the key as "used" atomically. The Shortener Service writes the mapping <code>{short_code: "aB3xY9k", long_url: "https://...", user_id: alice, created_at, expires_at: null}</code> to the <strong>URL DB</strong> and populates the <strong>Cache</strong> (Redis). Returns <code>{short_url: "https://tinyurl.com/aB3xY9k"}</code> to Alice.</p>
</div>

<div class="example">
<h4>Example 2: Custom alias</h4>
<p>Bob submits <strong>POST /api/v1/shorten</strong> with <code>{long_url: "https://mybusiness.com", custom_alias: "my-biz"}</code>. The Shortener Service checks if "my-biz" is already taken in the URL DB. It's not, so it creates the mapping and returns <code>{short_url: "https://tinyurl.com/my-biz"}</code>. If "my-biz" were already taken, a 409 Conflict error would be returned.</p>
</div>

<h3>Deep Dive: Components</h3>

<div class="deep-dive">
<h4>Key Generation Service (KGS)</h4>
<p>Pre-generates unique 7-character codes using base62 encoding (a-z, A-Z, 0-9). 62^7 = 3.5 trillion possible codes — enough for centuries of usage. The KGS pre-generates keys in batches (e.g., 1M at a time) and stores them in the Key DB with a <code>used</code> flag. When the Shortener Service requests a key, KGS pops one from the pool and marks it used.</p>
<p><strong>Why KGS over hash-based approach:</strong> Hashing (e.g., MD5/SHA256 of long URL, truncated to 7 chars) can produce collisions. KGS guarantees uniqueness without collision checking. KGS also decouples key generation from the main service, enabling horizontal scaling.</p>
<p><strong>Concurrency:</strong> Each KGS instance pre-loads a batch of unused keys into memory. Multiple instances can serve keys in parallel without conflicts because each instance has its own batch.</p>
</div>

<div class="deep-dive">
<h4>URL Shortener Service</h4>
<p><strong>Endpoints:</strong></p>
<ul>
  <li><code>POST /api/v1/shorten</code> – Input: <code>{long_url, custom_alias?, expires_at?}</code>. Output: <code>{short_url, short_code, created_at}</code>.</li>
  <li><code>GET /{short_code}</code> – Redirect endpoint (see Flow 2).</li>
  <li><code>GET /api/v1/stats/{short_code}</code> – Analytics endpoint.</li>
  <li><code>DELETE /api/v1/urls/{short_code}</code> – Delete a short URL.</li>
</ul>
</div>

<!-- ==================== FLOW 2: URL REDIRECT ==================== -->
<h2>Flow 2: URL Redirect</h2>
<div class="diagram">
<svg viewBox="0 0 900 280" xmlns="http://www.w3.org/2000/svg">
  <defs><marker id="a2" viewBox="0 0 10 10" refX="9" refY="5" markerWidth="6" markerHeight="6" orient="auto"><path d="M0 0L10 5L0 10z" fill="#333"/></marker></defs>
  <rect x="10" y="100" width="80" height="50" rx="8" fill="#4caf50" stroke="#388e3c" stroke-width="2"/>
  <text x="50" y="130" text-anchor="middle" fill="#fff" font-size="12" font-weight="bold">User</text>
  <line x1="90" y1="125" x2="170" y2="125" stroke="#333" stroke-width="2" marker-end="url(#a2)"/>
  <text x="130" y="115" text-anchor="middle" fill="#555" font-size="9">GET /aB3xY9k</text>
  <rect x="170" y="100" width="80" height="50" rx="8" fill="#ff9800" stroke="#f57c00" stroke-width="2"/>
  <text x="210" y="123" text-anchor="middle" fill="#fff" font-size="10" font-weight="bold">Load</text>
  <text x="210" y="135" text-anchor="middle" fill="#fff" font-size="10" font-weight="bold">Balancer</text>
  <line x1="250" y1="125" x2="330" y2="125" stroke="#333" stroke-width="2" marker-end="url(#a2)"/>
  <rect x="330" y="100" width="110" height="50" rx="8" fill="#2196f3" stroke="#1565c0" stroke-width="2"/>
  <text x="385" y="130" text-anchor="middle" fill="#fff" font-size="11" font-weight="bold">URL Service</text>
  <!-- Cache check -->
  <line x1="440" y1="115" x2="520" y2="70" stroke="#333" stroke-width="1.5" marker-end="url(#a2)"/>
  <text x="500" y="80" text-anchor="middle" fill="#555" font-size="8">1. Cache lookup</text>
  <ellipse cx="575" cy="58" rx="45" ry="10" fill="#009688" stroke="#00695c" stroke-width="1.5"/>
  <rect x="530" y="58" width="90" height="22" fill="#009688" stroke="#00695c" stroke-width="1.5"/>
  <ellipse cx="575" cy="80" rx="45" ry="10" fill="#00796b" stroke="#00695c" stroke-width="1.5"/>
  <line x1="530" y1="58" x2="530" y2="80" stroke="#00695c" stroke-width="1.5"/>
  <line x1="620" y1="58" x2="620" y2="80" stroke="#00695c" stroke-width="1.5"/>
  <text x="575" y="73" text-anchor="middle" fill="#fff" font-size="8" font-weight="bold">Redis Cache</text>
  <!-- DB fallback -->
  <line x1="440" y1="135" x2="520" y2="175" stroke="#333" stroke-width="1.5" marker-end="url(#a2)"/>
  <text x="500" y="170" text-anchor="middle" fill="#555" font-size="8">2. DB (cache miss)</text>
  <ellipse cx="575" cy="170" rx="45" ry="10" fill="#ff5722" stroke="#d84315" stroke-width="1.5"/>
  <rect x="530" y="170" width="90" height="25" fill="#ff5722" stroke="#d84315" stroke-width="1.5"/>
  <ellipse cx="575" cy="195" rx="45" ry="10" fill="#e64a19" stroke="#d84315" stroke-width="1.5"/>
  <line x1="530" y1="170" x2="530" y2="195" stroke="#d84315" stroke-width="1.5"/>
  <line x1="620" y1="170" x2="620" y2="195" stroke="#d84315" stroke-width="1.5"/>
  <text x="575" y="187" text-anchor="middle" fill="#fff" font-size="8" font-weight="bold">URL DB</text>
  <!-- 301 redirect back to user -->
  <line x1="330" y1="150" x2="90" y2="175" stroke="#333" stroke-width="1.5" marker-end="url(#a2)"/>
  <text x="210" y="178" text-anchor="middle" fill="#555" font-size="9">HTTP 301 → long_url</text>
  <!-- Async analytics -->
  <line x1="385" y1="150" x2="385" y2="230" stroke="#333" stroke-width="1" stroke-dasharray="4,3" marker-end="url(#a2)"/>
  <rect x="330" y="230" width="110" height="35" rx="6" fill="#9c27b0" stroke="#6a1b9a" stroke-width="1.5"/>
  <text x="385" y="252" text-anchor="middle" fill="#fff" font-size="9" font-weight="bold">Analytics Queue</text>
</svg>
</div>

<div class="example">
<h4>Example 1: Cache hit</h4>
<p>A user clicks <code>https://tinyurl.com/aB3xY9k</code>. The browser sends <strong>GET /aB3xY9k</strong> to the Load Balancer → <strong>URL Service</strong>. The service looks up "aB3xY9k" in the <strong>Redis Cache</strong> — cache hit! Returns the long URL. The service responds with <strong>HTTP 301 Moved Permanently</strong> with <code>Location: https://www.example.com/very/long/path?param=value</code>. The browser redirects. Asynchronously, a click event is published to the <strong>Analytics Queue</strong>.</p>
</div>

<div class="example">
<h4>Example 2: Cache miss</h4>
<p>The short code "xYz987" hasn't been accessed recently and was evicted from cache. The URL Service queries the <strong>URL DB</strong> (cache miss → DB lookup), finds the mapping, populates the Redis Cache for future requests, and returns the 301 redirect.</p>
</div>

<div class="example">
<h4>Example 3: Expired URL</h4>
<p>The short code "abc123" was set to expire on 2024-01-01. A user visits it on 2024-03-15. The URL Service finds the record but checks <code>expires_at &lt; now()</code> → expired. Returns <strong>HTTP 410 Gone</strong> with a friendly error page.</p>
</div>

<div class="deep-dive">
<h4>HTTP 301 vs. 302</h4>
<p><strong>301 (Moved Permanently):</strong> Browser caches the redirect. Subsequent visits to the short URL don't hit our server — faster for the user, less server load. But we lose analytics on repeat visits.</p>
<p><strong>302 (Found/Temporary):</strong> Browser doesn't cache. Every visit hits our server — enables accurate click counting. Slightly slower for repeat visits.</p>
<p><strong>Our choice:</strong> Use <strong>301</strong> by default for speed and reduced load. For URLs with analytics tracking enabled, use <strong>302</strong> to capture every click.</p>
</div>

<!-- ==================== OVERALL COMBINED FLOW ==================== -->
<h2>Overall Combined Flow</h2>
<div class="diagram">
<svg viewBox="0 0 1050 380" xmlns="http://www.w3.org/2000/svg">
  <defs><marker id="a3" viewBox="0 0 10 10" refX="9" refY="5" markerWidth="6" markerHeight="6" orient="auto"><path d="M0 0L10 5L0 10z" fill="#333"/></marker></defs>
  <rect x="10" y="150" width="70" height="45" rx="6" fill="#4caf50" stroke="#388e3c" stroke-width="1.5"/>
  <text x="45" y="177" text-anchor="middle" fill="#fff" font-size="10" font-weight="bold">Client</text>
  <line x1="80" y1="172" x2="130" y2="172" stroke="#333" stroke-width="1.5" marker-end="url(#a3)"/>
  <rect x="130" y="150" width="70" height="45" rx="6" fill="#ff9800" stroke="#f57c00" stroke-width="1.5"/>
  <text x="165" y="170" text-anchor="middle" fill="#fff" font-size="9" font-weight="bold">Load</text>
  <text x="165" y="182" text-anchor="middle" fill="#fff" font-size="9" font-weight="bold">Balancer</text>
  <line x1="200" y1="172" x2="250" y2="172" stroke="#333" stroke-width="1.5" marker-end="url(#a3)"/>
  <rect x="250" y="145" width="100" height="55" rx="8" fill="#2196f3" stroke="#1565c0" stroke-width="2"/>
  <text x="300" y="170" text-anchor="middle" fill="#fff" font-size="10" font-weight="bold">URL</text>
  <text x="300" y="183" text-anchor="middle" fill="#fff" font-size="10" font-weight="bold">Service</text>
  <!-- Cache -->
  <line x1="350" y1="162" x2="420" y2="110" stroke="#333" stroke-width="1.5" marker-end="url(#a3)"/>
  <ellipse cx="470" cy="100" rx="40" ry="10" fill="#009688" stroke="#00695c" stroke-width="1.5"/>
  <rect x="430" y="100" width="80" height="20" fill="#009688" stroke="#00695c" stroke-width="1.5"/>
  <ellipse cx="470" cy="120" rx="40" ry="10" fill="#00796b" stroke="#00695c" stroke-width="1.5"/>
  <line x1="430" y1="100" x2="430" y2="120" stroke="#00695c" stroke-width="1.5"/>
  <line x1="510" y1="100" x2="510" y2="120" stroke="#00695c" stroke-width="1.5"/>
  <text x="470" y="114" text-anchor="middle" fill="#fff" font-size="8" font-weight="bold">Redis</text>
  <!-- URL DB -->
  <line x1="350" y1="180" x2="420" y2="230" stroke="#333" stroke-width="1.5" marker-end="url(#a3)"/>
  <ellipse cx="470" cy="225" rx="40" ry="10" fill="#ff5722" stroke="#d84315" stroke-width="1.5"/>
  <rect x="430" y="225" width="80" height="22" fill="#ff5722" stroke="#d84315" stroke-width="1.5"/>
  <ellipse cx="470" cy="247" rx="40" ry="10" fill="#e64a19" stroke="#d84315" stroke-width="1.5"/>
  <line x1="430" y1="225" x2="430" y2="247" stroke="#d84315" stroke-width="1.5"/>
  <line x1="510" y1="225" x2="510" y2="247" stroke="#d84315" stroke-width="1.5"/>
  <text x="470" y="240" text-anchor="middle" fill="#fff" font-size="8" font-weight="bold">URL DB</text>
  <!-- KGS -->
  <line x1="300" y1="145" x2="300" y2="70" stroke="#333" stroke-width="1" marker-end="url(#a3)"/>
  <rect x="255" y="25" width="90" height="45" rx="6" fill="#673ab7" stroke="#4527a0" stroke-width="1.5"/>
  <text x="300" y="52" text-anchor="middle" fill="#fff" font-size="9" font-weight="bold">KGS</text>
  <line x1="345" y1="47" x2="400" y2="47" stroke="#333" stroke-width="1" marker-end="url(#a3)"/>
  <ellipse cx="440" cy="40" rx="30" ry="8" fill="#ff5722" stroke="#d84315" stroke-width="1"/>
  <rect x="410" y="40" width="60" height="16" fill="#ff5722" stroke="#d84315" stroke-width="1"/>
  <ellipse cx="440" cy="56" rx="30" ry="8" fill="#e64a19" stroke="#d84315" stroke-width="1"/>
  <line x1="410" y1="40" x2="410" y2="56" stroke="#d84315" stroke-width="1"/>
  <line x1="470" y1="40" x2="470" y2="56" stroke="#d84315" stroke-width="1"/>
  <text x="440" y="52" text-anchor="middle" fill="#fff" font-size="7" font-weight="bold">Key DB</text>
  <!-- Analytics -->
  <line x1="300" y1="200" x2="300" y2="290" stroke="#333" stroke-width="1" stroke-dasharray="4,3" marker-end="url(#a3)"/>
  <rect x="255" y="290" width="90" height="35" rx="6" fill="#9c27b0" stroke="#6a1b9a" stroke-width="1.5"/>
  <text x="300" y="312" text-anchor="middle" fill="#fff" font-size="9" font-weight="bold">Analytics Q</text>
  <line x1="345" y1="307" x2="410" y2="307" stroke="#333" stroke-width="1" marker-end="url(#a3)"/>
  <rect x="410" y="290" width="90" height="35" rx="6" fill="#e91e63" stroke="#ad1457" stroke-width="1.5"/>
  <text x="455" y="312" text-anchor="middle" fill="#fff" font-size="9" font-weight="bold">Analytics Svc</text>
  <line x1="500" y1="307" x2="560" y2="307" stroke="#333" stroke-width="1" marker-end="url(#a3)"/>
  <ellipse cx="605" cy="300" rx="35" ry="8" fill="#ff5722" stroke="#d84315" stroke-width="1"/>
  <rect x="570" y="300" width="70" height="16" fill="#ff5722" stroke="#d84315" stroke-width="1"/>
  <ellipse cx="605" cy="316" rx="35" ry="8" fill="#e64a19" stroke="#d84315" stroke-width="1"/>
  <line x1="570" y1="300" x2="570" y2="316" stroke="#d84315" stroke-width="1"/>
  <line x1="640" y1="300" x2="640" y2="316" stroke="#d84315" stroke-width="1"/>
  <text x="605" y="312" text-anchor="middle" fill="#fff" font-size="7" font-weight="bold">Analytics DB</text>
</svg>
</div>

<div class="example">
<h4>Combined Example</h4>
<p><strong>Create:</strong> User POSTs long URL → LB → URL Service → KGS provides unique key "aB3xY9k" → saved to URL DB + Redis Cache → returns short URL.<br/>
<strong>Redirect:</strong> User GETs /aB3xY9k → LB → URL Service → Redis cache hit → HTTP 301 redirect to long URL. Click event → Analytics Queue → Analytics Service → Analytics DB.</p>
</div>

<!-- ==================== SCHEMA ==================== -->
<h2>Database Schema</h2>

<h3>NoSQL Table (DynamoDB/Cassandra)</h3>

<h4>1. urls</h4>
<table>
  <tr><th>Field</th><th>Type</th><th>Key</th><th>Description</th></tr>
  <tr><td>short_code</td><td>VARCHAR(7)</td><td><span class="tag tag-pk">Partition Key</span></td><td>The 7-char unique short code</td></tr>
  <tr><td>long_url</td><td>TEXT</td><td></td><td>Original URL (up to 2048 chars)</td></tr>
  <tr><td>user_id</td><td>BIGINT</td><td><span class="tag tag-idx">Secondary Index (Hash)</span></td><td>Creator (nullable for anonymous)</td></tr>
  <tr><td>created_at</td><td>TIMESTAMP</td><td></td><td>Creation time</td></tr>
  <tr><td>expires_at</td><td>TIMESTAMP</td><td></td><td>Expiration time (nullable)</td></tr>
  <tr><td>click_count</td><td>COUNTER</td><td></td><td>Total clicks (denormalized)</td></tr>
</table>
<p><strong>Why NoSQL:</strong> This is a simple key-value lookup (short_code → long_url). No joins, no complex queries. NoSQL provides low-latency reads and easy horizontal scaling. Cassandra or DynamoDB both work well.</p>
<p><strong>Index:</strong> Hash index on <code>short_code</code> (partition key) for O(1) lookups. Secondary hash index on <code>user_id</code> for "get all URLs created by user X" queries (used in the dashboard).</p>
<p><strong>Sharding:</strong> Auto-sharded by <code>short_code</code> (partition key) using consistent hashing. Distributes evenly due to random nature of generated codes.</p>
<p><strong>Read trigger:</strong> Every redirect (GET /{short_code}). <strong>Write trigger:</strong> URL creation (POST /shorten).</p>

<h4>2. keys (Key Generation)</h4>
<table>
  <tr><th>Field</th><th>Type</th><th>Key</th><th>Description</th></tr>
  <tr><td>key_value</td><td>VARCHAR(7)</td><td><span class="tag tag-pk">PK</span></td><td>Pre-generated short code</td></tr>
  <tr><td>is_used</td><td>BOOLEAN</td><td><span class="tag tag-idx">Index</span></td><td>Whether the key has been assigned</td></tr>
</table>
<p>Stored in a simple key-value store. KGS instances pre-load batches of unused keys into memory.</p>

<h4>3. analytics (Time-series)</h4>
<table>
  <tr><th>Field</th><th>Type</th><th>Key</th><th>Description</th></tr>
  <tr><td>short_code</td><td>VARCHAR(7)</td><td><span class="tag tag-pk">Partition Key</span></td><td>The short code</td></tr>
  <tr><td>timestamp</td><td>TIMESTAMP</td><td><span class="tag tag-pk">Clustering Key</span></td><td>Click timestamp</td></tr>
  <tr><td>ip_address</td><td>TEXT</td><td></td><td>Client IP</td></tr>
  <tr><td>user_agent</td><td>TEXT</td><td></td><td>Browser/device info</td></tr>
  <tr><td>referrer</td><td>TEXT</td><td></td><td>HTTP referrer</td></tr>
  <tr><td>country</td><td>TEXT</td><td></td><td>Geo-resolved country</td></tr>
</table>

<!-- ==================== CACHE ==================== -->
<h2>Cache Deep Dive</h2>
<div class="deep-dive">
<h4>Redis Cache</h4>
<p><strong>Purpose:</strong> Cache the short_code → long_url mapping for fast redirect lookups.</p>
<p><strong>Caching strategy:</strong> <strong>Write-through + Read-through.</strong> On URL creation: write to both DB and Redis. On redirect: check Redis first; on miss, query DB and populate Redis.</p>
<p><strong>Eviction policy:</strong> <strong>LRU (Least Recently Used).</strong> Popular URLs stay cached; rarely accessed URLs get evicted. This is optimal because URL access follows a power-law distribution — a small percentage of URLs account for the majority of traffic.</p>
<p><strong>Expiration policy:</strong> TTL = 24 hours. Refreshed on each access (TTL reset on read). Expired URLs in the DB are not cached.</p>
<p><strong>Cache size:</strong> With 20% of URLs accounting for 80% of traffic, caching the top 20% (~200M URLs × 1KB each = ~200GB) provides excellent hit rates (~95%).</p>
</div>

<div class="deep-dive">
<h4>CDN Consideration</h4>
<p>CDN is <strong>appropriate for the redirect</strong> endpoint. Configure CDN (e.g., CloudFront) to cache 301 redirects at edge locations. When a user in Tokyo clicks a short URL, the CDN edge in Tokyo responds directly with the cached redirect without hitting the origin server. This reduces redirect latency from ~50ms to ~5ms.</p>
<p><strong>CDN TTL:</strong> 1 hour for 301 redirects. Invalidate CDN cache when a URL is deleted or updated.</p>
</div>

<!-- ==================== SCALING ==================== -->
<h2>Scaling Considerations</h2>
<h3>Load Balancers</h3>
<ul>
  <li><strong>L7 Load Balancer</strong> in front of URL Service instances. Round-robin distribution for stateless HTTP requests.</li>
  <li>For redirect endpoint (GET), consider <strong>consistent hashing</strong> on the short_code to improve local caching on URL Service instances.</li>
</ul>
<h3>Horizontal Scaling</h3>
<ul>
  <li>URL Service: Stateless, add instances behind LB.</li>
  <li>Redis: Cluster mode, shard by short_code hash slot.</li>
  <li>Cassandra/DynamoDB: Add nodes, auto-rebalance.</li>
  <li>KGS: Multiple instances, each pre-loads its own batch of unused keys.</li>
</ul>

<h2>Tradeoffs and Deep Dives</h2>
<div class="tradeoff">
<h4>KGS vs. Hash-based Key Generation</h4>
<p><strong>KGS (chosen):</strong> Guarantees uniqueness without collision checking. Slight overhead of maintaining pre-generated keys. If KGS goes down, the pool of in-memory keys can serve requests until it recovers.</p>
<p><strong>Hashing:</strong> MD5/SHA256 of long URL, take first 7 chars of base62-encoded hash. Simpler but collision-prone. Must check DB for uniqueness and retry with a different seed on collision. At scale (1B+ URLs), collision rate increases.</p>
</div>

<div class="tradeoff">
<h4>Base62 vs. Base64</h4>
<p>Base62 (a-z, A-Z, 0-9) produces URL-safe characters. Base64 includes +, /, = which must be URL-encoded. We chose base62 for cleaner URLs. The tradeoff is slightly longer codes for the same keyspace, but 62^7 = 3.5T is more than sufficient.</p>
</div>

<h2>Alternative Approaches</h2>
<div class="alternative">
<h4>Alternative 1: Counter-based IDs</h4>
<p>Use an auto-incrementing counter, convert to base62. Simple and unique. Not chosen because: (1) sequential IDs are predictable (security concern — users can enumerate URLs), (2) requires a single counter or distributed counter (coordination overhead).</p>
</div>
<div class="alternative">
<h4>Alternative 2: UUID</h4>
<p>Use a UUID (128-bit), encode in base62 (22 chars). Guaranteed unique. Not chosen because the resulting short URL is too long (defeats the purpose of URL shortening).</p>
</div>
<div class="alternative">
<h4>Alternative 3: Snowflake ID</h4>
<p>64-bit timestamp-based ID, base62 encoded (~11 chars). Time-sortable and unique. Viable alternative, but still produces longer codes than our 7-char target. Could work if we accept slightly longer URLs.</p>
</div>

<h2>Additional Information</h2>
<h3>URL Deduplication</h3>
<p>If Alice shortens the same long URL twice, should she get the same short code? Two approaches: (1) Always generate a new short code (simpler, allows per-link analytics). (2) Check if the long URL already exists and return the existing short code (saves storage, but requires a secondary index on long_url — expensive for long strings). We choose option (1) for simplicity.</p>

<h3>Abuse Prevention</h3>
<p>Short URLs can be used for phishing. Mitigations: (1) Rate limit URL creation per user/IP. (2) Check long URLs against a phishing/malware blocklist (e.g., Google Safe Browsing API) before shortening. (3) Show a preview/interstitial page before redirecting for suspicious URLs.</p>

<h3>Cleanup Job</h3>
<p>A periodic background job scans for expired URLs (where <code>expires_at &lt; now()</code>) and soft-deletes them. This frees up storage and eventually returns the short codes to the key pool for reuse (after a quarantine period to avoid confusion).</p>
</div>
</body>
</html>
