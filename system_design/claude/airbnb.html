<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>System Design: Airbnb</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        :root {
            --bg: #0d1117;
            --surface: #161b22;
            --border: #30363d;
            --text: #e6edf3;
            --text-muted: #8b949e;
            --accent: #ff5a5f;
            --accent2: #00a699;
            --accent3: #fc642d;
            --link: #58a6ff;
            --code-bg: #1c2129;
            --table-header: #1c2533;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            line-height: 1.7;
            padding: 0;
        }
        .container { max-width: 1100px; margin: 0 auto; padding: 40px 32px; }
        h1 {
            font-size: 2.6em;
            margin-bottom: 8px;
            background: linear-gradient(135deg, var(--accent), var(--accent3));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .subtitle { color: var(--text-muted); font-size: 1.1em; margin-bottom: 48px; }
        h2 {
            font-size: 1.8em;
            color: var(--accent);
            margin-top: 56px;
            margin-bottom: 20px;
            padding-bottom: 8px;
            border-bottom: 2px solid var(--border);
        }
        h3 {
            font-size: 1.35em;
            color: var(--accent2);
            margin-top: 32px;
            margin-bottom: 14px;
        }
        h4 {
            font-size: 1.1em;
            color: var(--accent3);
            margin-top: 24px;
            margin-bottom: 10px;
        }
        p { margin-bottom: 14px; }
        ul, ol { margin-left: 24px; margin-bottom: 14px; }
        li { margin-bottom: 6px; }
        code {
            background: var(--code-bg);
            padding: 2px 7px;
            border-radius: 4px;
            font-size: 0.92em;
            font-family: 'SF Mono', 'Fira Code', 'Courier New', monospace;
        }
        pre {
            background: var(--code-bg);
            padding: 16px 20px;
            border-radius: 8px;
            overflow-x: auto;
            margin-bottom: 16px;
            border: 1px solid var(--border);
        }
        pre code { background: none; padding: 0; }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
            font-size: 0.95em;
        }
        th {
            background: var(--table-header);
            padding: 12px 14px;
            text-align: left;
            border: 1px solid var(--border);
            font-weight: 600;
        }
        td {
            padding: 10px 14px;
            border: 1px solid var(--border);
            vertical-align: top;
        }
        tr:nth-child(even) td { background: rgba(255,255,255,0.02); }
        .diagram-container {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 24px;
            margin: 20px 0;
            overflow-x: auto;
        }
        .example-box {
            background: rgba(0, 166, 153, 0.08);
            border-left: 4px solid var(--accent2);
            padding: 16px 20px;
            border-radius: 0 8px 8px 0;
            margin: 16px 0;
        }
        .example-box strong { color: var(--accent2); }
        .warning-box {
            background: rgba(255, 90, 95, 0.08);
            border-left: 4px solid var(--accent);
            padding: 16px 20px;
            border-radius: 0 8px 8px 0;
            margin: 16px 0;
        }
        .info-box {
            background: rgba(88, 166, 255, 0.08);
            border-left: 4px solid var(--link);
            padding: 16px 20px;
            border-radius: 0 8px 8px 0;
            margin: 16px 0;
        }
        .toc {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 24px 28px;
            margin-bottom: 40px;
        }
        .toc h3 { margin-top: 0; color: var(--text); }
        .toc ol { margin-left: 20px; }
        .toc a { color: var(--link); text-decoration: none; }
        .toc a:hover { text-decoration: underline; }
        a { color: var(--link); }
        .mermaid { text-align: center; }
        .badge {
            display: inline-block;
            padding: 3px 10px;
            border-radius: 12px;
            font-size: 0.82em;
            font-weight: 600;
            margin-right: 6px;
        }
        .badge-sql { background: #1f3a5c; color: #58a6ff; }
        .badge-nosql { background: #3a2a1f; color: #fc642d; }
        .badge-pk { background: #1f3a2a; color: #3fb950; }
        .badge-fk { background: #3a1f3a; color: #d2a8ff; }
        .badge-idx { background: #3a3a1f; color: #e3b341; }
    </style>
</head>
<body>
<div class="container">

<h1>System Design: Airbnb</h1>
<p class="subtitle">A comprehensive design for a global property rental marketplace ‚Äî covering listing management, search, booking, reviews, and real-time messaging.</p>

<!-- TABLE OF CONTENTS -->
<div class="toc">
    <h3>Table of Contents</h3>
    <ol>
        <li><a href="#fr">Functional Requirements</a></li>
        <li><a href="#nfr">Non-Functional Requirements</a></li>
        <li><a href="#flow1">Flow 1 ‚Äî Listing Creation (Host)</a></li>
        <li><a href="#flow2">Flow 2 ‚Äî Property Search (Guest)</a></li>
        <li><a href="#flow3">Flow 3 ‚Äî Property Booking (Guest)</a></li>
        <li><a href="#flow4">Flow 4 ‚Äî Review Submission (Guest)</a></li>
        <li><a href="#flow5">Flow 5 ‚Äî Real-Time Messaging (Host ‚Üî Guest)</a></li>
        <li><a href="#combined">Combined Overall Architecture Diagram</a></li>
        <li><a href="#schema">Database Schema</a></li>
        <li><a href="#cdn-cache">CDN &amp; Caching Deep Dive</a></li>
        <li><a href="#scaling">Scaling Considerations</a></li>
        <li><a href="#tradeoffs">Tradeoffs &amp; Deep Dives</a></li>
        <li><a href="#alternatives">Alternative Approaches</a></li>
        <li><a href="#additional">Additional Considerations</a></li>
        <li><a href="#vendors">Vendor Suggestions</a></li>
    </ol>
</div>

<!-- ============================================================== -->
<h2 id="fr">1. Functional Requirements</h2>
<!-- ============================================================== -->
<ol>
    <li><strong>Listing Management</strong> ‚Äî Hosts can create, update, and deactivate property listings including photos, descriptions, amenities, pricing, and house rules.</li>
    <li><strong>Property Search</strong> ‚Äî Guests can search for available properties by location, dates, number of guests, price range, property type, and amenities.</li>
    <li><strong>Booking</strong> ‚Äî Guests can book a property for a date range; the system guarantees no double-booking. Guests can cancel bookings subject to cancellation policy.</li>
    <li><strong>Payments</strong> ‚Äî The system processes payments from guests, holds funds in escrow, and disburses to hosts after checkout (minus platform fee).</li>
    <li><strong>Reviews</strong> ‚Äî After a completed stay, guests can leave a rating and written review for a listing. Hosts can respond.</li>
    <li><strong>Messaging</strong> ‚Äî Guests and hosts can exchange real-time messages within the context of a listing or booking.</li>
    <li><strong>Notifications</strong> ‚Äî Users receive push/email notifications for booking confirmations, cancellations, new messages, and reviews.</li>
    <li><strong>Availability Calendar</strong> ‚Äî Hosts can block/unblock specific dates and set per-night price overrides on their calendar.</li>
</ol>

<!-- ============================================================== -->
<h2 id="nfr">2. Non-Functional Requirements</h2>
<!-- ============================================================== -->
<ol>
    <li><strong>High Availability</strong> ‚Äî The system must be available 99.99% of the time globally. Search and browsing must never go down.</li>
    <li><strong>Low Latency</strong> ‚Äî Search results should return in &lt;200 ms. Listing detail pages in &lt;100 ms. Booking confirmation in &lt;2 s.</li>
    <li><strong>Strong Consistency for Bookings</strong> ‚Äî Booking and payment operations require ACID guarantees. No two guests can book the same listing for overlapping dates.</li>
    <li><strong>Eventual Consistency Acceptable for Search/Reviews</strong> ‚Äî A newly created listing can take a few seconds to appear in search results. A new review can take a few seconds to reflect in the average rating.</li>
    <li><strong>Scalability</strong> ‚Äî Handle ~150 M+ users, ~7 M+ active listings, ~2 M+ bookings per day, and bursty search traffic (holidays, events).</li>
    <li><strong>Data Durability</strong> ‚Äî Zero data loss for bookings and payments. Photos stored with redundancy.</li>
    <li><strong>Security</strong> ‚Äî Encrypted data in transit (TLS) and at rest. PCI-DSS compliance for payment data.</li>
    <li><strong>Global Distribution</strong> ‚Äî Low latency for users worldwide through CDNs and regional deployments.</li>
</ol>

<!-- ============================================================== -->
<h2 id="flow1">3. Flow 1 ‚Äî Listing Creation (Host)</h2>
<!-- ============================================================== -->
<p>This flow covers a host creating a new property listing, uploading photos, and making it discoverable in search.</p>

<div class="diagram-container">
    <div class="mermaid">
graph LR
    A["üè† Host Client<br/>(Mobile / Web)"] -->|"HTTP POST<br/>/api/listings"| B["API Gateway"]
    B --> C["Listing Service"]
    C -->|"Write listing<br/>metadata"| D[("Listing DB<br/>(SQL)")]
    C -->|"Upload photos"| E["Object Storage"]
    E -->|"Distribute"| F["CDN"]
    C -->|"Publish<br/>listing_created event"| G["Message Queue"]
    G --> H["Search Index<br/>Updater"]
    H -->|"Index listing"| I[("Search Index")]
    G --> J["Notification<br/>Service"]
    J -->|"Confirmation"| K["Push / Email"]
    </div>
</div>

<h3>Examples</h3>

<div class="example-box">
    <strong>Example 1 ‚Äî Happy Path:</strong> Host Jane opens the Airbnb app and taps "Create Listing." She fills in the property title ("Cozy Beach House in Malibu"), description, property type (House), address, amenities (WiFi, Pool, Kitchen), sets the price to $250/night with a $75 cleaning fee, and uploads 12 photos. When she taps "Publish," the client sends an HTTP POST to <code>/api/listings</code> through the API Gateway. The Listing Service validates the data, writes the listing metadata to the Listing DB (SQL), and uploads the 12 photos to Object Storage (which are then distributed to the CDN for fast global access). The Listing Service then publishes a <code>listing_created</code> event onto the Message Queue. The Search Index Updater consumer picks up the event, transforms the listing data, and indexes it in the Search Index with geo-coordinates, amenities, and pricing. Within a few seconds, Jane's beach house is searchable by guests worldwide. Jane also receives a push notification confirming her listing is live.
</div>

<div class="example-box">
    <strong>Example 2 ‚Äî Large Photo Upload with Retry:</strong> Host Carlos creates a luxury villa listing and uploads 30 high-resolution photos. The client uses multipart upload to send photos to the Listing Service, which streams them to Object Storage. If a photo upload fails mid-transfer due to network issues, the client retries just the failed photo (resumable upload). The listing metadata is saved first, and photos are added incrementally. The search index is updated once all photos are confirmed uploaded, so the listing appears in search results with its complete photo gallery.
</div>

<div class="example-box">
    <strong>Example 3 ‚Äî Listing Update:</strong> Host Jane decides to raise her price from $250 to $300/night. She edits the listing and taps "Save." The client sends an HTTP PATCH to <code>/api/listings/{listing_id}</code>. The Listing Service updates the row in the Listing DB and publishes a <code>listing_updated</code> event to the Message Queue. The Search Index Updater re-indexes the listing with the new price. The CDN cache for this listing's detail page is invalidated. Within a few seconds, search results reflect the new price.
</div>

<h3>Component Deep Dive</h3>

<h4>Host Client (Mobile / Web)</h4>
<p>Native iOS/Android apps or web browser. Responsible for the listing creation form, photo capture/selection, and multipart file upload. Communicates over HTTPS (TLS 1.3 over TCP).</p>

<h4>API Gateway</h4>
<p>Single entry point for all client requests. Handles authentication (JWT validation), rate limiting, request routing, and TLS termination. Routes listing-related requests to the Listing Service. Protocol: HTTPS (HTTP/2 over TLS).</p>

<h4>Listing Service</h4>
<p>Core microservice responsible for CRUD operations on listings.</p>
<table>
    <tr><th>Endpoint</th><th>Method</th><th>Input</th><th>Output</th></tr>
    <tr>
        <td><code>/api/listings</code></td>
        <td>POST</td>
        <td>JSON body: title, description, property_type, address, lat/lng, price_per_night, cleaning_fee, max_guests, num_bedrooms, num_bathrooms, amenity_ids[], house_rules. Multipart: photo files.</td>
        <td>201 Created ‚Äî <code>{ listing_id, status, created_at }</code></td>
    </tr>
    <tr>
        <td><code>/api/listings/{id}</code></td>
        <td>PATCH</td>
        <td>JSON body: any subset of listing fields to update.</td>
        <td>200 OK ‚Äî <code>{ listing_id, updated_fields }</code></td>
    </tr>
    <tr>
        <td><code>/api/listings/{id}</code></td>
        <td>GET</td>
        <td>Path param: listing_id</td>
        <td>200 OK ‚Äî Full listing object with photos, amenities, host info, avg_rating, reviews summary.</td>
    </tr>
    <tr>
        <td><code>/api/listings/{id}</code></td>
        <td>DELETE</td>
        <td>Path param: listing_id</td>
        <td>200 OK ‚Äî <code>{ listing_id, status: "deactivated" }</code> (soft delete)</td>
    </tr>
</table>
<p>Internal protocol to DB: SQL over TCP. Internal protocol to Object Storage: proprietary SDK over HTTPS. Publishes events to the Message Queue via an async producer.</p>

<h4>Listing DB (SQL)</h4>
<p>Relational database storing all listing metadata, amenities, and photo references. SQL is chosen for its ACID guarantees and complex relational queries (joins between listings, amenities, and photos). See <a href="#schema">Schema section</a> for full table definitions.</p>

<h4>Object Storage</h4>
<p>Distributed object storage for listing photos. Each photo is stored with a unique key (e.g., <code>listings/{listing_id}/photos/{photo_id}.webp</code>). Photos are converted to multiple sizes (thumbnail 200px, medium 800px, large 1600px) by an image processing pipeline triggered on upload. Provides high durability (11 nines) and availability.</p>

<h4>CDN (Content Delivery Network)</h4>
<p>Caches listing photos at edge locations worldwide. When a guest views a listing, photos are served from the nearest CDN edge node rather than from the origin Object Storage, reducing latency to &lt;50 ms globally. See <a href="#cdn-cache">CDN &amp; Caching section</a> for strategy details.</p>

<h4>Message Queue</h4>
<p>Asynchronous event bus that decouples the Listing Service from downstream consumers. When a listing is created or updated, the Listing Service publishes an event (e.g., <code>listing_created</code>, <code>listing_updated</code>) to a topic on the queue. Multiple consumers subscribe to these topics independently. Uses at-least-once delivery with consumer-side idempotency. See <a href="#mq-deepdive">Message Queue deep dive</a> for full details.</p>

<h4>Search Index Updater</h4>
<p>Consumer that subscribes to listing events from the Message Queue. Transforms listing data into the search index schema (geo-coordinates, text fields, facets for amenities, price ranges) and upserts into the Search Index. Handles retries on index write failures. Runs as a horizontally scalable worker pool.</p>

<h4>Search Index</h4>
<p>A dedicated full-text and geo-spatial search engine optimized for multi-faceted queries. Supports geo-bounding-box queries, range filters (price, guests), faceted search (amenities, property type), and full-text search on title/description. Updated asynchronously ‚Äî eventual consistency with a typical lag of 1-3 seconds.</p>

<!-- ============================================================== -->
<h2 id="flow2">4. Flow 2 ‚Äî Property Search (Guest)</h2>
<!-- ============================================================== -->
<p>This flow covers a guest searching for available properties by location, dates, and filters.</p>

<div class="diagram-container">
    <div class="mermaid">
graph LR
    A["üîç Guest Client<br/>(Mobile / Web)"] -->|"HTTP GET<br/>/api/search"| B["API Gateway"]
    B --> C["Search Service"]
    C -->|"Check cache"| D["In-Memory Cache"]
    D -.->|"Cache miss"| E[("Search Index")]
    E -->|"Results"| C
    C -->|"Hydrate listing<br/>details"| F[("Listing DB<br/>(SQL)")]
    C -->|"Check availability<br/>for date range"| G[("Booking DB /<br/>Availability Table<br/>(SQL)")]
    C -->|"Paginated results"| B
    B --> A
    A -->|"Load images"| H["CDN"]
    </div>
</div>

<h3>Examples</h3>

<div class="example-box">
    <strong>Example 1 ‚Äî Standard Search:</strong> Guest Mike opens the Airbnb app and types "Paris" in the search bar, selects check-in March 15 and check-out March 20, 2 guests. He taps "Search." The client sends an HTTP GET to <code>/api/search?location=Paris&check_in=2025-03-15&check_out=2025-03-20&guests=2</code> through the API Gateway. The Search Service first checks the In-Memory Cache for this exact query. Cache miss ‚Äî it then queries the Search Index with a geo-bounding-box around Paris (lat/lng obtained by geocoding "Paris"), filtered by max_guests ‚â• 2 and status = active. The Search Index returns 2,400 matching listing IDs ranked by relevance. The Search Service takes the first page (20 results), hydrates them with listing details (title, price, thumbnail URL, avg_rating) from the Listing DB (or cache), and checks the Availability Table to confirm each listing is available for March 15-20. The response returns 18 available listings with pagination metadata. The client loads listing thumbnail images from the CDN. Total response time: ~120 ms.
</div>

<div class="example-box">
    <strong>Example 2 ‚Äî Filtered Search with Amenities:</strong> Guest Sarah searches "Tokyo" for 4 guests with filters: "Entire place," price $50-$150, amenities: WiFi, Kitchen, Washer. The Search Service queries the Search Index with the geo-bounding-box for Tokyo, property_type = "entire_place", price_per_night between 50-150, and required amenity facets. The Search Index uses its inverted index on amenities to intersect results efficiently. 340 results match. The first 20 are returned.
</div>

<div class="example-box">
    <strong>Example 3 ‚Äî Map-Based Search (Bounding Box):</strong> Guest Alex is viewing the map view and pans/zooms to a specific area of Barcelona. The client sends the visible map's bounding box coordinates (top-left lat/lng, bottom-right lat/lng) as query parameters. The Search Service queries the Search Index with this exact bounding box rather than geocoding a city name. Results are returned for all listings within the visible map area. As Alex pans the map, new requests are debounced (300 ms) and sent for the updated bounding box.
</div>

<div class="example-box">
    <strong>Example 4 ‚Äî No Results Found:</strong> Guest Pat searches "Remote Island" for 10 guests with extremely specific filters. The Search Index returns 0 results. The Search Service returns an empty result set with a suggestion: "No exact matches. Try expanding your search area or adjusting filters." The client UI shows a prompt to broaden the search radius.
</div>

<h3>Component Deep Dive</h3>

<h4>Search Service</h4>
<p>Stateless microservice that orchestrates search queries. It geocodes text locations to lat/lng (using a Geocoding Service or cached geocode mappings), constructs the search query with all filters, queries the Search Index, hydrates results from the Listing DB or cache, and paginates the response.</p>
<table>
    <tr><th>Endpoint</th><th>Method</th><th>Input</th><th>Output</th></tr>
    <tr>
        <td><code>/api/search</code></td>
        <td>GET</td>
        <td>Query params: location (text or lat/lng bounding box), check_in, check_out, guests, min_price, max_price, property_type, amenity_ids[], page, page_size, sort_by (relevance, price_asc, price_desc, rating).</td>
        <td>200 OK ‚Äî <code>{ results: [{ listing_id, title, thumbnail_url, price_per_night, avg_rating, property_type, lat, lng }], total_count, page, page_size, has_next }</code></td>
    </tr>
</table>

<h4>In-Memory Cache</h4>
<p>Caches search results for frequently queried location + date + guest combinations. For instance, "Paris, March 15-20, 2 guests" is likely queried hundreds of times per minute. See <a href="#cdn-cache">CDN &amp; Caching section</a> for eviction and expiration strategies.</p>

<h4>Geocoding (Internal Sub-component)</h4>
<p>Translates location text ("Paris," "Malibu Beach") into a lat/lng bounding box. Results are cached aggressively since city/neighborhood boundaries rarely change. Could be a third-party API or an internal service with a pre-built gazetteer.</p>

<!-- ============================================================== -->
<h2 id="flow3">5. Flow 3 ‚Äî Property Booking (Guest)</h2>
<!-- ============================================================== -->
<p>This flow covers the critical booking path including availability checking, payment processing, and double-booking prevention.</p>

<div class="diagram-container">
    <div class="mermaid">
graph LR
    A["üí≥ Guest Client<br/>(Mobile / Web)"] -->|"HTTP POST<br/>/api/bookings"| B["API Gateway"]
    B --> C["Booking Service"]
    C -->|"1. BEGIN TXN<br/>SELECT ... FOR UPDATE<br/>on availability rows"| D[("Booking DB /<br/>Availability<br/>(SQL)")]
    D -->|"2. Dates available ‚úì"| C
    C -->|"3. Authorize<br/>payment"| E["Payment Service"]
    E -->|"Charge"| F["External Payment<br/>Provider"]
    F -->|"Payment OK ‚úì"| E
    E -->|"Payment confirmed"| C
    C -->|"4. Insert booking<br/>Mark dates unavailable<br/>COMMIT TXN"| D
    C -->|"5. Publish<br/>booking_confirmed"| G["Message Queue"]
    G --> H["Notification<br/>Service"]
    H -->|"Host + Guest<br/>notifications"| I["Push / Email"]
    G --> J["Search Index<br/>Updater"]
    J -->|"Update availability<br/>in index"| K[("Search Index")]
    C -->|"Booking confirmed"| B
    B --> A
    </div>
</div>

<h3>Examples</h3>

<div class="example-box">
    <strong>Example 1 ‚Äî Happy Path:</strong> Guest Mike finds "Cozy Beach House in Malibu" and selects March 15-20 for 2 guests. He clicks "Reserve" and enters his payment information. The client sends an HTTP POST to <code>/api/bookings</code> with <code>{ listing_id, check_in: "2025-03-15", check_out: "2025-03-20", guests: 2, payment_method_id }</code>. The Booking Service begins a database transaction. It executes <code>SELECT ... FOR UPDATE</code> on the Availability table for listing_id + dates March 15-19 (5 nights). All 5 rows show <code>is_available = true</code> ‚Äî the dates are free. The Booking Service then calls the Payment Service to authorize $1,325 ($250√ó5 nights + $75 cleaning fee). The external payment provider approves the charge. The Booking Service inserts a new row in the Bookings table (status = confirmed), sets the 5 availability rows to <code>is_available = false</code>, and commits the transaction. A <code>booking_confirmed</code> event is published to the Message Queue. The Notification Service sends a push notification to host Jane ("New booking! Mike is staying March 15-20") and a confirmation email to Mike. The Search Index Updater removes March 15-20 from the available dates for this listing so future searches correctly exclude those dates. The client shows a "Booking Confirmed!" screen with the booking details.
</div>

<div class="example-box">
    <strong>Example 2 ‚Äî Double-Booking Prevention:</strong> Guest Mike and Guest Sarah both try to book the same Malibu beach house for March 15-20 at nearly the same instant. Mike's request arrives first. The Booking Service begins a transaction and acquires a row-level lock (<code>SELECT ... FOR UPDATE</code>) on the 5 availability rows. Sarah's request arrives 50 ms later and tries the same <code>SELECT ... FOR UPDATE</code> ‚Äî it blocks, waiting for Mike's transaction to complete. Mike's payment is authorized, the booking is committed, and the availability rows are now <code>is_available = false</code>. The lock is released. Sarah's transaction proceeds and now reads <code>is_available = false</code> for those dates. The Booking Service returns an HTTP 409 Conflict to Sarah: "Sorry, these dates are no longer available." Sarah sees a message suggesting she try different dates.
</div>

<div class="example-box">
    <strong>Example 3 ‚Äî Payment Failure:</strong> Guest Alex tries to book a listing but his credit card is declined by the external payment provider. The Booking Service receives the payment failure, does NOT insert a booking row, rolls back the transaction (the availability rows remain <code>is_available = true</code>), and returns an HTTP 402 Payment Required to Alex: "Payment failed. Please try another payment method." No notifications are sent. No availability changes are made.
</div>

<div class="example-box">
    <strong>Example 4 ‚Äî Guest Cancellation:</strong> Guest Mike cancels his confirmed booking 10 days before check-in. The client sends an HTTP PATCH to <code>/api/bookings/{booking_id}</code> with <code>{ status: "cancelled_by_guest" }</code>. The Booking Service checks the listing's cancellation policy (e.g., "Full refund if cancelled 7+ days before check-in"). Since Mike is cancelling 10 days early, a full refund applies. The Booking Service updates the booking status to <code>cancelled_by_guest</code>, marks the 5 availability dates as <code>is_available = true</code> again, and triggers a refund through the Payment Service. A <code>booking_cancelled</code> event is published. Host Jane is notified that the booking was cancelled. The Search Index is updated so those dates appear available again.
</div>

<h3>Component Deep Dive</h3>

<h4>Booking Service</h4>
<p>The most critical service in the system. Manages the full booking lifecycle: creation, confirmation, cancellation, and completion. Uses pessimistic locking (<code>SELECT ... FOR UPDATE</code>) within a database transaction to prevent double-bookings.</p>
<table>
    <tr><th>Endpoint</th><th>Method</th><th>Input</th><th>Output</th></tr>
    <tr>
        <td><code>/api/bookings</code></td>
        <td>POST</td>
        <td>JSON body: listing_id, check_in, check_out, guests, payment_method_id</td>
        <td>201 Created ‚Äî <code>{ booking_id, status, total_price, check_in, check_out }</code><br/>409 Conflict ‚Äî dates unavailable<br/>402 Payment Required ‚Äî payment failed</td>
    </tr>
    <tr>
        <td><code>/api/bookings/{id}</code></td>
        <td>GET</td>
        <td>Path param: booking_id</td>
        <td>200 OK ‚Äî full booking details</td>
    </tr>
    <tr>
        <td><code>/api/bookings/{id}</code></td>
        <td>PATCH</td>
        <td>JSON body: status (cancelled_by_guest, cancelled_by_host)</td>
        <td>200 OK ‚Äî <code>{ booking_id, status, refund_amount }</code></td>
    </tr>
    <tr>
        <td><code>/api/users/{id}/bookings</code></td>
        <td>GET</td>
        <td>Path param: user_id. Query params: status, page, page_size</td>
        <td>200 OK ‚Äî paginated list of user's bookings</td>
    </tr>
</table>

<h4>Payment Service</h4>
<p>Handles all financial transactions. Communicates with external payment providers over HTTPS. Supports authorization (hold funds), capture (charge), and refund operations. Payment data is stored in a PCI-DSS compliant manner ‚Äî the Payment Service only stores tokenized payment references, not raw card numbers.</p>
<table>
    <tr><th>Endpoint</th><th>Method</th><th>Input</th><th>Output</th></tr>
    <tr>
        <td><code>/internal/payments/authorize</code></td>
        <td>POST</td>
        <td>JSON body: booking_id, amount, currency, payment_method_token</td>
        <td>200 OK ‚Äî <code>{ payment_id, status: "authorized" }</code><br/>402 ‚Äî payment declined</td>
    </tr>
    <tr>
        <td><code>/internal/payments/{id}/capture</code></td>
        <td>POST</td>
        <td>Path param: payment_id</td>
        <td>200 OK ‚Äî <code>{ payment_id, status: "captured" }</code></td>
    </tr>
    <tr>
        <td><code>/internal/payments/{id}/refund</code></td>
        <td>POST</td>
        <td>Path param: payment_id. JSON body: refund_amount</td>
        <td>200 OK ‚Äî <code>{ payment_id, status: "refunded", refund_amount }</code></td>
    </tr>
</table>
<p>Note: The Payment Service is an <em>internal</em> service ‚Äî not directly accessible to clients. Only the Booking Service calls it. Protocol: gRPC over TLS for low-latency internal communication.</p>

<h4>External Payment Provider</h4>
<p>Third-party payment processor. The Payment Service abstracts this behind a consistent interface, allowing the provider to be swapped out. Communication: HTTPS REST API.</p>

<!-- ============================================================== -->
<h2 id="flow4">6. Flow 4 ‚Äî Review Submission (Guest)</h2>
<!-- ============================================================== -->
<p>This flow covers a guest leaving a review after a completed stay.</p>

<div class="diagram-container">
    <div class="mermaid">
graph LR
    A["‚≠ê Guest Client<br/>(Mobile / Web)"] -->|"HTTP POST<br/>/api/reviews"| B["API Gateway"]
    B --> C["Review Service"]
    C -->|"Validate:<br/>booking completed?<br/>review exists?"| D[("Booking DB<br/>(SQL)")]
    C -->|"Write review"| E[("Review DB<br/>(SQL)")]
    C -->|"Publish<br/>review_submitted"| F["Message Queue"]
    F --> G["Rating<br/>Aggregator"]
    G -->|"Update avg_rating<br/>& review_count"| H[("Listing DB<br/>(SQL)")]
    G -->|"Update search<br/>index rating"| I[("Search Index")]
    F --> J["Notification<br/>Service"]
    J -->|"Notify host"| K["Push / Email"]
    </div>
</div>

<h3>Examples</h3>

<div class="example-box">
    <strong>Example 1 ‚Äî Happy Path:</strong> Guest Mike completes his stay at the Malibu beach house (check-out was March 20). He opens the app and sees a prompt: "How was your stay at Cozy Beach House?" He gives an overall rating of 5 stars, rates cleanliness (5), accuracy (4), communication (5), location (5), value (4), and writes: "Amazing beachfront property! Jane was a great host." He taps "Submit Review." The client sends an HTTP POST to <code>/api/reviews</code> with <code>{ booking_id, listing_id, rating: 5, cleanliness_rating: 5, accuracy_rating: 4, communication_rating: 5, location_rating: 5, value_rating: 4, comment: "..." }</code>. The Review Service first validates that (a) the booking exists and is in "completed" status, and (b) no review already exists for this booking_id (one review per booking). Validation passes. The review is written to the Review DB. A <code>review_submitted</code> event is published to the Message Queue. The Rating Aggregator consumer recalculates the listing's average rating (was 4.7 from 45 reviews, now 4.71 with 46 reviews) and updates the <code>avg_rating</code> and <code>review_count</code> fields in the Listing DB. The Search Index is also updated with the new rating. Host Jane receives a push notification: "Mike left you a 5-star review!"
</div>

<div class="example-box">
    <strong>Example 2 ‚Äî Duplicate Review Attempt:</strong> Guest Mike tries to submit a second review for the same booking. The Review Service queries the Review DB and finds that a review with <code>booking_id = X</code> already exists (the <code>booking_id</code> column has a UNIQUE constraint). The service returns an HTTP 409 Conflict: "You have already reviewed this booking."
</div>

<div class="example-box">
    <strong>Example 3 ‚Äî Unauthorized Review Attempt:</strong> Guest Sarah tries to review a listing she hasn't stayed at. She sends a POST with a <code>booking_id</code> that either doesn't exist or belongs to a different user. The Review Service validates the booking and finds a mismatch. It returns an HTTP 403 Forbidden: "You can only review a completed stay."
</div>

<h3>Component Deep Dive</h3>

<h4>Review Service</h4>
<table>
    <tr><th>Endpoint</th><th>Method</th><th>Input</th><th>Output</th></tr>
    <tr>
        <td><code>/api/reviews</code></td>
        <td>POST</td>
        <td>JSON body: booking_id, listing_id, rating (1-5), cleanliness_rating, accuracy_rating, communication_rating, location_rating, value_rating, comment.</td>
        <td>201 Created ‚Äî <code>{ review_id, listing_id, created_at }</code><br/>409 Conflict ‚Äî already reviewed<br/>403 Forbidden ‚Äî not authorized</td>
    </tr>
    <tr>
        <td><code>/api/listings/{id}/reviews</code></td>
        <td>GET</td>
        <td>Path param: listing_id. Query params: page, page_size, sort_by (newest, highest, lowest).</td>
        <td>200 OK ‚Äî <code>{ reviews: [...], avg_rating, review_count, rating_distribution: { 5: 30, 4: 12, ... } }</code></td>
    </tr>
</table>

<h4>Rating Aggregator</h4>
<p>An asynchronous consumer that processes <code>review_submitted</code> events. It recalculates the listing's average rating and updates both the Listing DB (<code>avg_rating</code>, <code>review_count</code> columns ‚Äî denormalized for read performance) and the Search Index. This is a form of <strong>denormalization</strong> ‚Äî storing the computed average in the listing row itself rather than computing it with a JOIN + AVG() query every time a listing detail page is loaded. This is justified because reviews are written infrequently (once per completed booking) but the average rating is read millions of times (every search result, every listing page).</p>

<!-- ============================================================== -->
<h2 id="flow5">7. Flow 5 ‚Äî Real-Time Messaging (Host ‚Üî Guest)</h2>
<!-- ============================================================== -->
<p>This flow covers real-time chat between hosts and guests, using WebSockets for instant delivery.</p>

<div class="diagram-container">
    <div class="mermaid">
graph LR
    A["üí¨ Sender Client"] -->|"WebSocket<br/>Connection"| B["WebSocket<br/>Gateway<br/>(Server A)"]
    B -->|"Forward<br/>message"| C["Message<br/>Service"]
    C -->|"Persist"| D[("Message Store<br/>(NoSQL)")]
    C -->|"Lookup recipient<br/>connection"| E[("Connection<br/>Registry<br/>(In-Memory Cache)")]
    E -->|"Recipient on<br/>Server B"| C
    C -->|"Route message"| F["WebSocket<br/>Gateway<br/>(Server B)"]
    F -->|"WebSocket<br/>push"| G["üì± Recipient Client"]
    C -->|"If recipient<br/>offline"| H["Notification<br/>Service"]
    H --> I["Push Notification"]
    </div>
</div>

<h3>Examples</h3>

<div class="example-box">
    <strong>Example 1 ‚Äî Both Users Online:</strong> Guest Mike wants to ask host Jane a question about her Malibu listing. He opens the messaging tab and types "Hi Jane! Is there parking available at the property?" When Mike opens the messaging screen, his client establishes a WebSocket connection with the WebSocket Gateway (say, Server A). The connection is registered in the Connection Registry: <code>{ user_id: "mike_123" ‚Üí server: "gateway-A", conn_id: "ws-789" }</code>. Jane, who has the app open, already has a WebSocket connection to Server B, registered as <code>{ user_id: "jane_456" ‚Üí server: "gateway-B", conn_id: "ws-321" }</code>. When Mike sends his message, it travels through the WebSocket to Gateway Server A, which forwards it to the Message Service. The Message Service (1) persists the message in the NoSQL Message Store with conversation_id, sender_id, content, and timestamp, (2) looks up Jane's entry in the Connection Registry and finds she's connected to Gateway Server B, (3) routes the message to Gateway Server B, which pushes it to Jane's client via her WebSocket. Jane sees the message appear instantly (&lt;100 ms). The client marks the message as delivered.
</div>

<div class="example-box">
    <strong>Example 2 ‚Äî Recipient Offline:</strong> Guest Mike sends a message but host Jane has closed the app. The Message Service persists the message in the Message Store, looks up Jane in the Connection Registry, and finds no active connection. The Message Service then sends the message payload to the Notification Service, which dispatches a push notification to Jane's device: "Mike: Hi Jane! Is there parking available at the property?" When Jane opens the app later, her client establishes a WebSocket connection and sends an HTTP GET to <code>/api/conversations/{id}/messages?since={last_sync_timestamp}</code> to fetch all messages received while she was offline. The missed messages load into the chat view.
</div>

<div class="example-box">
    <strong>Example 3 ‚Äî Connection Failover:</strong> Mike's WebSocket connection drops due to a network switch. The WebSocket Gateway Server A detects the disconnection via a missed heartbeat (ping/pong interval: 30 seconds, timeout: 10 seconds). Server A removes Mike's entry from the Connection Registry. When Mike's client reconnects (automatic reconnect with exponential backoff), it may connect to a different Gateway server (say, Server C). The new connection is registered in the Connection Registry. Any messages sent during the brief disconnection are fetched via the HTTP sync endpoint.
</div>

<h3>Component Deep Dive</h3>

<h4 id="ws-deepdive">WebSocket Gateway</h4>
<p>A horizontally scaled pool of servers that maintain persistent WebSocket connections with clients. Each server can handle ~100K concurrent WebSocket connections.</p>
<ul>
    <li><strong>Connection Establishment:</strong> Client sends an HTTP Upgrade request (HTTP 1.1 ‚Üí WebSocket). The Gateway authenticates the client using a JWT token in the handshake headers. Upon successful upgrade, a persistent TCP connection is maintained.</li>
    <li><strong>Heartbeat:</strong> The Gateway sends WebSocket ping frames every 30 seconds. If no pong is received within 10 seconds, the connection is considered dead and cleaned up.</li>
    <li><strong>Connection Registry:</strong> A shared In-Memory Cache (key-value store) that maps <code>user_id ‚Üí { gateway_server_id, connection_id, connected_at }</code>. All Gateway servers read/write to this shared registry to locate which server a user is connected to. The registry uses TTL-based expiration (matching the heartbeat timeout) for automatic cleanup of stale entries.</li>
    <li><strong>Protocol:</strong> WebSocket (RFC 6455) over TLS (wss://). Underlying transport: TCP for reliable, ordered delivery.</li>
</ul>
<p><strong>Why WebSocket over alternatives:</strong></p>
<ul>
    <li><strong>vs. Long Polling:</strong> Long polling requires frequent reconnections and is less efficient for bidirectional, frequent messaging. WebSocket maintains a single persistent connection with minimal overhead.</li>
    <li><strong>vs. Server-Sent Events (SSE):</strong> SSE is unidirectional (server ‚Üí client only). Messaging requires bidirectional communication. Would need a separate HTTP channel for client ‚Üí server messages, adding complexity.</li>
    <li><strong>vs. HTTP Short Polling:</strong> Wasteful ‚Äî polling every 1-2 seconds for new messages generates massive unnecessary traffic for most users who receive messages infrequently.</li>
</ul>

<h4>Message Service</h4>
<table>
    <tr><th>Endpoint</th><th>Method</th><th>Input</th><th>Output</th></tr>
    <tr>
        <td>(WebSocket frame)</td>
        <td>‚Äî</td>
        <td>JSON: <code>{ conversation_id, content, message_type }</code></td>
        <td>Acknowledgment frame: <code>{ message_id, status: "delivered" | "sent" }</code></td>
    </tr>
    <tr>
        <td><code>/api/conversations/{id}/messages</code></td>
        <td>GET</td>
        <td>Path: conversation_id. Query: since (timestamp), page_size, cursor.</td>
        <td>200 OK ‚Äî <code>{ messages: [...], cursor_next }</code></td>
    </tr>
    <tr>
        <td><code>/api/conversations</code></td>
        <td>GET</td>
        <td>Query: user_id (from auth token), page, page_size.</td>
        <td>200 OK ‚Äî <code>{ conversations: [{ conversation_id, participants, last_message_preview, last_message_at }] }</code></td>
    </tr>
</table>

<h4>Message Store (NoSQL)</h4>
<p>A wide-column NoSQL store optimized for the messaging access pattern: "get all messages for a conversation, sorted by time." Partition key = <code>conversation_id</code>, sort key = <code>sent_at</code>. This allows efficient range queries for fetching recent messages within a conversation. NoSQL is chosen over SQL because: (1) very high write throughput (millions of messages/day), (2) simple, partition-key-based access pattern with no joins, (3) the data model is naturally key-value / time-series, (4) horizontal scaling via automatic sharding on partition key.</p>

<h4>Connection Registry (In-Memory Cache)</h4>
<p>A shared in-memory key-value store that all WebSocket Gateway servers read from and write to. Key = <code>user_id</code>, Value = <code>{ server_id, connection_id, connected_at }</code>. Operations are simple GET/SET/DELETE with TTL. Sub-millisecond latency is critical here to avoid adding delay to message routing. The cache is replicated for availability.</p>

<!-- ============================================================== -->
<h2 id="combined">8. Combined Overall Architecture Diagram</h2>
<!-- ============================================================== -->
<p>This diagram combines all five flows into a single unified system architecture view.</p>

<div class="diagram-container">
    <div class="mermaid">
graph TB
    subgraph Clients
        MC["üì± Mobile Client<br/>(iOS / Android)"]
        WC["üñ•Ô∏è Web Client<br/>(Browser)"]
    end

    subgraph Edge Layer
        LB["Load Balancer<br/>(Layer 7)"]
        CDN["CDN<br/>(Photos, Static Assets)"]
    end

    subgraph Gateway Layer
        AG["API Gateway<br/>(REST / HTTP)"]
        WSG["WebSocket Gateway<br/>(Pool of Servers)"]
    end

    subgraph Core Services
        LS["Listing<br/>Service"]
        SS["Search<br/>Service"]
        BS["Booking<br/>Service"]
        RS["Review<br/>Service"]
        MS["Message<br/>Service"]
        PS["Payment<br/>Service"]
        NS["Notification<br/>Service"]
    end

    subgraph Async Workers
        SIU["Search Index<br/>Updater"]
        RA["Rating<br/>Aggregator"]
    end

    subgraph Data Stores
        LDB[("Listing DB<br/>(SQL)")]
        BDB[("Booking DB /<br/>Availability<br/>(SQL)")]
        RDB[("Review DB<br/>(SQL)")]
        MST[("Message Store<br/>(NoSQL)")]
        SI[("Search Index")]
        OS["Object<br/>Storage"]
        CR[("Connection<br/>Registry<br/>(Cache)")]
    end

    subgraph Caching Layer
        RC["In-Memory<br/>Cache"]
    end

    MQ["Message Queue<br/>(Pub/Sub Topics)"]

    MC & WC --> LB
    MC & WC --> CDN
    MC & WC -.->|"WebSocket"| WSG
    LB --> AG
    AG --> LS & SS & BS & RS
    WSG --> MS

    LS --> LDB
    LS --> OS
    OS --> CDN
    SS --> RC
    SS --> SI
    SS --> LDB
    SS --> BDB
    BS --> BDB
    BS --> PS
    PS -->|"HTTPS"| EXT["External Payment<br/>Provider"]
    RS --> RDB
    RS --> BDB
    MS --> MST
    MS --> CR
    MS --> WSG

    LS & BS & RS -->|"Events"| MQ
    MQ --> SIU & RA & NS
    SIU --> SI
    RA --> LDB
    RA --> SI
    NS -->|"Push / Email / SMS"| MC & WC
    MS -.->|"If offline"| NS
    </div>
</div>

<h3>Combined Flow Examples</h3>

<div class="example-box">
    <strong>Example 1 ‚Äî Full Booking Journey:</strong> Guest Mike opens the Airbnb app on his iPhone. His requests hit the Load Balancer, which routes to the API Gateway. He searches for "Malibu" (Search Service queries the Search Index and In-Memory Cache, hydrates from the Listing DB). He browses listings ‚Äî images load from the CDN. He views the "Cozy Beach House" listing detail page (Listing Service reads from Listing DB, reviews from Review DB). He sends host Jane a message asking about parking ‚Äî his WebSocket connection goes through the WebSocket Gateway ‚Üí Message Service ‚Üí Message Store (NoSQL), and the message is routed to Jane via her WebSocket connection found in the Connection Registry. Jane responds in real-time. Mike then books March 15-20 ‚Äî the Booking Service acquires a lock on availability rows, the Payment Service authorizes $1,325 via the external provider, the booking is confirmed, and a <code>booking_confirmed</code> event flows through the Message Queue to the Notification Service (which pushes notifications to both Mike and Jane) and the Search Index Updater (which marks those dates unavailable). After his stay, Mike leaves a 5-star review ‚Äî the Review Service writes to the Review DB, and the Rating Aggregator updates the listing's average rating in the Listing DB and Search Index.
</div>

<div class="example-box">
    <strong>Example 2 ‚Äî Host Listing &amp; Booking Management:</strong> Host Jane creates a new listing on her laptop (Web Client ‚Üí Load Balancer ‚Üí API Gateway ‚Üí Listing Service). Photos are uploaded to Object Storage and propagated to the CDN. A <code>listing_created</code> event flows through the Message Queue to the Search Index Updater. Later, Jane receives a booking notification (Message Queue ‚Üí Notification Service ‚Üí Push). She opens the app and messages the guest via WebSocket. After the guest's stay, she receives a review notification and sees her updated average rating ‚Äî all flowing through the async workers (Rating Aggregator) and eventually reflected in search results.
</div>

<!-- ============================================================== -->
<h2 id="schema">9. Database Schema</h2>
<!-- ============================================================== -->

<h3>SQL Tables</h3>

<h4>9.1 users</h4>
<table>
    <tr><th>Column</th><th>Type</th><th>Constraints</th><th>Notes</th></tr>
    <tr><td><span class="badge badge-pk">PK</span> user_id</td><td>UUID</td><td>PRIMARY KEY</td><td>Globally unique identifier</td></tr>
    <tr><td>email</td><td>VARCHAR(255)</td><td>UNIQUE, NOT NULL</td><td>Login identifier</td></tr>
    <tr><td>password_hash</td><td>VARCHAR(255)</td><td>NOT NULL</td><td>bcrypt hash</td></tr>
    <tr><td>first_name</td><td>VARCHAR(100)</td><td>NOT NULL</td><td></td></tr>
    <tr><td>last_name</td><td>VARCHAR(100)</td><td>NOT NULL</td><td></td></tr>
    <tr><td>phone</td><td>VARCHAR(20)</td><td></td><td>Optional, for 2FA</td></tr>
    <tr><td>profile_photo_url</td><td>VARCHAR(512)</td><td></td><td>Points to Object Storage via CDN</td></tr>
    <tr><td>is_host</td><td>BOOLEAN</td><td>DEFAULT false</td><td>Whether user has hosting enabled</td></tr>
    <tr><td>created_at</td><td>TIMESTAMP</td><td>NOT NULL</td><td></td></tr>
    <tr><td>updated_at</td><td>TIMESTAMP</td><td>NOT NULL</td><td></td></tr>
</table>
<p><span class="badge badge-idx">INDEX</span> <strong>Hash index on <code>email</code></strong> ‚Äî Exact-match lookups during login. Hash index is ideal for equality queries (no range scans needed on email).</p>
<p><strong>Why SQL:</strong> User data is highly relational (referenced by listings, bookings, reviews, messages). ACID guarantees are essential for account operations (e.g., email uniqueness). Low write volume; read-heavy.</p>
<p><strong>Read events:</strong> Login, profile page view, displaying host info on a listing, displaying guest info on a booking.<br/>
<strong>Write events:</strong> User registration, profile update.</p>

<h4>9.2 listings</h4>
<table>
    <tr><th>Column</th><th>Type</th><th>Constraints</th><th>Notes</th></tr>
    <tr><td><span class="badge badge-pk">PK</span> listing_id</td><td>UUID</td><td>PRIMARY KEY</td><td></td></tr>
    <tr><td><span class="badge badge-fk">FK</span> host_id</td><td>UUID</td><td>NOT NULL, FK ‚Üí users.user_id</td><td></td></tr>
    <tr><td>title</td><td>VARCHAR(200)</td><td>NOT NULL</td><td></td></tr>
    <tr><td>description</td><td>TEXT</td><td></td><td></td></tr>
    <tr><td>property_type</td><td>ENUM</td><td>NOT NULL</td><td>apartment, house, villa, cabin, etc.</td></tr>
    <tr><td>latitude</td><td>DECIMAL(10,7)</td><td>NOT NULL</td><td></td></tr>
    <tr><td>longitude</td><td>DECIMAL(10,7)</td><td>NOT NULL</td><td></td></tr>
    <tr><td>address</td><td>VARCHAR(500)</td><td>NOT NULL</td><td>Full street address (visible post-booking)</td></tr>
    <tr><td>city</td><td>VARCHAR(100)</td><td>NOT NULL</td><td></td></tr>
    <tr><td>state</td><td>VARCHAR(100)</td><td></td><td></td></tr>
    <tr><td>country</td><td>VARCHAR(100)</td><td>NOT NULL</td><td></td></tr>
    <tr><td>price_per_night</td><td>DECIMAL(10,2)</td><td>NOT NULL</td><td>Base price in USD</td></tr>
    <tr><td>cleaning_fee</td><td>DECIMAL(10,2)</td><td>DEFAULT 0</td><td></td></tr>
    <tr><td>max_guests</td><td>INT</td><td>NOT NULL</td><td></td></tr>
    <tr><td>num_bedrooms</td><td>INT</td><td>NOT NULL</td><td></td></tr>
    <tr><td>num_bathrooms</td><td>INT</td><td>NOT NULL</td><td></td></tr>
    <tr><td>status</td><td>ENUM</td><td>NOT NULL, DEFAULT 'active'</td><td>active, inactive, under_review</td></tr>
    <tr><td>avg_rating</td><td>DECIMAL(3,2)</td><td>DEFAULT 0</td><td><strong>Denormalized</strong> ‚Äî updated async by Rating Aggregator</td></tr>
    <tr><td>review_count</td><td>INT</td><td>DEFAULT 0</td><td><strong>Denormalized</strong> ‚Äî updated async by Rating Aggregator</td></tr>
    <tr><td>created_at</td><td>TIMESTAMP</td><td>NOT NULL</td><td></td></tr>
    <tr><td>updated_at</td><td>TIMESTAMP</td><td>NOT NULL</td><td></td></tr>
</table>
<p><span class="badge badge-idx">INDEX</span> <strong>B-tree index on <code>host_id</code></strong> ‚Äî Retrieve all listings for a host (range scan). B-tree supports efficient range queries on the FK.</p>
<p><span class="badge badge-idx">INDEX</span> <strong>R-tree (geo-spatial) index on <code>(latitude, longitude)</code></strong> ‚Äî Power geo-spatial bounding-box and nearest-neighbor queries. The R-tree index organizes points in a multi-dimensional spatial structure, enabling efficient "find all listings within this rectangle" queries that are core to map-based search. Note: The primary search path uses the dedicated Search Index, but this R-tree index serves as a fallback and supports the Listing Service's direct geo-queries.</p>
<p><span class="badge badge-idx">INDEX</span> <strong>Composite B-tree index on <code>(status, city)</code></strong> ‚Äî Optimizes queries like "all active listings in Paris." Putting <code>status</code> first allows efficient filtering of only active listings.</p>

<div class="info-box">
    <strong>Denormalization Explanation:</strong> The <code>avg_rating</code> and <code>review_count</code> fields are denormalized from the reviews table into the listings table. Without this, every listing detail page and every search result would require a <code>JOIN</code> to the reviews table with an <code>AVG()</code> aggregation ‚Äî expensive at scale with millions of reviews. Since reviews are written rarely (once per completed stay) but ratings are read on every listing view and search result (billions of reads/day), the read-to-write ratio heavily favors denormalization. The Rating Aggregator asynchronously updates these fields when a new review is submitted, accepting a few seconds of staleness.
</div>

<p><strong>Why SQL:</strong> Listings are heavily relational (joined with photos, amenities, bookings, reviews). Complex queries with multiple filters. ACID needed for listing updates. Moderate write volume; very high read volume (mitigated by caching + search index).</p>
<p><strong>Read events:</strong> Listing detail page view, search result hydration, host dashboard.<br/>
<strong>Write events:</strong> Host creates listing, host updates listing, Rating Aggregator updates avg_rating/review_count.</p>

<h4>9.3 listing_photos</h4>
<table>
    <tr><th>Column</th><th>Type</th><th>Constraints</th><th>Notes</th></tr>
    <tr><td><span class="badge badge-pk">PK</span> photo_id</td><td>UUID</td><td>PRIMARY KEY</td><td></td></tr>
    <tr><td><span class="badge badge-fk">FK</span> listing_id</td><td>UUID</td><td>NOT NULL, FK ‚Üí listings.listing_id</td><td></td></tr>
    <tr><td>url</td><td>VARCHAR(512)</td><td>NOT NULL</td><td>CDN URL for the photo</td></tr>
    <tr><td>display_order</td><td>INT</td><td>NOT NULL</td><td>Controls photo carousel order</td></tr>
    <tr><td>caption</td><td>VARCHAR(200)</td><td></td><td>Optional</td></tr>
</table>
<p><span class="badge badge-idx">INDEX</span> <strong>Composite B-tree index on <code>(listing_id, display_order)</code></strong> ‚Äî Fetch all photos for a listing in display order. The composite index eliminates the need for a separate sort step.</p>
<p><strong>Why SQL:</strong> Referential integrity with listings table. Simple structure, low write volume.</p>
<p><strong>Read events:</strong> Listing detail page, search result thumbnails.<br/>
<strong>Write events:</strong> Host creates/updates listing photos.</p>

<h4>9.4 amenities</h4>
<table>
    <tr><th>Column</th><th>Type</th><th>Constraints</th><th>Notes</th></tr>
    <tr><td><span class="badge badge-pk">PK</span> amenity_id</td><td>INT</td><td>PRIMARY KEY, AUTO_INCREMENT</td><td></td></tr>
    <tr><td>name</td><td>VARCHAR(100)</td><td>UNIQUE, NOT NULL</td><td>e.g., "WiFi", "Pool", "Kitchen"</td></tr>
    <tr><td>category</td><td>VARCHAR(50)</td><td></td><td>e.g., "Essentials", "Features", "Safety"</td></tr>
    <tr><td>icon_url</td><td>VARCHAR(512)</td><td></td><td>Icon asset URL</td></tr>
</table>
<p><strong>Why SQL:</strong> Tiny reference table (~200 rows). Rarely changes. Cached in memory by the application.</p>
<p><strong>Read events:</strong> Listing creation form (show available amenities), search filter UI, listing detail page.<br/>
<strong>Write events:</strong> Admin adds new amenity (rare).</p>

<h4>9.5 listing_amenities (Junction Table)</h4>
<table>
    <tr><th>Column</th><th>Type</th><th>Constraints</th><th>Notes</th></tr>
    <tr><td><span class="badge badge-pk">PK</span><span class="badge badge-fk">FK</span> listing_id</td><td>UUID</td><td>FK ‚Üí listings.listing_id</td><td>Composite PK</td></tr>
    <tr><td><span class="badge badge-pk">PK</span><span class="badge badge-fk">FK</span> amenity_id</td><td>INT</td><td>FK ‚Üí amenities.amenity_id</td><td>Composite PK</td></tr>
</table>
<p><strong>Primary Key:</strong> Composite <code>(listing_id, amenity_id)</code> ‚Äî prevents duplicate entries and serves as the main index.</p>
<p><span class="badge badge-idx">INDEX</span> <strong>B-tree index on <code>amenity_id</code></strong> ‚Äî For reverse lookups ("find all listings with Pool amenity"). Though the primary search path uses the Search Index's inverted index on amenities, this SQL index supports direct DB queries.</p>
<p><strong>Why SQL:</strong> Classic many-to-many junction table. Referential integrity is important. Normalization is used here (rather than storing amenity IDs as a JSON array in the listings table) because (a) it enables efficient queries from both directions, (b) it enforces valid amenity references via FKs, and (c) amenity lookups are a common filter operation.</p>
<p><strong>Read events:</strong> Listing detail page (show amenities), search filtering.<br/>
<strong>Write events:</strong> Host creates/updates listing amenities.</p>

<h4>9.6 bookings</h4>
<table>
    <tr><th>Column</th><th>Type</th><th>Constraints</th><th>Notes</th></tr>
    <tr><td><span class="badge badge-pk">PK</span> booking_id</td><td>UUID</td><td>PRIMARY KEY</td><td></td></tr>
    <tr><td><span class="badge badge-fk">FK</span> listing_id</td><td>UUID</td><td>NOT NULL, FK ‚Üí listings.listing_id</td><td></td></tr>
    <tr><td><span class="badge badge-fk">FK</span> guest_id</td><td>UUID</td><td>NOT NULL, FK ‚Üí users.user_id</td><td></td></tr>
    <tr><td>check_in_date</td><td>DATE</td><td>NOT NULL</td><td></td></tr>
    <tr><td>check_out_date</td><td>DATE</td><td>NOT NULL</td><td></td></tr>
    <tr><td>num_guests</td><td>INT</td><td>NOT NULL</td><td></td></tr>
    <tr><td>nightly_rate</td><td>DECIMAL(10,2)</td><td>NOT NULL</td><td>Snapshot at booking time ‚Äî won't change if host updates price</td></tr>
    <tr><td>cleaning_fee</td><td>DECIMAL(10,2)</td><td>NOT NULL</td><td>Snapshot at booking time</td></tr>
    <tr><td>service_fee</td><td>DECIMAL(10,2)</td><td>NOT NULL</td><td>Platform fee</td></tr>
    <tr><td>total_price</td><td>DECIMAL(10,2)</td><td>NOT NULL</td><td>Calculated: (nightly_rate √ó nights) + cleaning_fee + service_fee</td></tr>
    <tr><td>status</td><td>ENUM</td><td>NOT NULL</td><td>pending, confirmed, cancelled_by_guest, cancelled_by_host, completed</td></tr>
    <tr><td>cancellation_policy</td><td>ENUM</td><td>NOT NULL</td><td>flexible, moderate, strict ‚Äî snapshotted at booking time</td></tr>
    <tr><td>created_at</td><td>TIMESTAMP</td><td>NOT NULL</td><td></td></tr>
    <tr><td>updated_at</td><td>TIMESTAMP</td><td>NOT NULL</td><td></td></tr>
</table>
<p><span class="badge badge-idx">INDEX</span> <strong>B-tree index on <code>guest_id</code></strong> ‚Äî "Show me my bookings" query. Range scan on guest_id returns all bookings for a guest.</p>
<p><span class="badge badge-idx">INDEX</span> <strong>Composite B-tree index on <code>(listing_id, check_in_date, check_out_date)</code></strong> ‚Äî Critical for the double-booking prevention query. Enables efficient lookup of all bookings for a listing within a date range to detect overlaps. Also used by the <code>SELECT ... FOR UPDATE</code> locking query.</p>
<p><span class="badge badge-idx">INDEX</span> <strong>B-tree index on <code>status</code></strong> ‚Äî Filter bookings by status (e.g., show only confirmed bookings).</p>

<div class="info-box">
    <strong>Denormalization Explanation:</strong> The <code>nightly_rate</code>, <code>cleaning_fee</code>, and <code>cancellation_policy</code> fields are snapshots of the listing's values at booking time. This is deliberate denormalization ‚Äî if the host later changes the price or cancellation policy, existing bookings retain the original terms. This is a business requirement, not just a performance optimization.
</div>

<p><strong>Sharding Strategy:</strong> Shard by <code>listing_id</code>. Rationale: The most critical query is the double-booking prevention check: "Are there any existing bookings for <em>this listing</em> that overlap with the requested dates?" This query must be atomic and fast, requiring all bookings for a given listing to reside on the same shard. The composite index <code>(listing_id, check_in_date, check_out_date)</code> works efficiently within a single shard. Secondary access pattern ("my bookings" by guest_id) can use a global secondary index or a scatter-gather query ‚Äî acceptable because it's a lower-frequency, latency-tolerant operation.</p>

<p><strong>Why SQL:</strong> ACID transactions are absolutely critical for booking. The pessimistic locking strategy (<code>SELECT ... FOR UPDATE</code>) requires SQL's transaction and row-locking support. Financial data demands strong consistency.</p>
<p><strong>Read events:</strong> Guest views "My Trips," host views "Reservations," availability checking during booking.<br/>
<strong>Write events:</strong> Guest creates a booking, guest/host cancels a booking, system marks booking as completed after check-out date.</p>

<h4>9.7 availability</h4>
<table>
    <tr><th>Column</th><th>Type</th><th>Constraints</th><th>Notes</th></tr>
    <tr><td><span class="badge badge-pk">PK</span><span class="badge badge-fk">FK</span> listing_id</td><td>UUID</td><td>FK ‚Üí listings.listing_id</td><td>Composite PK</td></tr>
    <tr><td><span class="badge badge-pk">PK</span> date</td><td>DATE</td><td></td><td>Composite PK</td></tr>
    <tr><td>is_available</td><td>BOOLEAN</td><td>NOT NULL, DEFAULT true</td><td></td></tr>
    <tr><td>price_override</td><td>DECIMAL(10,2)</td><td></td><td>Null = use listing's default price_per_night</td></tr>
    <tr><td>min_nights</td><td>INT</td><td></td><td>Optional minimum night stay for this date</td></tr>
</table>
<p><strong>Primary Key:</strong> Composite <code>(listing_id, date)</code>. This naturally serves as the primary index ‚Äî given a listing_id, we can efficiently query a contiguous range of dates.</p>

<p><strong>Sharding Strategy:</strong> Same shard key as bookings (<code>listing_id</code>). This is critical: both the bookings table and the availability table must be on the same shard so that the booking transaction (which reads/writes both tables) can execute within a single shard ‚Äî avoiding expensive distributed transactions.</p>

<p><strong>Why SQL:</strong> Must be updated atomically within the same transaction as booking creation. The <code>SELECT ... FOR UPDATE</code> locking mechanism operates on these rows. Strong consistency is non-negotiable.</p>
<p><strong>Read events:</strong> Availability calendar view (host), search date filtering, booking creation (check availability).<br/>
<strong>Write events:</strong> Booking creation (mark dates unavailable), booking cancellation (mark dates available again), host manually blocks/unblocks dates, host sets price overrides.</p>

<h4>9.8 reviews</h4>
<table>
    <tr><th>Column</th><th>Type</th><th>Constraints</th><th>Notes</th></tr>
    <tr><td><span class="badge badge-pk">PK</span> review_id</td><td>UUID</td><td>PRIMARY KEY</td><td></td></tr>
    <tr><td><span class="badge badge-fk">FK</span> booking_id</td><td>UUID</td><td>UNIQUE, NOT NULL, FK ‚Üí bookings.booking_id</td><td>One review per booking</td></tr>
    <tr><td><span class="badge badge-fk">FK</span> listing_id</td><td>UUID</td><td>NOT NULL, FK ‚Üí listings.listing_id</td><td>Denormalized for direct listing‚Üíreviews queries without joining bookings</td></tr>
    <tr><td><span class="badge badge-fk">FK</span> reviewer_id</td><td>UUID</td><td>NOT NULL, FK ‚Üí users.user_id</td><td></td></tr>
    <tr><td>rating</td><td>SMALLINT</td><td>NOT NULL, CHECK(1-5)</td><td>Overall rating</td></tr>
    <tr><td>cleanliness_rating</td><td>SMALLINT</td><td>CHECK(1-5)</td><td></td></tr>
    <tr><td>accuracy_rating</td><td>SMALLINT</td><td>CHECK(1-5)</td><td></td></tr>
    <tr><td>communication_rating</td><td>SMALLINT</td><td>CHECK(1-5)</td><td></td></tr>
    <tr><td>location_rating</td><td>SMALLINT</td><td>CHECK(1-5)</td><td></td></tr>
    <tr><td>value_rating</td><td>SMALLINT</td><td>CHECK(1-5)</td><td></td></tr>
    <tr><td>comment</td><td>TEXT</td><td></td><td></td></tr>
    <tr><td>host_response</td><td>TEXT</td><td></td><td>Host's reply to the review</td></tr>
    <tr><td>created_at</td><td>TIMESTAMP</td><td>NOT NULL</td><td></td></tr>
</table>
<p><span class="badge badge-idx">INDEX</span> <strong>B-tree index on <code>listing_id</code></strong> ‚Äî "Show all reviews for this listing." Range scan retrieves all reviews for a listing, typically sorted by created_at descending.</p>
<p><span class="badge badge-idx">INDEX</span> <strong>Unique B-tree index on <code>booking_id</code></strong> ‚Äî Enforces the one-review-per-booking constraint and supports the validation query during review submission.</p>

<div class="info-box">
    <strong>Denormalization Explanation:</strong> The <code>listing_id</code> column in reviews is technically derivable from <code>bookings.listing_id</code> via the <code>booking_id</code> FK. However, it's denormalized here because the most frequent query is "get all reviews for listing X" ‚Äî without this column, every such query would require a JOIN to the bookings table. Since reviews are written once and read millions of times (every listing page view), this denormalization is a significant performance win.
</div>

<p><strong>Why SQL:</strong> Relational integrity with bookings and listings. The UNIQUE constraint on booking_id enforces business rules. Complex queries with sorting and pagination.</p>
<p><strong>Read events:</strong> Listing detail page (show reviews), host dashboard (see reviews).<br/>
<strong>Write events:</strong> Guest submits review after completed stay, host writes a response.</p>

<h4>9.9 payments</h4>
<table>
    <tr><th>Column</th><th>Type</th><th>Constraints</th><th>Notes</th></tr>
    <tr><td><span class="badge badge-pk">PK</span> payment_id</td><td>UUID</td><td>PRIMARY KEY</td><td></td></tr>
    <tr><td><span class="badge badge-fk">FK</span> booking_id</td><td>UUID</td><td>NOT NULL, FK ‚Üí bookings.booking_id</td><td></td></tr>
    <tr><td><span class="badge badge-fk">FK</span> payer_id</td><td>UUID</td><td>NOT NULL, FK ‚Üí users.user_id</td><td></td></tr>
    <tr><td>amount</td><td>DECIMAL(10,2)</td><td>NOT NULL</td><td></td></tr>
    <tr><td>currency</td><td>VARCHAR(3)</td><td>NOT NULL</td><td>ISO 4217 (USD, EUR, etc.)</td></tr>
    <tr><td>status</td><td>ENUM</td><td>NOT NULL</td><td>pending, authorized, captured, refunded, failed</td></tr>
    <tr><td>payment_method_type</td><td>ENUM</td><td>NOT NULL</td><td>credit_card, debit_card, bank_transfer</td></tr>
    <tr><td>payment_provider_ref</td><td>VARCHAR(255)</td><td></td><td>External provider's transaction ID</td></tr>
    <tr><td>host_payout_amount</td><td>DECIMAL(10,2)</td><td></td><td>amount ‚àí platform fee. Null until captured.</td></tr>
    <tr><td>host_payout_status</td><td>ENUM</td><td></td><td>pending, paid, failed</td></tr>
    <tr><td>created_at</td><td>TIMESTAMP</td><td>NOT NULL</td><td></td></tr>
    <tr><td>updated_at</td><td>TIMESTAMP</td><td>NOT NULL</td><td></td></tr>
</table>
<p><span class="badge badge-idx">INDEX</span> <strong>B-tree index on <code>booking_id</code></strong> ‚Äî Look up payment for a specific booking.</p>
<p><strong>Why SQL:</strong> Financial records require ACID guarantees, auditability, and strong consistency. Transactional integrity with the bookings table.</p>
<p><strong>Read events:</strong> Booking detail page (show payment info), host payout dashboard, financial reports.<br/>
<strong>Write events:</strong> Payment authorization during booking, capture after check-in, refund on cancellation, host payout after check-out.</p>

<h3>NoSQL Tables</h3>

<h4>9.10 messages</h4>
<table>
    <tr><th>Column</th><th>Type</th><th>Key</th><th>Notes</th></tr>
    <tr><td><span class="badge badge-pk">PK</span> conversation_id</td><td>UUID</td><td>Partition Key</td><td>Groups all messages in a conversation</td></tr>
    <tr><td><span class="badge badge-pk">SK</span> sent_at</td><td>TIMESTAMP (ms precision)</td><td>Sort Key</td><td>Orders messages chronologically</td></tr>
    <tr><td>message_id</td><td>UUID</td><td></td><td>Globally unique message identifier</td></tr>
    <tr><td>sender_id</td><td>UUID</td><td></td><td>FK reference to users (not enforced in NoSQL)</td></tr>
    <tr><td>content</td><td>TEXT</td><td></td><td>Message body</td></tr>
    <tr><td>message_type</td><td>STRING</td><td></td><td>text, image, system (e.g., "Booking confirmed")</td></tr>
    <tr><td>is_read</td><td>BOOLEAN</td><td></td><td></td></tr>
</table>
<p><strong>Access Pattern:</strong> Partition by <code>conversation_id</code>, sorted by <code>sent_at</code>. Primary query: "Get the last 50 messages in conversation X" ‚Üí single partition range query, extremely efficient.</p>
<p><strong>Sharding:</strong> Automatically sharded by partition key (<code>conversation_id</code>). This distributes conversations evenly across nodes. All messages in a conversation are on the same partition, so fetching a conversation's messages never crosses shard boundaries.</p>
<p><strong>Why NoSQL:</strong> (1) Very high write throughput ‚Äî millions of messages per day. (2) Simple, predictable access pattern: always query by conversation_id + time range. No complex joins. (3) Horizontal scaling via automatic partitioning. (4) Schema flexibility for different message types (text, images, system messages, booking references). (5) Natural time-series data model aligns perfectly with wide-column/sorted-key NoSQL stores.</p>
<p><strong>Read events:</strong> User opens a conversation (paginated, newest first).<br/>
<strong>Write events:</strong> User sends a message, system sends automated message (booking confirmation, etc.).</p>

<h4>9.11 conversations</h4>
<table>
    <tr><th>Column</th><th>Type</th><th>Key</th><th>Notes</th></tr>
    <tr><td><span class="badge badge-pk">PK</span> conversation_id</td><td>UUID</td><td>Partition Key</td><td></td></tr>
    <tr><td>participant_ids</td><td>LIST&lt;UUID&gt;</td><td></td><td>Typically 2: [guest_id, host_id]</td></tr>
    <tr><td>listing_id</td><td>UUID</td><td></td><td>The listing this conversation is about</td></tr>
    <tr><td>last_message_preview</td><td>VARCHAR(200)</td><td></td><td>Denormalized ‚Äî avoids reading latest message from messages table</td></tr>
    <tr><td>last_message_at</td><td>TIMESTAMP</td><td></td><td>Denormalized ‚Äî for sorting inbox by most recent</td></tr>
    <tr><td>created_at</td><td>TIMESTAMP</td><td></td><td></td></tr>
</table>
<p><strong>Global Secondary Index (GSI):</strong> <code>user_id ‚Üí conversation_id, last_message_at</code> ‚Äî enables the "get all conversations for user X, sorted by most recent message" query. Each user ID has a GSI entry pointing to their conversations.</p>

<div class="info-box">
    <strong>Denormalization Explanation:</strong> <code>last_message_preview</code> and <code>last_message_at</code> are denormalized from the messages table. Without this, displaying the inbox (list of conversations with previews) would require querying the messages table for each conversation to find the latest message ‚Äî an N+1 query problem. Since messages are written frequently and the inbox is viewed on every app open, this denormalization is essential for performance.
</div>

<p><strong>Why NoSQL:</strong> Simple key-value access pattern. The GSI enables the inbox query. Schema flexibility for future features (group conversations, conversation tags, etc.).</p>
<p><strong>Read events:</strong> User opens messaging inbox (list all conversations).<br/>
<strong>Write events:</strong> New conversation created (guest messages host about a listing), <code>last_message_preview</code> and <code>last_message_at</code> updated every time a new message is sent.</p>

<h4>9.12 notifications</h4>
<table>
    <tr><th>Column</th><th>Type</th><th>Key</th><th>Notes</th></tr>
    <tr><td><span class="badge badge-pk">PK</span> user_id</td><td>UUID</td><td>Partition Key</td><td></td></tr>
    <tr><td><span class="badge badge-pk">SK</span> created_at</td><td>TIMESTAMP</td><td>Sort Key</td><td></td></tr>
    <tr><td>notification_id</td><td>UUID</td><td></td><td></td></tr>
    <tr><td>type</td><td>STRING</td><td></td><td>booking_confirmed, booking_cancelled, new_review, new_message, payout_sent, etc.</td></tr>
    <tr><td>title</td><td>VARCHAR(200)</td><td></td><td></td></tr>
    <tr><td>body</td><td>TEXT</td><td></td><td></td></tr>
    <tr><td>data</td><td>JSON</td><td></td><td>Flexible payload: { booking_id, listing_id, etc. }</td></tr>
    <tr><td>is_read</td><td>BOOLEAN</td><td></td><td></td></tr>
</table>
<p><strong>Access Pattern:</strong> Partition by <code>user_id</code>, sorted by <code>created_at</code> descending. Primary query: "Get the latest 20 notifications for user X."</p>
<p><strong>Why NoSQL:</strong> High write volume (every booking, message, review generates notifications). Simple access pattern. Schema flexibility for different notification types (each type has different data payload). Time-series nature of the data.</p>
<p><strong>Read events:</strong> User opens notification feed.<br/>
<strong>Write events:</strong> Any event that triggers a notification (booking, cancellation, message, review, payout).</p>

<!-- ============================================================== -->
<h2 id="cdn-cache">10. CDN &amp; Caching Deep Dive</h2>
<!-- ============================================================== -->

<h3>10.1 CDN</h3>

<p>A CDN is <strong>highly appropriate</strong> for Airbnb because:</p>
<ul>
    <li><strong>Listing photos</strong> are the single largest payload on the platform. Each listing has 10-30 photos in multiple sizes (thumbnail, medium, large). Photos are uploaded once and read millions of times across the globe.</li>
    <li><strong>Static assets</strong> (JavaScript bundles, CSS, fonts, icons) are identical for all users and benefit from edge caching.</li>
    <li><strong>Global user base</strong> ‚Äî users in Tokyo, Paris, and New York all need low-latency photo loading. A CDN with edge nodes worldwide reduces photo latency from 500+ ms (origin) to &lt;50 ms.</li>
</ul>

<h4>CDN Strategy</h4>
<table>
    <tr><th>Aspect</th><th>Strategy</th><th>Reasoning</th></tr>
    <tr>
        <td><strong>Content Cached</strong></td>
        <td>Listing photos (all sizes), user profile photos, static JS/CSS/fonts, amenity icons</td>
        <td>These are all immutable or rarely-changing static assets with extremely high read-to-write ratios</td>
    </tr>
    <tr>
        <td><strong>Cache Population</strong></td>
        <td>Pull-based (lazy loading). On first request for a photo, the CDN edge node fetches from Object Storage, caches it, and serves subsequent requests from cache.</td>
        <td>Pull-based is simpler and works well because popular listings naturally warm the cache. Pre-warming could be used for trending/featured listings.</td>
    </tr>
    <tr>
        <td><strong>Expiration Policy</strong></td>
        <td>Long TTL: 30 days for photos, 7 days for static assets</td>
        <td>Photos almost never change (hosts typically upload new photos rather than replacing). Long TTLs maximize cache hit ratio. Static assets use content-hashing in filenames (e.g., <code>app.abc123.js</code>) enabling infinite caching with cache-busting on new deploys.</td>
    </tr>
    <tr>
        <td><strong>Eviction Policy</strong></td>
        <td>LRU (Least Recently Used)</td>
        <td>Naturally evicts photos of rarely-viewed listings while keeping popular listings cached. Aligns with the power-law distribution of listing views.</td>
    </tr>
    <tr>
        <td><strong>Invalidation</strong></td>
        <td>When a host replaces a photo, the CDN is purged for that specific URL. New photos get new URLs, so no invalidation is needed for additions.</td>
        <td>Photo replacement is rare. URL-based purging is targeted and fast.</td>
    </tr>
</table>

<h3>10.2 In-Memory Cache</h3>

<p>An in-memory cache is <strong>essential</strong> for Airbnb because:</p>
<ul>
    <li><strong>Search results for popular locations</strong> (Paris, New York, Tokyo) are queried thousands of times per minute with similar parameters. Caching these avoids redundant Search Index queries.</li>
    <li><strong>Listing details</strong> are read millions of times per day. Popular listings (Superhost, trending) are viewed far more than average. Caching avoids repeated SQL reads.</li>
    <li><strong>User session data</strong> and authentication tokens are accessed on every request.</li>
    <li><strong>Geocoding results</strong> (city name ‚Üí lat/lng) rarely change and are queried on every search.</li>
</ul>

<h4>Cache Strategy per Use Case</h4>
<table>
    <tr><th>Use Case</th><th>Caching Strategy</th><th>TTL</th><th>Eviction</th><th>Population Trigger</th><th>Reasoning</th></tr>
    <tr>
        <td><strong>Search Results</strong></td>
        <td>Cache-Aside (Lazy Loading)</td>
        <td>2-5 minutes</td>
        <td>LRU</td>
        <td>On cache miss: query Search Index, write result to cache before returning to client.</td>
        <td>Cache-aside is appropriate because search results change frequently (availability updates, price changes). Short TTL ensures results don't become stale beyond a few minutes. We don't use write-through because search index updates happen asynchronously and independently. LRU evicts unpopular location/date combos. The short TTL is a balance between performance and freshness ‚Äî a user won't notice 2-minute-old results, but stale availability lasting hours would cause booking failures.</td>
    </tr>
    <tr>
        <td><strong>Listing Details</strong></td>
        <td>Cache-Aside with TTL + Event-Driven Invalidation</td>
        <td>15 minutes</td>
        <td>LRU</td>
        <td>On cache miss: query Listing DB, write to cache. On listing_updated event: invalidate the specific cache entry.</td>
        <td>Longer TTL because listing details change infrequently (host edits are rare). Event-driven invalidation ensures that when a host does update, the change is reflected quickly without waiting for TTL expiry. LRU keeps popular listings cached.</td>
    </tr>
    <tr>
        <td><strong>Geocoding Results</strong></td>
        <td>Cache-Aside</td>
        <td>24 hours</td>
        <td>LRU</td>
        <td>On cache miss: call geocoding service, cache the result.</td>
        <td>City/neighborhood boundaries extremely rarely change. Long TTL with aggressive caching reduces external API calls by 99%+.</td>
    </tr>
    <tr>
        <td><strong>Connection Registry</strong></td>
        <td>Write-Through</td>
        <td>45 seconds (matching heartbeat cycle)</td>
        <td>TTL-based</td>
        <td>WebSocket Gateway writes on connection/disconnection.</td>
        <td>Write-through ensures the registry is always up-to-date with active connections. TTL-based expiration acts as a safety net for connections that drop without a clean disconnect ‚Äî if a heartbeat refresh doesn't occur within 45 seconds, the entry expires automatically. No LRU needed since the data is small (just user_id ‚Üí server mappings) and entries naturally expire.</td>
    </tr>
</table>

<div class="warning-box">
    <strong>Why NOT Write-Through for Search/Listing Cache:</strong> Write-through cache updates the cache on every write to the database. This would be wasteful for search results because the "write" (search index update) is an asynchronous event, and the cache key is a complex composite (location + dates + filters) ‚Äî there are thousands of possible cache keys affected by a single listing update. It's more efficient to invalidate the specific listing detail cache entry and let search result caches expire naturally via short TTL.
</div>

<!-- ============================================================== -->
<h2 id="scaling">11. Scaling Considerations</h2>
<!-- ============================================================== -->

<h3>11.1 Load Balancers</h3>
<p>Load balancers are critical at multiple points in the architecture:</p>

<table>
    <tr><th>Location</th><th>Type</th><th>Algorithm</th><th>Reasoning</th></tr>
    <tr>
        <td><strong>Between Clients and API Gateway</strong></td>
        <td>Layer 7 (Application) Load Balancer</td>
        <td>Round-robin with health checks</td>
        <td>Distributes incoming HTTPS requests across multiple API Gateway instances. Layer 7 enables content-based routing (e.g., route <code>/api/search</code> to Search Service cluster, <code>/api/bookings</code> to Booking Service cluster). Health checks remove unhealthy instances from rotation. Round-robin is sufficient since API Gateway instances are stateless.</td>
    </tr>
    <tr>
        <td><strong>Between Clients and WebSocket Gateways</strong></td>
        <td>Layer 4 (Transport) Load Balancer with Sticky Sessions</td>
        <td>Least connections with sticky sessions (IP hash or cookie-based)</td>
        <td>Layer 4 is used because the WebSocket upgrade request needs to be forwarded without HTTP-level inspection. Sticky sessions ensure that after the initial WebSocket handshake, all frames from a client go to the same Gateway server. "Least connections" distributes new connections to the least-loaded server.</td>
    </tr>
    <tr>
        <td><strong>Between API Gateway and Backend Services</strong></td>
        <td>Layer 7 or Service Mesh (internal)</td>
        <td>Least connections or weighted round-robin</td>
        <td>Internal load balancing between microservices. Can be done via a service mesh sidecar proxy or an internal LB. Weighted round-robin allows gradual rollout (canary deployments).</td>
    </tr>
</table>

<h4>Load Balancer Deep Dive</h4>
<p><strong>Client ‚Üí API Gateway LB:</strong> This is the most critical load balancer. It terminates TLS, performs rate limiting (per-IP and per-user-token), and routes to one of many API Gateway instances. Health checks ping each instance every 5 seconds; instances that fail 3 consecutive health checks are removed. Auto-scaling adds new API Gateway instances when average CPU exceeds 70% or average latency exceeds 200 ms.</p>
<p><strong>Client ‚Üí WebSocket Gateway LB:</strong> Special handling is required because WebSocket connections are long-lived (hours to days). The LB must support connection draining during deployments ‚Äî when a Gateway server is being replaced, existing connections are gradually migrated (clients reconnect to new servers) rather than abruptly terminated. IP-hash-based sticky sessions ensure reconnections go to the same server if possible, but the system is designed to handle server changes gracefully via the Connection Registry.</p>

<h3>11.2 Horizontal Scaling by Component</h3>
<table>
    <tr><th>Component</th><th>Scaling Strategy</th></tr>
    <tr>
        <td><strong>API Gateway</strong></td>
        <td>Stateless ‚Äî scale horizontally by adding instances behind the load balancer. Auto-scale based on request rate / CPU / latency.</td>
    </tr>
    <tr>
        <td><strong>Search Service</strong></td>
        <td>Stateless ‚Äî scale horizontally. This is the highest-traffic service (searches are ~10x more frequent than bookings). Add replicas during peak travel planning seasons (January, holiday weekends).</td>
    </tr>
    <tr>
        <td><strong>Booking Service</strong></td>
        <td>Stateless ‚Äî scale horizontally. However, the booking DB shard is the bottleneck. Optimize by ensuring transactions are short-lived (minimize lock hold time).</td>
    </tr>
    <tr>
        <td><strong>Search Index</strong></td>
        <td>Horizontally scalable via sharding (geo-based sharding: North America, Europe, Asia-Pacific, etc.) and read replicas within each shard. Index size: ~7M listings √ó 2KB per document ‚âà 14GB ‚Äî fits in memory on each replica node.</td>
    </tr>
    <tr>
        <td><strong>SQL Databases</strong></td>
        <td>Vertical scaling for primary (larger instance). Read replicas for read-heavy queries (listing details, reviews). Sharding for bookings/availability (by listing_id) once single-node limits are reached. Connection pooling to handle high concurrency.</td>
    </tr>
    <tr>
        <td><strong>NoSQL (Messages, Notifications)</strong></td>
        <td>Automatically horizontally scalable via partition key sharding. Add nodes as data volume grows. Replication factor of 3 for durability.</td>
    </tr>
    <tr>
        <td><strong>WebSocket Gateways</strong></td>
        <td>Add servers as concurrent connection count grows. Each server handles ~100K connections. 10M concurrent users ‚âà 100 Gateway servers.</td>
    </tr>
    <tr>
        <td><strong>Message Queue</strong></td>
        <td>Scale consumer groups independently based on lag. If the search-index-updater consumer falls behind, add more consumer instances. Partition topics by key for parallel consumption.</td>
    </tr>
    <tr>
        <td><strong>In-Memory Cache</strong></td>
        <td>Clustered deployment with consistent hashing for key distribution. Scale by adding nodes to the cluster. Replication for availability.</td>
    </tr>
</table>

<h3>11.3 Seasonal / Event-Driven Scaling</h3>
<p>Airbnb has <strong>highly seasonal traffic patterns</strong>:</p>
<ul>
    <li><strong>Peak: Holiday weekends, New Year's, summer vacation planning season (Jan-Mar)</strong> ‚Äî Search traffic can spike 5-10x. Auto-scaling rules should pre-warm instances before known peak events.</li>
    <li><strong>Geographic events:</strong> Olympics, World Cup, music festivals cause localized search spikes. Geo-based search index shards for those regions need extra replicas.</li>
    <li><strong>Strategy:</strong> Predictive auto-scaling based on historical patterns + reactive auto-scaling based on real-time metrics.</li>
</ul>

<!-- ============================================================== -->
<h2 id="tradeoffs">12. Tradeoffs &amp; Deep Dives</h2>
<!-- ============================================================== -->

<h3>12.1 Consistency vs. Availability in Search</h3>
<p><strong>Tradeoff:</strong> Search results are eventually consistent. When a host creates a listing or a guest books dates, the search index is updated asynchronously (1-3 second delay). This means a guest might search and see a listing whose dates were just booked by someone else.</p>
<p><strong>Why this is acceptable:</strong> The booking step has a hard consistency check (pessimistic locking on availability). If a guest tries to book dates that were just booked, the booking will fail with a 409 Conflict and the guest can choose different dates. This is a "check-then-book" pattern where the search is an optimistic filter and the booking is the authoritative check. The alternative ‚Äî making search fully consistent with bookings ‚Äî would require synchronous updates to the search index during booking, significantly increasing booking latency and coupling two critical services.</p>

<h3>12.2 Pessimistic vs. Optimistic Locking for Bookings</h3>
<p><strong>Chose: Pessimistic locking (SELECT ... FOR UPDATE)</strong></p>
<p><strong>Tradeoff:</strong> Pessimistic locking blocks concurrent transactions attempting to book the same listing/dates, adding a small delay to the losing request. However, it guarantees correctness without retries.</p>
<p><strong>Why not optimistic:</strong> With optimistic concurrency control, both transactions would proceed in parallel, and the second one would fail at commit time due to a version mismatch, requiring the client to retry. For a booking (which involves payment authorization), retrying is expensive and frustrating for the user ‚Äî they'd see "payment processing" and then "failed, please try again." Pessimistic locking prevents this by serializing access upfront. The contention rate is low (two people booking the exact same listing + dates simultaneously is rare), so the lock wait time is minimal in practice.</p>

<h3>12.3 Per-Day Availability Rows vs. Date Range Bookings</h3>
<p><strong>Chose: Per-day rows in the availability table</strong></p>
<p><strong>Tradeoff:</strong> More storage (365 rows per listing per year ‚âà 7M √ó 365 = 2.5B rows) but dramatically simpler queries. To check if March 15-20 is available: <code>SELECT * FROM availability WHERE listing_id = X AND date BETWEEN '2025-03-15' AND '2025-03-19' AND is_available = false</code> ‚Äî if 0 rows returned, dates are available.</p>
<p><strong>Why not date ranges:</strong> With date-range bookings only, checking availability requires detecting overlapping date ranges (<code>WHERE check_in &lt; requested_checkout AND check_out &gt; requested_checkin</code>) ‚Äî more complex, harder to optimize, and the overlap detection query is less efficient with large numbers of bookings. Per-day rows also naturally support host-blocked dates and per-day price overrides without special handling.</p>

<h3 id="mq-deepdive">12.4 Message Queue Deep Dive</h3>
<p>The message queue is the backbone of the asynchronous event-driven architecture.</p>

<h4>Why a Message Queue</h4>
<ul>
    <li><strong>Decoupling:</strong> The Booking Service doesn't need to know about the Notification Service or Search Index Updater. It just publishes a <code>booking_confirmed</code> event and moves on. New consumers can be added without changing the producer.</li>
    <li><strong>Backpressure:</strong> If the Notification Service is temporarily slow, events accumulate in the queue rather than causing cascading failures in the Booking Service.</li>
    <li><strong>Retry &amp; Reliability:</strong> If a consumer fails to process an event, the message is retried (with exponential backoff). Dead-letter queues capture permanently failed messages for investigation.</li>
    <li><strong>Ordering:</strong> Events for a given listing or user are ordered within a partition, ensuring state changes are applied in the correct sequence.</li>
</ul>

<h4>Topics and Consumers</h4>
<table>
    <tr><th>Topic</th><th>Producers</th><th>Consumers</th></tr>
    <tr>
        <td><code>listing_events</code></td>
        <td>Listing Service</td>
        <td>Search Index Updater (index/re-index listing), Notification Service (if applicable)</td>
    </tr>
    <tr>
        <td><code>booking_events</code></td>
        <td>Booking Service</td>
        <td>Notification Service (host/guest notifications), Search Index Updater (update availability in search), Analytics Service</td>
    </tr>
    <tr>
        <td><code>review_events</code></td>
        <td>Review Service</td>
        <td>Rating Aggregator (update avg_rating), Notification Service (notify host), Search Index Updater (update rating in search)</td>
    </tr>
</table>

<h4>How Messages Flow</h4>
<ol>
    <li><strong>Production:</strong> A service (e.g., Booking Service) constructs an event message (JSON with event type, entity IDs, and relevant data) and publishes it to a topic. The message is partitioned by a key (e.g., listing_id) to ensure ordering for that entity.</li>
    <li><strong>Delivery:</strong> The message queue stores the message durably (replicated across brokers). Each consumer group independently tracks its offset/position in the topic.</li>
    <li><strong>Consumption:</strong> Each consumer group (e.g., "notification-consumers," "search-index-consumers") reads messages at its own pace. Within a consumer group, partitions are distributed across consumer instances for parallelism.</li>
    <li><strong>Acknowledgment:</strong> After a consumer successfully processes a message, it commits its offset. If a consumer crashes before committing, the message is redelivered to another instance in the group.</li>
    <li><strong>Dead-letter queue:</strong> Messages that fail after N retries (e.g., 5 retries with exponential backoff) are moved to a dead-letter queue for manual investigation.</li>
</ol>

<h4>Why Not Direct Synchronous Calls</h4>
<p>Without a message queue, the Booking Service would need to directly call the Notification Service and Search Index Updater synchronously before returning a response to the client. This would (1) increase booking latency by 200-500 ms, (2) make the Booking Service's availability dependent on the Notification Service's availability (coupling), and (3) eliminate retry capability ‚Äî if the notification fails, should the booking fail too? No. The queue decouples these concerns.</p>

<h4>Why Not Pure Pub/Sub Without Persistence</h4>
<p>A pure in-memory pub/sub (fire-and-forget) would lose messages if a consumer is temporarily down. The message queue provides durable storage with replay capability ‚Äî if the Search Index Updater goes down for 5 minutes and comes back, it can resume processing from where it left off.</p>

<h3>12.5 Microservices vs. Modular Monolith</h3>
<p><strong>Chose: Microservices</strong></p>
<p>Airbnb's domains (listing, search, booking, payments, messaging) have very different scaling requirements. Search handles 100x the traffic of bookings. Messaging requires WebSocket infrastructure that's irrelevant to search. Microservices allow each service to be scaled, deployed, and optimized independently. The tradeoff is operational complexity (service discovery, distributed tracing, inter-service communication), which is justified at Airbnb's scale.</p>

<h3>12.6 TCP as the Underlying Transport Protocol</h3>
<p>All communication in this system uses TCP as the transport layer:</p>
<ul>
    <li><strong>HTTPS (HTTP/2 over TLS over TCP):</strong> For all client-to-server REST API calls. TCP provides reliable, ordered delivery which is essential for API requests/responses where every byte must arrive correctly.</li>
    <li><strong>WebSocket over TCP:</strong> For real-time messaging. TCP ensures messages arrive in order and without loss, which is critical for chat (you don't want messages arriving out of order or getting dropped).</li>
    <li><strong>gRPC over TCP:</strong> For internal service-to-service calls (e.g., Booking Service ‚Üí Payment Service). gRPC uses HTTP/2 which runs on TCP.</li>
</ul>
<p><strong>Why not UDP:</strong> UDP would only be appropriate for real-time media streaming (video tours, voice calls) where occasional packet loss is acceptable. Airbnb's primary interactions are text-based (search queries, booking data, messages) where data integrity is paramount. If Airbnb added a video tour feature, WebRTC (which uses UDP for media streams) would be appropriate for that specific feature.</p>

<!-- ============================================================== -->
<h2 id="alternatives">13. Alternative Approaches</h2>
<!-- ============================================================== -->

<h3>13.1 Search: SQL with Geo-spatial Extensions Instead of Dedicated Search Index</h3>
<p><strong>Approach:</strong> Use the SQL database's built-in geo-spatial capabilities (R-tree index on lat/lng) for all search queries, eliminating the separate search index.</p>
<p><strong>Why not chosen:</strong> While SQL geo-spatial queries work for simple "find nearby" operations, Airbnb search requires multi-faceted queries combining geo-spatial filtering, full-text search (title/description), range filters (price, guests), faceted filtering (amenities, property type), and relevance scoring ‚Äî all in &lt;200 ms. SQL databases struggle with this combination at scale. A dedicated search index is purpose-built for these compound queries and can handle them orders of magnitude faster. Additionally, the search index can be scaled independently (read replicas, geo-sharding) without affecting the transactional SQL database's performance.</p>

<h3>13.2 Event Sourcing Instead of Traditional CRUD for Bookings</h3>
<p><strong>Approach:</strong> Instead of updating booking/availability rows directly, store an immutable append-only log of events (BookingRequested, PaymentAuthorized, BookingConfirmed, BookingCancelled) and derive the current state from the event log.</p>
<p><strong>Why not chosen:</strong> Event sourcing provides excellent audit trails and temporal queries ("what was the availability on March 1st?") but adds significant complexity: (1) materializing the current state requires replaying events or maintaining projections, (2) the double-booking check becomes more complex (you'd need a projection that's always up-to-date), (3) the development team needs expertise in event sourcing patterns. For a system where the booking state machine is relatively simple (5-6 states), traditional CRUD with an audit log table is simpler and sufficient. Event sourcing could be considered for the payment subsystem where the audit trail is more critical.</p>

<h3>13.3 GraphQL Instead of REST for API</h3>
<p><strong>Approach:</strong> Use GraphQL instead of REST for the client-facing API, allowing clients to request exactly the fields they need.</p>
<p><strong>Why not chosen:</strong> GraphQL would reduce over-fetching (mobile clients could request fewer fields than web) and eliminate multiple round-trips (fetch listing + reviews + host info in one query). However, it adds complexity: query parsing/validation overhead, potential for expensive nested queries (N+1 to the database), and harder caching (each query is unique, unlike REST endpoints which are easily CDN-cacheable). REST with well-designed endpoints, pagination, and field selection parameters (e.g., <code>?fields=title,price,rating</code>) achieves most of GraphQL's benefits with less complexity. GraphQL could be adopted incrementally for the listing detail page where data requirements vary significantly between mobile and web.</p>

<h3>13.4 CQRS (Command Query Responsibility Segregation)</h3>
<p><strong>Approach:</strong> Completely separate the read and write models ‚Äî writes go to the SQL database, reads are served from optimized read stores (search index, cache, materialized views).</p>
<p><strong>Why partially chosen:</strong> The design already incorporates CQRS principles for search (writes ‚Üí SQL ‚Üí async ‚Üí Search Index; reads ‚Üí Search Index). Full CQRS across all services was not adopted because it adds complexity to maintain consistency between command and query models, and most services (Listing, Review) don't have the read/write ratio disparity that justifies full separation. The partial CQRS for search is the sweet spot.</p>

<h3>13.5 Long Polling for Messaging Instead of WebSockets</h3>
<p><strong>Approach:</strong> Use HTTP long polling where the client makes a request that the server holds open until a new message arrives, then immediately makes another request.</p>
<p><strong>Why not chosen:</strong> Long polling creates a new TCP connection for every message exchange (or timeout), consuming more server resources and adding 50-200 ms latency per message. For Airbnb messaging (which is moderately active ‚Äî not as high-frequency as a chat app like WhatsApp), long polling would technically work but WebSockets provide a better user experience with true real-time delivery (&lt;50 ms) and lower server resource consumption. The Connection Registry complexity is the main cost of WebSockets, but it's a well-understood pattern.</p>

<h3>13.6 Separate Availability Microservice</h3>
<p><strong>Approach:</strong> Extract availability management into its own microservice with its own database, separate from the Booking Service.</p>
<p><strong>Why not chosen:</strong> Availability and bookings are tightly coupled ‚Äî creating a booking and updating availability must happen in a single ACID transaction. Splitting them into separate services would require distributed transactions (2-phase commit) or saga patterns, adding latency and complexity to the most critical path in the system. Keeping them in the same service (and same database shard) allows a simple single-database transaction. This is a deliberate choice to favor consistency over microservice purity.</p>

<!-- ============================================================== -->
<h2 id="additional">14. Additional Considerations</h2>
<!-- ============================================================== -->

<h3>14.1 Fraud Detection</h3>
<p>A fraud detection pipeline should analyze bookings and reviews asynchronously. Suspicious patterns (fake reviews, fraudulent payment methods, listing spam) can be flagged via machine learning models consuming events from the message queue. Flagged listings enter an "under_review" status and are hidden from search results.</p>

<h3>14.2 Idempotency</h3>
<p>All write operations should be idempotent. The booking creation endpoint should accept a client-generated idempotency key (UUID) so that if a network retry sends the same request twice, the second request is a no-op. This is stored in a short-lived cache (TTL: 24 hours) keyed by the idempotency key.</p>

<h3>14.3 Rate Limiting</h3>
<p>The API Gateway enforces rate limits: 100 search requests/minute per user (to prevent scraping), 10 booking attempts/minute per user, 60 messages/minute per user. Rate limits are enforced via a sliding-window counter in the in-memory cache.</p>

<h3>14.4 Image Processing Pipeline</h3>
<p>When a host uploads a photo, an asynchronous image processing pipeline (triggered via the message queue) resizes the photo into multiple variants: thumbnail (200√ó150), medium (800√ó600), large (1600√ó1200), and generates WebP versions for modern browsers. EXIF data is stripped for privacy. Blur hash placeholders are generated for progressive loading.</p>

<h3>14.5 Monitoring &amp; Observability</h3>
<ul>
    <li><strong>Distributed Tracing:</strong> Every request gets a trace ID that follows it through all services. If a booking takes 5 seconds, the trace shows which service added latency.</li>
    <li><strong>Metrics:</strong> p50/p99 latency per endpoint, booking success rate, search cache hit ratio, message queue consumer lag, WebSocket connection count.</li>
    <li><strong>Alerting:</strong> Alert if booking error rate exceeds 1%, search p99 latency exceeds 500 ms, or message queue consumer lag exceeds 10,000 messages.</li>
</ul>

<h3>14.6 Data Backup &amp; Disaster Recovery</h3>
<p>SQL databases: continuous replication to standby instances in a different availability zone. Point-in-time recovery with write-ahead logs. Daily snapshots retained for 30 days. RTO: 15 minutes. RPO: 0 (synchronous replication for bookings/payments, async for others).</p>

<h3>14.7 Internationalization</h3>
<p>Listing content (title, description) is stored in the host's language. Translations can be generated on-demand or stored as a JSON map of locale ‚Üí translated text in a separate column. Prices are stored in the listing's base currency and converted to the viewer's currency at display time using a currency exchange rate service (rates cached for 1 hour).</p>

<h3>14.8 Privacy &amp; Data Protection</h3>
<p>Full property addresses are only revealed to guests after booking confirmation. Search results show approximate location (neighborhood-level). Personal data (email, phone) is encrypted at rest. GDPR compliance requires a "right to be forgotten" workflow that anonymizes user data across all services and data stores.</p>

<!-- ============================================================== -->
<h2 id="vendors">15. Vendor Suggestions</h2>
<!-- ============================================================== -->
<p>While the design is vendor-agnostic, here are suitable vendors for each category with rationale:</p>

<table>
    <tr><th>Component</th><th>Vendor Options</th><th>Rationale</th></tr>
    <tr>
        <td><strong>SQL Database</strong></td>
        <td>PostgreSQL, MySQL, Amazon Aurora, Google Cloud Spanner</td>
        <td>PostgreSQL: Excellent geo-spatial support (PostGIS), mature, open-source. Aurora: PostgreSQL-compatible with automated scaling and replication. Cloud Spanner: Global distribution with strong consistency ‚Äî ideal for bookings if multi-region write is needed.</td>
    </tr>
    <tr>
        <td><strong>NoSQL (Messages, Notifications)</strong></td>
        <td>Apache Cassandra, Amazon DynamoDB, Google Bigtable</td>
        <td>Cassandra: Wide-column store with excellent write throughput and tunable consistency. Ideal for time-series message data. DynamoDB: Fully managed, single-digit millisecond latency, auto-scaling. Bigtable: Excellent for high-throughput, sorted time-series data.</td>
    </tr>
    <tr>
        <td><strong>Search Index</strong></td>
        <td>Elasticsearch, Apache Solr, Typesense, Meilisearch</td>
        <td>Elasticsearch: Industry standard for full-text + geo-spatial search. Supports complex aggregations, faceted search, and geo-bounding-box queries. Highly scalable with sharding and replicas.</td>
    </tr>
    <tr>
        <td><strong>In-Memory Cache</strong></td>
        <td>Redis, Memcached, KeyDB</td>
        <td>Redis: Supports complex data structures (sorted sets for leaderboards, hashes for objects), pub/sub for cache invalidation, and cluster mode for horizontal scaling. Also serves as the Connection Registry for WebSockets. Memcached: Simpler, faster for pure key-value caching if complex data structures aren't needed.</td>
    </tr>
    <tr>
        <td><strong>Message Queue</strong></td>
        <td>Apache Kafka, Amazon SQS/SNS, RabbitMQ, Apache Pulsar</td>
        <td>Kafka: High-throughput, durable, supports partitioned topics with consumer groups. Excellent for event-driven architectures. Message replay capability enables reprocessing. Pulsar: Similar to Kafka with built-in multi-tenancy. RabbitMQ: Simpler for lower-throughput scenarios with routing flexibility.</td>
    </tr>
    <tr>
        <td><strong>Object Storage</strong></td>
        <td>Amazon S3, Google Cloud Storage, Azure Blob Storage, MinIO</td>
        <td>S3: Industry standard. 11 nines durability. Lifecycle policies for cost optimization. Integrates with CDNs. MinIO: S3-compatible, self-hosted option for multi-cloud or on-premise deployments.</td>
    </tr>
    <tr>
        <td><strong>CDN</strong></td>
        <td>Cloudflare, Amazon CloudFront, Akamai, Fastly</td>
        <td>Cloudflare: Global edge network, DDoS protection, generous free tier. CloudFront: Tight integration with S3 for origin pull. Akamai: Largest CDN network globally, best for enterprise. Fastly: Real-time cache purging and edge compute.</td>
    </tr>
    <tr>
        <td><strong>Load Balancer</strong></td>
        <td>NGINX, HAProxy, Amazon ALB/NLB, Google Cloud Load Balancing</td>
        <td>NGINX: High-performance L7 LB with WebSocket support. HAProxy: Excellent L4/L7 LB with sticky session support. Cloud-native LBs (ALB, NLB) for managed infrastructure with auto-scaling integration.</td>
    </tr>
</table>

</div>

<script>
    mermaid.initialize({
        startOnLoad: true,
        theme: 'dark',
        themeVariables: {
            primaryColor: '#1f3a5c',
            primaryTextColor: '#e6edf3',
            primaryBorderColor: '#30363d',
            lineColor: '#58a6ff',
            secondaryColor: '#1a2332',
            tertiaryColor: '#161b22',
            fontSize: '14px'
        },
        flowchart: {
            useMaxWidth: true,
            htmlLabels: true,
            curve: 'basis'
        }
    });
</script>

</body>
</html>
