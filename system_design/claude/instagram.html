<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>System Design: Instagram</title>
<style>
  body{font-family:'Segoe UI',Arial,sans-serif;margin:0;padding:20px;background:#f5f5f5;color:#333}
  .container{max-width:1200px;margin:0 auto;background:#fff;padding:40px;border-radius:8px;box-shadow:0 2px 10px rgba(0,0,0,.1)}
  h1{color:#1a73e8;border-bottom:3px solid #1a73e8;padding-bottom:10px}
  h2{color:#2c3e50;margin-top:40px;border-left:4px solid #1a73e8;padding-left:12px}
  h3{color:#34495e}h4{color:#555}
  .diagram{background:#fafafa;border:1px solid #ddd;border-radius:8px;padding:20px;margin:20px 0;overflow-x:auto}
  .example{background:#e8f5e9;border-left:4px solid #4caf50;padding:15px;margin:15px 0;border-radius:4px}
  .deep-dive{background:#e3f2fd;border-left:4px solid #2196f3;padding:15px;margin:15px 0;border-radius:4px}
  .tradeoff{background:#fff3e0;border-left:4px solid #ff9800;padding:15px;margin:15px 0;border-radius:4px}
  .alternative{background:#fce4ec;border-left:4px solid #e91e63;padding:15px;margin:15px 0;border-radius:4px}
  table{border-collapse:collapse;width:100%;margin:15px 0}
  th,td{border:1px solid #ddd;padding:10px 14px;text-align:left}
  th{background:#1a73e8;color:#fff}
  tr:nth-child(even){background:#f9f9f9}
  code{background:#f0f0f0;padding:2px 6px;border-radius:3px;font-size:.9em}
  .tag{display:inline-block;padding:2px 8px;border-radius:4px;font-size:.85em;margin:2px}
  .tag-pk{background:#ffeb3b;color:#333}.tag-fk{background:#ce93d8;color:#333}.tag-idx{background:#80cbc4;color:#333}
  ul,ol{line-height:1.8}
  svg text{font-family:'Segoe UI',Arial,sans-serif}
</style>
</head>
<body>
<div class="container">
<h1>System Design: Instagram</h1>

<h2>Functional Requirements</h2>
<ol>
  <li><strong>Upload photos/videos</strong> â€“ Users can upload photos and short videos with captions, filters, and tags.</li>
  <li><strong>View feed</strong> â€“ Users see a personalized feed of posts from people they follow.</li>
  <li><strong>Follow/unfollow users</strong> â€“ Users can follow other users to see their content.</li>
  <li><strong>Like and comment</strong> â€“ Users can like posts and leave comments.</li>
  <li><strong>User profile</strong> â€“ Users have profiles with bio, avatar, follower/following counts, and a grid of their posts.</li>
  <li><strong>Search</strong> â€“ Users can search for other users, hashtags, and locations.</li>
  <li><strong>Stories</strong> â€“ Users can post ephemeral content that disappears after 24 hours.</li>
  <li><strong>Direct messaging</strong> â€“ Users can send private messages (text, photos, videos).</li>
  <li><strong>Explore page</strong> â€“ Content discovery through algorithmically curated posts.</li>
  <li><strong>Notifications</strong> â€“ Users receive notifications for likes, comments, follows, mentions.</li>
</ol>

<h2>Non-Functional Requirements</h2>
<ol>
  <li><strong>High availability</strong> â€“ 99.99% uptime; read-heavy workload (100:1 read-to-write ratio).</li>
  <li><strong>Low latency</strong> â€“ Feed loads in &lt;500ms; image loads in &lt;200ms.</li>
  <li><strong>Scalability</strong> â€“ 2B+ monthly active users, 100M+ photos uploaded daily.</li>
  <li><strong>Eventual consistency</strong> â€“ Acceptable for feeds and like counts; strong consistency for follows and user data.</li>
  <li><strong>Durability</strong> â€“ Zero data loss for uploaded photos/videos.</li>
  <li><strong>Cost efficiency</strong> â€“ Optimize storage costs for petabytes of media.</li>
</ol>

<!-- ==================== FLOW 1: UPLOAD POST ==================== -->
<h2>Flow 1: Uploading a Post</h2>
<div class="diagram">
<svg viewBox="0 0 1100 450" xmlns="http://www.w3.org/2000/svg">
  <defs><marker id="a1" viewBox="0 0 10 10" refX="9" refY="5" markerWidth="6" markerHeight="6" orient="auto"><path d="M0 0L10 5L0 10z" fill="#333"/></marker></defs>
  <rect x="10" y="170" width="90" height="60" rx="8" fill="#4caf50" stroke="#388e3c" stroke-width="2"/>
  <text x="55" y="205" text-anchor="middle" fill="#fff" font-size="13" font-weight="bold">User</text>
  <line x1="100" y1="200" x2="170" y2="200" stroke="#333" stroke-width="2" marker-end="url(#a1)"/>
  <text x="135" y="190" text-anchor="middle" fill="#555" font-size="9">HTTPS POST</text>
  <rect x="170" y="170" width="90" height="60" rx="8" fill="#ff9800" stroke="#f57c00" stroke-width="2"/>
  <text x="215" y="198" text-anchor="middle" fill="#fff" font-size="11" font-weight="bold">API</text>
  <text x="215" y="212" text-anchor="middle" fill="#fff" font-size="11" font-weight="bold">Gateway</text>
  <line x1="260" y1="200" x2="330" y2="200" stroke="#333" stroke-width="2" marker-end="url(#a1)"/>
  <rect x="330" y="170" width="110" height="60" rx="8" fill="#2196f3" stroke="#1565c0" stroke-width="2"/>
  <text x="385" y="198" text-anchor="middle" fill="#fff" font-size="12" font-weight="bold">Post</text>
  <text x="385" y="213" text-anchor="middle" fill="#fff" font-size="12" font-weight="bold">Service</text>
  <!-- To Media Service -->
  <line x1="385" y1="170" x2="385" y2="80" stroke="#333" stroke-width="2" marker-end="url(#a1)"/>
  <rect x="330" y="20" width="110" height="50" rx="8" fill="#00bcd4" stroke="#00838f" stroke-width="2"/>
  <text x="385" y="50" text-anchor="middle" fill="#fff" font-size="12" font-weight="bold">Media Svc</text>
  <!-- Media Svc to S3 -->
  <line x1="440" y1="45" x2="530" y2="45" stroke="#333" stroke-width="2" marker-end="url(#a1)"/>
  <rect x="530" y="25" width="90" height="40" rx="6" fill="#795548" stroke="#4e342e" stroke-width="2"/>
  <text x="575" y="50" text-anchor="middle" fill="#fff" font-size="11" font-weight="bold">S3</text>
  <!-- S3 to CDN -->
  <line x1="620" y1="45" x2="700" y2="45" stroke="#333" stroke-width="2" marker-end="url(#a1)"/>
  <rect x="700" y="25" width="80" height="40" rx="6" fill="#607d8b" stroke="#37474f" stroke-width="2"/>
  <text x="740" y="50" text-anchor="middle" fill="#fff" font-size="11" font-weight="bold">CDN</text>
  <!-- Post Service to Post DB -->
  <line x1="385" y1="230" x2="385" y2="310" stroke="#333" stroke-width="2" marker-end="url(#a1)"/>
  <ellipse cx="385" cy="320" rx="50" ry="12" fill="#ff5722" stroke="#d84315" stroke-width="2"/>
  <rect x="335" y="320" width="100" height="35" fill="#ff5722" stroke="#d84315" stroke-width="2"/>
  <ellipse cx="385" cy="355" rx="50" ry="12" fill="#e64a19" stroke="#d84315" stroke-width="2"/>
  <line x1="335" y1="320" x2="335" y2="355" stroke="#d84315" stroke-width="2"/>
  <line x1="435" y1="320" x2="435" y2="355" stroke="#d84315" stroke-width="2"/>
  <text x="385" y="342" text-anchor="middle" fill="#fff" font-size="10" font-weight="bold">Post DB</text>
  <!-- Post Service to Message Queue for fan-out -->
  <line x1="440" y1="200" x2="530" y2="200" stroke="#333" stroke-width="2" marker-end="url(#a1)"/>
  <text x="485" y="190" text-anchor="middle" fill="#555" font-size="9">Fan-out event</text>
  <rect x="530" y="170" width="110" height="60" rx="8" fill="#9c27b0" stroke="#6a1b9a" stroke-width="2"/>
  <text x="585" y="198" text-anchor="middle" fill="#fff" font-size="11" font-weight="bold">Message</text>
  <text x="585" y="213" text-anchor="middle" fill="#fff" font-size="11" font-weight="bold">Queue</text>
  <!-- MQ to Fan-out Service -->
  <line x1="640" y1="200" x2="720" y2="200" stroke="#333" stroke-width="2" marker-end="url(#a1)"/>
  <rect x="720" y="170" width="120" height="60" rx="8" fill="#673ab7" stroke="#4527a0" stroke-width="2"/>
  <text x="780" y="198" text-anchor="middle" fill="#fff" font-size="11" font-weight="bold">Fan-out</text>
  <text x="780" y="213" text-anchor="middle" fill="#fff" font-size="11" font-weight="bold">Service</text>
  <!-- Fan-out to Feed Cache -->
  <line x1="780" y1="230" x2="780" y2="310" stroke="#333" stroke-width="2" marker-end="url(#a1)"/>
  <ellipse cx="780" cy="320" rx="55" ry="12" fill="#009688" stroke="#00695c" stroke-width="2"/>
  <rect x="725" y="320" width="110" height="35" fill="#009688" stroke="#00695c" stroke-width="2"/>
  <ellipse cx="780" cy="355" rx="55" ry="12" fill="#00796b" stroke="#00695c" stroke-width="2"/>
  <line x1="725" y1="320" x2="725" y2="355" stroke="#00695c" stroke-width="2"/>
  <line x1="835" y1="320" x2="835" y2="355" stroke="#00695c" stroke-width="2"/>
  <text x="780" y="340" text-anchor="middle" fill="#fff" font-size="10" font-weight="bold">Feed Cache</text>
  <text x="780" y="375" text-anchor="middle" fill="#555" font-size="9">(Redis)</text>
</svg>
</div>

<div class="example">
<h4>Example: User uploads a photo</h4>
<p>Alice selects a photo from her camera roll, applies a filter, adds caption "Sunset vibes ðŸŒ… #travel", and taps Share. The client sends an <strong>HTTPS POST</strong> (multipart/form-data) to the <strong>API Gateway</strong>, which authenticates the request via JWT and routes it to the <strong>Post Service</strong>. The Post Service calls the <strong>Media Service</strong> to upload the image: it resizes the image into multiple resolutions (150px thumbnail, 640px medium, 1080px full), stores all versions in <strong>S3</strong>, and returns the media URLs. The Post Service creates a post record in the <strong>Post DB</strong> (PostgreSQL) with the media URLs, caption, hashtags, and timestamp. It then publishes a <code>POST_CREATED</code> event to the <strong>Message Queue</strong> (Kafka). The <strong>Fan-out Service</strong> consumes this event, fetches Alice's follower list, and prepends Alice's post_id to each follower's feed in the <strong>Feed Cache</strong> (Redis). Alice's 500 followers will now see the post when they open their feed.</p>
</div>

<h3>Deep Dive: Flow 1 Components</h3>

<div class="deep-dive">
<h4>API Gateway</h4>
<p>Entry point for all client requests. Handles authentication (JWT token validation), rate limiting, request routing, and SSL termination. Routes requests to appropriate microservices based on URL path.</p>
<p><strong>Protocol:</strong> HTTPS (REST). For uploads: POST with multipart/form-data.</p>
</div>

<div class="deep-dive">
<h4>Post Service</h4>
<p>Manages post creation, deletion, and retrieval.</p>
<p><strong>Endpoints:</strong></p>
<ul>
  <li><code>POST /api/v1/posts</code> â€“ Create a new post. Input: image/video file, caption, hashtags, location. Output: <code>{post_id, media_urls, created_at}</code></li>
  <li><code>GET /api/v1/posts/{post_id}</code> â€“ Get a single post. Output: <code>{post_id, user_id, media_urls, caption, like_count, comment_count, created_at}</code></li>
  <li><code>DELETE /api/v1/posts/{post_id}</code> â€“ Delete a post.</li>
</ul>
</div>

<div class="deep-dive">
<h4>Media Service</h4>
<p>Handles image/video processing: resizing, compression, format conversion (WebP for images, HLS/DASH for videos), and storage.</p>
<p><strong>Protocol:</strong> Internal gRPC from Post Service. HTTPS PUT to S3.</p>
<p><strong>Input:</strong> Raw binary image/video. <strong>Output:</strong> List of media URLs (thumbnail, medium, full resolution).</p>
</div>

<div class="deep-dive">
<h4>Fan-out Service</h4>
<p>Consumes <code>POST_CREATED</code> events from Kafka and distributes the post to followers' feeds. Uses a <strong>hybrid fan-out</strong> approach:</p>
<ul>
  <li><strong>Fan-out on write</strong> for regular users (&lt;10K followers): Prepend post_id to each follower's feed in Redis. Fast feed reads.</li>
  <li><strong>Fan-out on read</strong> for celebrities (&gt;10K followers): Don't pre-compute; merge celebrity posts at feed read time. Avoids writing to millions of feed caches.</li>
</ul>
</div>

<div class="deep-dive">
<h4>CDN</h4>
<p><strong>Why CDN is critical:</strong> Instagram is image-heavy. Serving images from S3 directly would be too slow and costly. CDN caches images at 200+ edge locations globally, reducing latency from ~500ms to ~50ms.</p>
<p><strong>Caching strategy:</strong> Pull-based (origin pull from S3). First request fetches from S3 and caches at edge.</p>
<p><strong>Eviction policy:</strong> LRU with size-aware eviction (larger files evicted first when cache is full).</p>
<p><strong>Expiration policy:</strong> TTL = 30 days for images (they don't change), 1 year for profile avatars with cache-busting URL parameters on update.</p>
</div>

<!-- ==================== FLOW 2: VIEWING FEED ==================== -->
<h2>Flow 2: Viewing the Feed</h2>
<div class="diagram">
<svg viewBox="0 0 1050 350" xmlns="http://www.w3.org/2000/svg">
  <defs><marker id="a2" viewBox="0 0 10 10" refX="9" refY="5" markerWidth="6" markerHeight="6" orient="auto"><path d="M0 0L10 5L0 10z" fill="#333"/></marker></defs>
  <rect x="10" y="140" width="90" height="60" rx="8" fill="#4caf50" stroke="#388e3c" stroke-width="2"/>
  <text x="55" y="175" text-anchor="middle" fill="#fff" font-size="13" font-weight="bold">User</text>
  <line x1="100" y1="170" x2="170" y2="170" stroke="#333" stroke-width="2" marker-end="url(#a2)"/>
  <text x="135" y="160" text-anchor="middle" fill="#555" font-size="9">HTTPS GET</text>
  <rect x="170" y="140" width="90" height="60" rx="8" fill="#ff9800" stroke="#f57c00" stroke-width="2"/>
  <text x="215" y="168" text-anchor="middle" fill="#fff" font-size="11" font-weight="bold">API</text>
  <text x="215" y="182" text-anchor="middle" fill="#fff" font-size="11" font-weight="bold">Gateway</text>
  <line x1="260" y1="170" x2="340" y2="170" stroke="#333" stroke-width="2" marker-end="url(#a2)"/>
  <rect x="340" y="140" width="110" height="60" rx="8" fill="#2196f3" stroke="#1565c0" stroke-width="2"/>
  <text x="395" y="168" text-anchor="middle" fill="#fff" font-size="12" font-weight="bold">Feed</text>
  <text x="395" y="183" text-anchor="middle" fill="#fff" font-size="12" font-weight="bold">Service</text>
  <!-- Feed Service to Feed Cache -->
  <line x1="450" y1="170" x2="530" y2="170" stroke="#333" stroke-width="2" marker-end="url(#a2)"/>
  <text x="490" y="160" text-anchor="middle" fill="#555" font-size="9">1. Get post IDs</text>
  <ellipse cx="590" cy="160" rx="50" ry="12" fill="#009688" stroke="#00695c" stroke-width="2"/>
  <rect x="540" y="160" width="100" height="35" fill="#009688" stroke="#00695c" stroke-width="2"/>
  <ellipse cx="590" cy="195" rx="50" ry="12" fill="#00796b" stroke="#00695c" stroke-width="2"/>
  <line x1="540" y1="160" x2="540" y2="195" stroke="#00695c" stroke-width="2"/>
  <line x1="640" y1="160" x2="640" y2="195" stroke="#00695c" stroke-width="2"/>
  <text x="590" y="182" text-anchor="middle" fill="#fff" font-size="10" font-weight="bold">Feed Cache</text>
  <!-- Feed Service to Post DB -->
  <line x1="395" y1="200" x2="395" y2="280" stroke="#333" stroke-width="2" marker-end="url(#a2)"/>
  <text x="395" y="250" text-anchor="start" fill="#555" font-size="9"> 2. Hydrate</text>
  <ellipse cx="395" cy="290" rx="50" ry="12" fill="#ff5722" stroke="#d84315" stroke-width="2"/>
  <rect x="345" y="290" width="100" height="30" fill="#ff5722" stroke="#d84315" stroke-width="2"/>
  <ellipse cx="395" cy="320" rx="50" ry="12" fill="#e64a19" stroke="#d84315" stroke-width="2"/>
  <line x1="345" y1="290" x2="345" y2="320" stroke="#d84315" stroke-width="2"/>
  <line x1="445" y1="290" x2="445" y2="320" stroke="#d84315" stroke-width="2"/>
  <text x="395" y="310" text-anchor="middle" fill="#fff" font-size="10" font-weight="bold">Post DB</text>
  <!-- Feed Service to Ranking Service -->
  <line x1="395" y1="140" x2="395" y2="70" stroke="#333" stroke-width="2" marker-end="url(#a2)"/>
  <rect x="340" y="20" width="110" height="50" rx="8" fill="#673ab7" stroke="#4527a0" stroke-width="2"/>
  <text x="395" y="50" text-anchor="middle" fill="#fff" font-size="12" font-weight="bold">Ranking Svc</text>
  <text x="395" y="68" text-anchor="middle" fill="#555" font-size="9">3. Rank &amp; filter</text>
  <!-- Images from CDN -->
  <line x1="740" y1="170" x2="820" y2="170" stroke="#333" stroke-width="2" marker-end="url(#a2)"/>
  <text x="780" y="160" text-anchor="middle" fill="#555" font-size="9">4. Images</text>
  <rect x="820" y="140" width="80" height="60" rx="8" fill="#607d8b" stroke="#37474f" stroke-width="2"/>
  <text x="860" y="175" text-anchor="middle" fill="#fff" font-size="13" font-weight="bold">CDN</text>
  <line x1="640" y1="170" x2="740" y2="170" stroke="#aaa" stroke-width="1" stroke-dasharray="5,3"/>
</svg>
</div>

<div class="example">
<h4>Example: User opens Instagram home feed</h4>
<p>Bob opens the Instagram app. The client sends <strong>GET /api/v1/feed?cursor=&lt;last_seen_id&gt;&amp;limit=20</strong> to the <strong>API Gateway</strong>, which routes to the <strong>Feed Service</strong>. The Feed Service retrieves Bob's pre-computed list of post IDs from the <strong>Feed Cache</strong> (Redis list). It then <strong>hydrates</strong> these post IDs by fetching full post details (caption, like count, media URLs, author info) from the <strong>Post DB</strong> with a multi-get query. If Bob follows celebrities, the Feed Service also fetches recent posts from those celebrities at read time (fan-out on read) and merges them. The combined list is sent to the <strong>Ranking Service</strong>, which re-ranks posts based on engagement signals (likes, comments, user affinity). The top 20 posts are returned to the client. The client then loads images directly from the <strong>CDN</strong> using the media URLs.</p>
</div>

<div class="example">
<h4>Example: Infinite scroll (pagination)</h4>
<p>Bob scrolls to the bottom of his feed and the client requests the next page: <strong>GET /api/v1/feed?cursor=post_12345&amp;limit=20</strong>. The Feed Service uses the cursor (last seen post_id) to fetch the next 20 post IDs from Redis (LRANGE command with offset). Hydration and ranking proceed as before.</p>
</div>

<div class="deep-dive">
<h4>Feed Service</h4>
<p><strong>Protocol:</strong> HTTPS GET.</p>
<p><strong>Input:</strong> user_id (from JWT), cursor (for pagination), limit.</p>
<p><strong>Output:</strong> <code>{posts: [{post_id, user_id, username, avatar_url, media_urls, caption, like_count, comment_count, created_at, is_liked}], next_cursor}</code></p>
<p>Uses cursor-based pagination (not offset-based) for consistency in a constantly updating feed.</p>
</div>

<div class="deep-dive">
<h4>Ranking Service</h4>
<p>ML-based service that scores and ranks feed items. Features include: recency, engagement rate, user-author affinity (how often Bob interacts with Alice's posts), content type preference, and diversity. Runs a lightweight model for real-time scoring.</p>
</div>

<!-- ==================== FLOW 3: LIKING A POST ==================== -->
<h2>Flow 3: Liking a Post</h2>
<div class="diagram">
<svg viewBox="0 0 900 350" xmlns="http://www.w3.org/2000/svg">
  <defs><marker id="a3" viewBox="0 0 10 10" refX="9" refY="5" markerWidth="6" markerHeight="6" orient="auto"><path d="M0 0L10 5L0 10z" fill="#333"/></marker></defs>
  <rect x="10" y="130" width="90" height="60" rx="8" fill="#4caf50" stroke="#388e3c" stroke-width="2"/>
  <text x="55" y="165" text-anchor="middle" fill="#fff" font-size="13" font-weight="bold">User</text>
  <line x1="100" y1="160" x2="180" y2="160" stroke="#333" stroke-width="2" marker-end="url(#a3)"/>
  <text x="140" y="150" text-anchor="middle" fill="#555" font-size="9">POST /like</text>
  <rect x="180" y="130" width="90" height="60" rx="8" fill="#ff9800" stroke="#f57c00" stroke-width="2"/>
  <text x="225" y="158" text-anchor="middle" fill="#fff" font-size="11" font-weight="bold">API</text>
  <text x="225" y="172" text-anchor="middle" fill="#fff" font-size="11" font-weight="bold">Gateway</text>
  <line x1="270" y1="160" x2="350" y2="160" stroke="#333" stroke-width="2" marker-end="url(#a3)"/>
  <rect x="350" y="130" width="110" height="60" rx="8" fill="#2196f3" stroke="#1565c0" stroke-width="2"/>
  <text x="405" y="158" text-anchor="middle" fill="#fff" font-size="12" font-weight="bold">Like</text>
  <text x="405" y="173" text-anchor="middle" fill="#fff" font-size="12" font-weight="bold">Service</text>
  <!-- To Like DB -->
  <line x1="405" y1="190" x2="405" y2="260" stroke="#333" stroke-width="2" marker-end="url(#a3)"/>
  <ellipse cx="405" cy="270" rx="50" ry="12" fill="#ff5722" stroke="#d84315" stroke-width="2"/>
  <rect x="355" y="270" width="100" height="30" fill="#ff5722" stroke="#d84315" stroke-width="2"/>
  <ellipse cx="405" cy="300" rx="50" ry="12" fill="#e64a19" stroke="#d84315" stroke-width="2"/>
  <line x1="355" y1="270" x2="355" y2="300" stroke="#d84315" stroke-width="2"/>
  <line x1="455" y1="270" x2="455" y2="300" stroke="#d84315" stroke-width="2"/>
  <text x="405" y="290" text-anchor="middle" fill="#fff" font-size="10" font-weight="bold">Like DB</text>
  <!-- To Like Count Cache -->
  <line x1="460" y1="160" x2="540" y2="160" stroke="#333" stroke-width="2" marker-end="url(#a3)"/>
  <ellipse cx="600" cy="150" rx="50" ry="12" fill="#009688" stroke="#00695c" stroke-width="2"/>
  <rect x="550" y="150" width="100" height="30" fill="#009688" stroke="#00695c" stroke-width="2"/>
  <ellipse cx="600" cy="180" rx="50" ry="12" fill="#00796b" stroke="#00695c" stroke-width="2"/>
  <line x1="550" y1="150" x2="550" y2="180" stroke="#00695c" stroke-width="2"/>
  <line x1="650" y1="150" x2="650" y2="180" stroke="#00695c" stroke-width="2"/>
  <text x="600" y="168" text-anchor="middle" fill="#fff" font-size="9" font-weight="bold">Count Cache</text>
  <text x="600" y="195" text-anchor="middle" fill="#555" font-size="9">INCR post:{id}:likes</text>
  <!-- To Notification Queue -->
  <line x1="405" y1="130" x2="405" y2="60" stroke="#333" stroke-width="2" marker-end="url(#a3)"/>
  <rect x="350" y="10" width="110" height="50" rx="8" fill="#9c27b0" stroke="#6a1b9a" stroke-width="2"/>
  <text x="405" y="40" text-anchor="middle" fill="#fff" font-size="11" font-weight="bold">Notif Queue</text>
</svg>
</div>

<div class="example">
<h4>Example: User likes a post</h4>
<p>Bob double-taps Alice's sunset photo. The client sends <strong>POST /api/v1/posts/{post_id}/like</strong> with <code>{user_id: bob_id}</code> to the API Gateway â†’ <strong>Like Service</strong>. The Like Service writes a like record to the <strong>Like DB</strong> (Cassandra: partition by post_id, clustering by user_id) to prevent duplicate likes. It atomically increments the like count in the <strong>Count Cache</strong> (Redis INCR). It also publishes a <code>POST_LIKED</code> event to the <strong>Notification Queue</strong> (Kafka) so Alice receives a "Bob liked your photo" notification.</p>
</div>

<div class="example">
<h4>Example: User unlikes a post</h4>
<p>Bob taps the heart again to unlike. The client sends <strong>DELETE /api/v1/posts/{post_id}/like</strong>. The Like Service deletes the like record from the Like DB and decrements the count in Redis (DECR). No notification is sent for unlikes.</p>
</div>

<!-- ==================== OVERALL COMBINED FLOW ==================== -->
<h2>Overall Combined Flow</h2>
<div class="diagram">
<svg viewBox="0 0 1200 600" xmlns="http://www.w3.org/2000/svg">
  <defs><marker id="a4" viewBox="0 0 10 10" refX="9" refY="5" markerWidth="6" markerHeight="6" orient="auto"><path d="M0 0L10 5L0 10z" fill="#333"/></marker></defs>
  <!-- Client -->
  <rect x="10" y="250" width="80" height="55" rx="8" fill="#4caf50" stroke="#388e3c" stroke-width="2"/>
  <text x="50" y="282" text-anchor="middle" fill="#fff" font-size="12" font-weight="bold">Client</text>
  <!-- API Gateway -->
  <line x1="90" y1="278" x2="150" y2="278" stroke="#333" stroke-width="2" marker-end="url(#a4)"/>
  <rect x="150" y="250" width="80" height="55" rx="8" fill="#ff9800" stroke="#f57c00" stroke-width="2"/>
  <text x="190" y="275" text-anchor="middle" fill="#fff" font-size="10" font-weight="bold">API</text>
  <text x="190" y="288" text-anchor="middle" fill="#fff" font-size="10" font-weight="bold">Gateway</text>
  <!-- Post Service -->
  <line x1="230" y1="260" x2="300" y2="160" stroke="#333" stroke-width="1.5" marker-end="url(#a4)"/>
  <rect x="300" y="130" width="100" height="50" rx="8" fill="#2196f3" stroke="#1565c0" stroke-width="2"/>
  <text x="350" y="160" text-anchor="middle" fill="#fff" font-size="11" font-weight="bold">Post Svc</text>
  <!-- Feed Service -->
  <line x1="230" y1="278" x2="300" y2="278" stroke="#333" stroke-width="1.5" marker-end="url(#a4)"/>
  <rect x="300" y="253" width="100" height="50" rx="8" fill="#2196f3" stroke="#1565c0" stroke-width="2"/>
  <text x="350" y="283" text-anchor="middle" fill="#fff" font-size="11" font-weight="bold">Feed Svc</text>
  <!-- Like Service -->
  <line x1="230" y1="295" x2="300" y2="380" stroke="#333" stroke-width="1.5" marker-end="url(#a4)"/>
  <rect x="300" y="360" width="100" height="50" rx="8" fill="#2196f3" stroke="#1565c0" stroke-width="2"/>
  <text x="350" y="390" text-anchor="middle" fill="#fff" font-size="11" font-weight="bold">Like Svc</text>
  <!-- User Service -->
  <line x1="230" y1="250" x2="300" y2="65" stroke="#333" stroke-width="1.5" marker-end="url(#a4)"/>
  <rect x="300" y="40" width="100" height="50" rx="8" fill="#2196f3" stroke="#1565c0" stroke-width="2"/>
  <text x="350" y="70" text-anchor="middle" fill="#fff" font-size="11" font-weight="bold">User Svc</text>
  <!-- Media Service -->
  <line x1="350" y1="130" x2="350" y2="40" stroke="#aaa" stroke-width="1" stroke-dasharray="4,3"/>
  <line x1="400" y1="55" x2="480" y2="55" stroke="#333" stroke-width="1.5" marker-end="url(#a4)"/>
  <rect x="480" y="30" width="90" height="50" rx="8" fill="#00bcd4" stroke="#00838f" stroke-width="2"/>
  <text x="525" y="60" text-anchor="middle" fill="#fff" font-size="11" font-weight="bold">Media Svc</text>
  <!-- S3 -->
  <line x1="570" y1="55" x2="630" y2="55" stroke="#333" stroke-width="1.5" marker-end="url(#a4)"/>
  <rect x="630" y="40" width="60" height="30" rx="5" fill="#795548" stroke="#4e342e" stroke-width="1.5"/>
  <text x="660" y="60" text-anchor="middle" fill="#fff" font-size="10" font-weight="bold">S3</text>
  <!-- CDN -->
  <line x1="690" y1="55" x2="740" y2="55" stroke="#333" stroke-width="1.5" marker-end="url(#a4)"/>
  <rect x="740" y="40" width="60" height="30" rx="5" fill="#607d8b" stroke="#37474f" stroke-width="1.5"/>
  <text x="770" y="60" text-anchor="middle" fill="#fff" font-size="10" font-weight="bold">CDN</text>
  <!-- Post DB -->
  <line x1="400" y1="155" x2="480" y2="155" stroke="#333" stroke-width="1.5" marker-end="url(#a4)"/>
  <ellipse cx="530" cy="148" rx="40" ry="10" fill="#ff5722" stroke="#d84315" stroke-width="1.5"/>
  <rect x="490" y="148" width="80" height="25" fill="#ff5722" stroke="#d84315" stroke-width="1.5"/>
  <ellipse cx="530" cy="173" rx="40" ry="10" fill="#e64a19" stroke="#d84315" stroke-width="1.5"/>
  <line x1="490" y1="148" x2="490" y2="173" stroke="#d84315" stroke-width="1.5"/>
  <line x1="570" y1="148" x2="570" y2="173" stroke="#d84315" stroke-width="1.5"/>
  <text x="530" y="165" text-anchor="middle" fill="#fff" font-size="9" font-weight="bold">Post DB</text>
  <!-- Kafka -->
  <line x1="400" y1="170" x2="480" y2="220" stroke="#333" stroke-width="1.5" marker-end="url(#a4)"/>
  <rect x="480" y="200" width="100" height="45" rx="8" fill="#9c27b0" stroke="#6a1b9a" stroke-width="2"/>
  <text x="530" y="227" text-anchor="middle" fill="#fff" font-size="10" font-weight="bold">Kafka</text>
  <!-- Fan-out Service -->
  <line x1="580" y1="222" x2="650" y2="222" stroke="#333" stroke-width="1.5" marker-end="url(#a4)"/>
  <rect x="650" y="200" width="100" height="45" rx="8" fill="#673ab7" stroke="#4527a0" stroke-width="2"/>
  <text x="700" y="227" text-anchor="middle" fill="#fff" font-size="10" font-weight="bold">Fan-out Svc</text>
  <!-- Feed Cache -->
  <line x1="400" y1="278" x2="480" y2="278" stroke="#333" stroke-width="1.5" marker-end="url(#a4)"/>
  <ellipse cx="530" cy="270" rx="40" ry="10" fill="#009688" stroke="#00695c" stroke-width="1.5"/>
  <rect x="490" y="270" width="80" height="25" fill="#009688" stroke="#00695c" stroke-width="1.5"/>
  <ellipse cx="530" cy="295" rx="40" ry="10" fill="#00796b" stroke="#00695c" stroke-width="1.5"/>
  <line x1="490" y1="270" x2="490" y2="295" stroke="#00695c" stroke-width="1.5"/>
  <line x1="570" y1="270" x2="570" y2="295" stroke="#00695c" stroke-width="1.5"/>
  <text x="530" y="287" text-anchor="middle" fill="#fff" font-size="9" font-weight="bold">Feed Cache</text>
  <!-- Fan-out to Feed Cache -->
  <line x1="700" y1="245" x2="700" y2="280" stroke="#333" stroke-width="1.5"/>
  <line x1="700" y1="280" x2="570" y2="280" stroke="#333" stroke-width="1.5" marker-end="url(#a4)"/>
  <!-- Like DB -->
  <line x1="400" y1="385" x2="480" y2="385" stroke="#333" stroke-width="1.5" marker-end="url(#a4)"/>
  <ellipse cx="530" cy="378" rx="40" ry="10" fill="#ff5722" stroke="#d84315" stroke-width="1.5"/>
  <rect x="490" y="378" width="80" height="25" fill="#ff5722" stroke="#d84315" stroke-width="1.5"/>
  <ellipse cx="530" cy="403" rx="40" ry="10" fill="#e64a19" stroke="#d84315" stroke-width="1.5"/>
  <line x1="490" y1="378" x2="490" y2="403" stroke="#d84315" stroke-width="1.5"/>
  <line x1="570" y1="378" x2="570" y2="403" stroke="#d84315" stroke-width="1.5"/>
  <text x="530" y="395" text-anchor="middle" fill="#fff" font-size="9" font-weight="bold">Like DB</text>
  <!-- Count Cache -->
  <line x1="400" y1="370" x2="480" y2="340" stroke="#333" stroke-width="1.5" marker-end="url(#a4)"/>
  <ellipse cx="530" cy="328" rx="45" ry="10" fill="#009688" stroke="#00695c" stroke-width="1.5"/>
  <rect x="485" y="328" width="90" height="22" fill="#009688" stroke="#00695c" stroke-width="1.5"/>
  <ellipse cx="530" cy="350" rx="45" ry="10" fill="#00796b" stroke="#00695c" stroke-width="1.5"/>
  <line x1="485" y1="328" x2="485" y2="350" stroke="#00695c" stroke-width="1.5"/>
  <line x1="575" y1="328" x2="575" y2="350" stroke="#00695c" stroke-width="1.5"/>
  <text x="530" y="343" text-anchor="middle" fill="#fff" font-size="8" font-weight="bold">Count Cache</text>
  <!-- User DB -->
  <line x1="400" y1="65" x2="480" y2="100" stroke="#333" stroke-width="1.5" marker-end="url(#a4)"/>
  <ellipse cx="530" cy="95" rx="40" ry="10" fill="#3f51b5" stroke="#1a237e" stroke-width="1.5"/>
  <rect x="490" y="95" width="80" height="25" fill="#3f51b5" stroke="#1a237e" stroke-width="1.5"/>
  <ellipse cx="530" cy="120" rx="40" ry="10" fill="#283593" stroke="#1a237e" stroke-width="1.5"/>
  <line x1="490" y1="95" x2="490" y2="120" stroke="#1a237e" stroke-width="1.5"/>
  <line x1="570" y1="95" x2="570" y2="120" stroke="#1a237e" stroke-width="1.5"/>
  <text x="530" y="112" text-anchor="middle" fill="#fff" font-size="9" font-weight="bold">User DB</text>
  <!-- Ranking Service -->
  <rect x="650" y="260" width="100" height="40" rx="8" fill="#673ab7" stroke="#4527a0" stroke-width="1.5"/>
  <text x="700" y="285" text-anchor="middle" fill="#fff" font-size="10" font-weight="bold">Ranking Svc</text>
  <line x1="570" y1="282" x2="650" y2="282" stroke="#aaa" stroke-width="1" stroke-dasharray="4,3"/>
  <!-- Notification Service -->
  <rect x="650" y="360" width="100" height="40" rx="8" fill="#e91e63" stroke="#ad1457" stroke-width="1.5"/>
  <text x="700" y="385" text-anchor="middle" fill="#fff" font-size="10" font-weight="bold">Notif Svc</text>
  <line x1="530" y1="222" x2="530" y2="360" stroke="#aaa" stroke-width="1" stroke-dasharray="4,3"/>
  <line x1="530" y1="360" x2="530" y2="385" stroke="#aaa" stroke-width="1" stroke-dasharray="4,3"/>
  <line x1="580" y1="385" x2="650" y2="385" stroke="#333" stroke-width="1.5" marker-end="url(#a4)"/>
</svg>
</div>

<div class="example">
<h4>Combined Example</h4>
<p>Alice uploads a photo â†’ Post Service stores metadata in Post DB, media in S3/CDN, triggers fan-out via Kafka â†’ Fan-out Service populates followers' Feed Caches. Bob opens Instagram â†’ Feed Service reads post IDs from Feed Cache, hydrates from Post DB, ranks via Ranking Service, returns feed. Bob double-taps Alice's photo â†’ Like Service writes to Like DB, increments Count Cache, publishes notification event â†’ Notification Service sends "Bob liked your photo" to Alice.</p>
</div>

<!-- ==================== SCHEMA ==================== -->
<h2>Database Schema</h2>

<h3>SQL Tables (PostgreSQL)</h3>

<h4>1. users</h4>
<table>
  <tr><th>Field</th><th>Type</th><th>Key</th><th>Description</th></tr>
  <tr><td>user_id</td><td>BIGINT</td><td><span class="tag tag-pk">PK</span></td><td>Auto-increment unique user ID</td></tr>
  <tr><td>username</td><td>VARCHAR(30)</td><td><span class="tag tag-idx">UNIQUE INDEX (Hash)</span></td><td>Unique username</td></tr>
  <tr><td>email</td><td>VARCHAR(255)</td><td><span class="tag tag-idx">UNIQUE INDEX (Hash)</span></td><td>User email</td></tr>
  <tr><td>password_hash</td><td>VARCHAR(255)</td><td></td><td>Bcrypt hashed password</td></tr>
  <tr><td>display_name</td><td>VARCHAR(100)</td><td></td><td>Display name</td></tr>
  <tr><td>bio</td><td>TEXT</td><td></td><td>User biography</td></tr>
  <tr><td>avatar_url</td><td>TEXT</td><td></td><td>Profile picture CDN URL</td></tr>
  <tr><td>follower_count</td><td>INT</td><td></td><td>Denormalized follower count</td></tr>
  <tr><td>following_count</td><td>INT</td><td></td><td>Denormalized following count</td></tr>
  <tr><td>post_count</td><td>INT</td><td></td><td>Denormalized post count</td></tr>
  <tr><td>created_at</td><td>TIMESTAMP</td><td></td><td>Registration time</td></tr>
</table>
<p><strong>Why SQL:</strong> User data requires strong consistency (unique username/email enforcement), ACID transactions for registration, and relational queries for profile data.</p>
<p><strong>Index:</strong> Hash index on <code>username</code> and <code>email</code> for O(1) lookups during login and registration. No range queries needed on these fields.</p>
<p><strong>Denormalization:</strong> <code>follower_count</code>, <code>following_count</code>, and <code>post_count</code> are denormalized from the follows and posts tables. This avoids expensive COUNT(*) queries on every profile view. The counts are updated via atomic increment/decrement when follows/posts are created/deleted.</p>
<p><strong>Sharding:</strong> Hash-based sharding on <code>user_id</code>. Username lookups use a global secondary index or a separate usernameâ†’user_id mapping table.</p>
<p><strong>Read/Write:</strong> Written on registration, profile update. Read on login, profile view, feed hydration (author info).</p>

<h4>2. follows</h4>
<table>
  <tr><th>Field</th><th>Type</th><th>Key</th><th>Description</th></tr>
  <tr><td>follower_id</td><td>BIGINT</td><td><span class="tag tag-pk">PK</span> <span class="tag tag-fk">FK â†’ users</span></td><td>The user who follows</td></tr>
  <tr><td>followee_id</td><td>BIGINT</td><td><span class="tag tag-pk">PK</span> <span class="tag tag-fk">FK â†’ users</span></td><td>The user being followed</td></tr>
  <tr><td>created_at</td><td>TIMESTAMP</td><td></td><td>When the follow happened</td></tr>
</table>
<p><strong>Index:</strong> Composite PK on (<code>follower_id</code>, <code>followee_id</code>) prevents duplicate follows. Additional <strong>B-tree index</strong> on <code>followee_id</code> for "get all followers of user X" queries (used by fan-out service).</p>
<p><strong>Why SQL:</strong> Relational data with strong consistency requirements. Must prevent duplicate follows.</p>

<h3>NoSQL Tables (Cassandra)</h3>

<h4>3. posts</h4>
<table>
  <tr><th>Field</th><th>Type</th><th>Key</th><th>Description</th></tr>
  <tr><td>post_id</td><td>UUID (Snowflake)</td><td><span class="tag tag-pk">Partition Key</span></td><td>Globally unique post ID</td></tr>
  <tr><td>user_id</td><td>BIGINT</td><td></td><td>Author's user ID</td></tr>
  <tr><td>media_urls</td><td>LIST&lt;TEXT&gt;</td><td></td><td>CDN URLs for images/videos</td></tr>
  <tr><td>caption</td><td>TEXT</td><td></td><td>Post caption</td></tr>
  <tr><td>hashtags</td><td>SET&lt;TEXT&gt;</td><td></td><td>Extracted hashtags</td></tr>
  <tr><td>location</td><td>TEXT</td><td></td><td>Location tag</td></tr>
  <tr><td>like_count</td><td>COUNTER</td><td></td><td>Denormalized like count</td></tr>
  <tr><td>comment_count</td><td>COUNTER</td><td></td><td>Denormalized comment count</td></tr>
  <tr><td>created_at</td><td>TIMESTAMP</td><td></td><td>Post creation time</td></tr>
</table>
<p><strong>Why NoSQL:</strong> Posts are read-heavy (billions of reads/day from feeds). Cassandra provides low-latency reads with horizontal scaling. Each post is self-contained (no joins needed).</p>

<h4>4. user_posts (timeline table)</h4>
<table>
  <tr><th>Field</th><th>Type</th><th>Key</th><th>Description</th></tr>
  <tr><td>user_id</td><td>BIGINT</td><td><span class="tag tag-pk">Partition Key</span></td><td>The author</td></tr>
  <tr><td>post_id</td><td>TimeUUID</td><td><span class="tag tag-pk">Clustering Key DESC</span></td><td>Post ID (sorted by time descending)</td></tr>
</table>
<p><strong>Why:</strong> Denormalized table for "get all posts by user X" (profile grid). Avoids secondary index on the posts table.</p>

<h4>5. likes</h4>
<table>
  <tr><th>Field</th><th>Type</th><th>Key</th><th>Description</th></tr>
  <tr><td>post_id</td><td>UUID</td><td><span class="tag tag-pk">Partition Key</span></td><td>The liked post</td></tr>
  <tr><td>user_id</td><td>BIGINT</td><td><span class="tag tag-pk">Clustering Key</span></td><td>The user who liked</td></tr>
  <tr><td>created_at</td><td>TIMESTAMP</td><td></td><td>When the like happened</td></tr>
</table>
<p><strong>Why NoSQL:</strong> Like data is extremely high-volume. Partition by post_id gives efficient "did user X like post Y?" checks and "get all likers of post Z" queries.</p>

<h4>6. comments</h4>
<table>
  <tr><th>Field</th><th>Type</th><th>Key</th><th>Description</th></tr>
  <tr><td>post_id</td><td>UUID</td><td><span class="tag tag-pk">Partition Key</span></td><td>The post being commented on</td></tr>
  <tr><td>comment_id</td><td>TimeUUID</td><td><span class="tag tag-pk">Clustering Key</span></td><td>Chronologically sorted</td></tr>
  <tr><td>user_id</td><td>BIGINT</td><td></td><td>Commenter</td></tr>
  <tr><td>text</td><td>TEXT</td><td></td><td>Comment text</td></tr>
  <tr><td>created_at</td><td>TIMESTAMP</td><td></td><td>Comment time</td></tr>
</table>

<!-- ==================== CACHE ==================== -->
<h2>Cache Deep Dive</h2>

<div class="deep-dive">
<h4>Feed Cache (Redis)</h4>
<p><strong>Purpose:</strong> Pre-computed feed for each user. Stores a list of post_ids (last ~800 posts).</p>
<p><strong>Data structure:</strong> Redis Sorted Set per user, scored by timestamp. <code>ZREVRANGE user:{id}:feed 0 19</code> gets the top 20.</p>
<p><strong>Caching strategy:</strong> <strong>Write-through</strong> â€“ When a new post is created, the Fan-out Service writes to the Feed Cache as part of the fan-out process. This ensures the feed is always up-to-date.</p>
<p><strong>Eviction policy:</strong> <strong>LRU</strong> at the Redis cluster level. Additionally, each feed is capped at 800 entries (older posts are trimmed via ZREMRANGEBYRANK).</p>
<p><strong>Expiration policy:</strong> TTL = 7 days for inactive users' feeds. Active users' feeds are refreshed continuously by fan-out writes.</p>
</div>

<div class="deep-dive">
<h4>Count Cache (Redis)</h4>
<p><strong>Purpose:</strong> Stores like/comment counts for posts. <code>post:{id}:likes</code>, <code>post:{id}:comments</code>.</p>
<p><strong>Caching strategy:</strong> <strong>Write-through</strong> â€“ Counts are incremented/decremented atomically on every like/comment action using Redis INCR/DECR.</p>
<p><strong>Eviction policy:</strong> LRU. Older posts' counts are evicted and re-fetched from DB on cache miss.</p>
<p><strong>Expiration policy:</strong> TTL = 48 hours. Refreshed from DB if accessed after expiry.</p>
</div>

<!-- ==================== SCALING ==================== -->
<h2>Scaling Considerations</h2>
<h3>Load Balancers</h3>
<ul>
  <li><strong>L7 Load Balancer</strong> in front of the API Gateway â€“ round-robin for stateless HTTP requests. Handles SSL termination, request routing by URL path to appropriate microservices.</li>
  <li><strong>Internal L4 Load Balancers</strong> between microservices (e.g., Feed Service â†’ Post DB read replicas).</li>
</ul>
<h3>Horizontal Scaling</h3>
<ul>
  <li>All services are stateless and horizontally scalable behind load balancers.</li>
  <li>Cassandra: Add nodes; data rebalances automatically.</li>
  <li>PostgreSQL: Read replicas for user lookups; hash sharding for writes.</li>
  <li>Redis: Cluster mode with hash slots.</li>
  <li>Kafka: Add partitions and brokers for throughput.</li>
  <li>CDN: Scales inherently with global edge network.</li>
</ul>

<!-- ==================== TRADEOFFS ==================== -->
<h2>Tradeoffs and Deep Dives</h2>
<div class="tradeoff">
<h4>Fan-out on Write vs. Fan-out on Read</h4>
<p><strong>Fan-out on write:</strong> Pre-compute feeds at post time. Pros: Fast reads (just read from cache). Cons: Expensive for celebrities with millions of followers (writing to millions of caches).</p>
<p><strong>Fan-out on read:</strong> Compute feed at read time by fetching posts from all followed users. Pros: No write amplification. Cons: Slow reads (must query many users' posts and merge).</p>
<p><strong>Our approach:</strong> Hybrid. Fan-out on write for regular users, fan-out on read for celebrities. This balances write amplification and read latency.</p>
</div>

<div class="tradeoff">
<h4>Eventual Consistency for Feeds</h4>
<p>Feed updates are eventually consistent â€” there's a brief delay between post creation and it appearing in all followers' feeds. This is acceptable because users won't notice a 1-2 second delay. The alternative (synchronous fan-out) would make post uploads slow.</p>
</div>

<h2>Alternative Approaches</h2>
<div class="alternative">
<h4>Alternative 1: Graph Database for Social Graph</h4>
<p>Neo4j or similar graph DB for follows/followers. Efficient for graph traversals (friends-of-friends, recommendations). Not chosen because: the social graph is relatively simple (just follow edges), and sharding graph databases is notoriously difficult at Instagram's scale. SQL with denormalized counts works well enough.</p>
</div>

<div class="alternative">
<h4>Alternative 2: Pull-based Feed (No Pre-computation)</h4>
<p>Compute feed entirely at read time. Simpler architecture, no fan-out infrastructure needed. Not chosen because read latency would be too high â€” merging posts from 500+ followed users at request time is slow.</p>
</div>

<div class="alternative">
<h4>Alternative 3: Single Monolithic Database</h4>
<p>Use a single PostgreSQL instance for everything. Simpler development. Not chosen because it cannot scale to billions of posts and trillions of likes. Polyglot persistence (SQL for users, NoSQL for posts/likes) leverages each database's strengths.</p>
</div>

<h2>Additional Information</h2>
<h3>Snowflake IDs</h3>
<p>Post IDs use a Snowflake-like ID generator: 64-bit IDs composed of timestamp + machine ID + sequence number. This ensures globally unique, time-sortable IDs without a central coordination service.</p>

<h3>Image Processing Pipeline</h3>
<p>When a photo is uploaded, the Media Service creates multiple resolutions (150px, 320px, 640px, 1080px) and converts to WebP format for ~30% smaller file sizes. This happens asynchronously â€” the user sees their post immediately while processing continues in the background.</p>

<h3>Rate Limiting</h3>
<p>The API Gateway enforces rate limits: 200 API calls/hour per user, 30 posts/day, 100 likes/minute. This prevents spam and abuse. Implemented with a sliding window counter in Redis.</p>

</div>
</body>
</html>
