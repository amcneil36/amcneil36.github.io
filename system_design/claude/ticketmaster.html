<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>System Design: Ticketmaster</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        h1 {
            color: #1a73e8;
            border-bottom: 3px solid #1a73e8;
            padding-bottom: 10px;
        }
        h2 {
            color: #185abc;
            border-bottom: 2px solid #185abc;
            padding-bottom: 8px;
            margin-top: 40px;
        }
        h3 {
            color: #1967d2;
            margin-top: 30px;
        }
        h4 {
            color: #4285f4;
            margin-top: 20px;
        }
        .section {
            background: white;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .diagram-container {
            background: #fff;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            overflow-x: auto;
        }
        .mermaid {
            display: flex;
            justify-content: center;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        th {
            background-color: #1a73e8;
            color: white;
        }
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        tr:hover {
            background-color: #f1f1f1;
        }
        code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
        }
        .example-box {
            background-color: #e8f5e9;
            border-left: 4px solid #4caf50;
            padding: 15px;
            margin: 15px 0;
            border-radius: 0 8px 8px 0;
        }
        .warning-box {
            background-color: #fff3e0;
            border-left: 4px solid #ff9800;
            padding: 15px;
            margin: 15px 0;
            border-radius: 0 8px 8px 0;
        }
        .info-box {
            background-color: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 15px;
            margin: 15px 0;
            border-radius: 0 8px 8px 0;
        }
        .critical-box {
            background-color: #ffebee;
            border-left: 4px solid #f44336;
            padding: 15px;
            margin: 15px 0;
            border-radius: 0 8px 8px 0;
        }
        ul, ol {
            margin: 10px 0;
            padding-left: 25px;
        }
        li {
            margin: 5px 0;
        }
        .api-endpoint {
            background-color: #263238;
            color: #80cbc4;
            padding: 10px 15px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            margin: 10px 0;
        }
        .toc {
            background: #fff;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 30px;
        }
        .toc ul {
            list-style-type: none;
            padding-left: 20px;
        }
        .toc > ul {
            padding-left: 0;
        }
        .toc a {
            color: #1a73e8;
            text-decoration: none;
        }
        .toc a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <h1>üé´ System Design: Ticketmaster</h1>
    
    <div class="toc">
        <h2>Table of Contents</h2>
        <ul>
            <li><a href="#requirements">1. Requirements</a></li>
            <li><a href="#flow-diagrams">2. Flow Diagrams</a>
                <ul>
                    <li><a href="#flow1">Flow 1: Event Discovery & Search</a></li>
                    <li><a href="#flow2">Flow 2: Seat Selection & Temporary Hold</a></li>
                    <li><a href="#flow3">Flow 3: Ticket Booking & Payment</a></li>
                    <li><a href="#flow4">Flow 4: Ticket Delivery & Notifications</a></li>
                    <li><a href="#flow5">Flow 5: Waiting Room / Virtual Queue</a></li>
                    <li><a href="#overall-flow">Overall Combined Flow</a></li>
                </ul>
            </li>
            <li><a href="#schema">3. Database Schema</a></li>
            <li><a href="#caching">4. Caching Strategy</a></li>
            <li><a href="#cdn">5. CDN Strategy</a></li>
            <li><a href="#scaling">6. Scaling Considerations</a></li>
            <li><a href="#tradeoffs">7. Tradeoffs & Deep Dives</a></li>
            <li><a href="#alternatives">8. Alternative Approaches</a></li>
            <li><a href="#additional">9. Additional Considerations</a></li>
            <li><a href="#vendors">10. Vendor Recommendations</a></li>
        </ul>
    </div>

    <!-- REQUIREMENTS SECTION -->
    <div class="section" id="requirements">
        <h2>1. Requirements</h2>
        
        <h3>1.1 Functional Requirements</h3>
        <ol>
            <li><strong>Event Discovery & Search</strong>
                <ul>
                    <li>Users can browse and search for events by name, artist, venue, date, location, category</li>
                    <li>Users can filter events by price range, date range, and genre</li>
                    <li>Users can view event details including venue map, pricing tiers, and availability</li>
                </ul>
            </li>
            <li><strong>Seat Selection</strong>
                <ul>
                    <li>Users can view interactive venue seating maps</li>
                    <li>Users can see real-time seat availability</li>
                    <li>Users can select specific seats or "best available"</li>
                    <li>Selected seats are temporarily held during checkout process</li>
                </ul>
            </li>
            <li><strong>Ticket Booking & Payment</strong>
                <ul>
                    <li>Users can add tickets to cart with a time-limited hold</li>
                    <li>Users can complete purchase with various payment methods</li>
                    <li>System prevents double-booking of the same seat</li>
                    <li>System handles concurrent booking attempts</li>
                </ul>
            </li>
            <li><strong>Ticket Delivery</strong>
                <ul>
                    <li>Users receive digital tickets via email/app</li>
                    <li>Users can view and manage their tickets in their account</li>
                    <li>QR code/barcode generation for ticket validation</li>
                </ul>
            </li>
            <li><strong>Notifications</strong>
                <ul>
                    <li>Booking confirmation notifications</li>
                    <li>Event reminders</li>
                    <li>Event updates/changes</li>
                </ul>
            </li>
            <li><strong>Virtual Queue (Waiting Room)</strong>
                <ul>
                    <li>Queue system for high-demand events</li>
                    <li>Fair ordering of users during high-traffic sales</li>
                    <li>Position updates and estimated wait time</li>
                </ul>
            </li>
            <li><strong>User Account Management</strong>
                <ul>
                    <li>Registration and login</li>
                    <li>Order history</li>
                    <li>Saved payment methods</li>
                    <li>Favorite artists/venues</li>
                </ul>
            </li>
        </ol>

        <h3>1.2 Non-Functional Requirements</h3>
        <table>
            <tr>
                <th>Requirement</th>
                <th>Target</th>
                <th>Rationale</th>
            </tr>
            <tr>
                <td><strong>Availability</strong></td>
                <td>99.99% (Four 9s)</td>
                <td>Revenue-critical system; downtime during major event sales = significant financial loss and reputation damage</td>
            </tr>
            <tr>
                <td><strong>Latency</strong></td>
                <td>
                    Search: &lt;200ms (p99)<br>
                    Seat Selection: &lt;100ms (p99)<br>
                    Booking: &lt;500ms (p99)
                </td>
                <td>User experience during time-sensitive ticket purchases; reduce cart abandonment</td>
            </tr>
            <tr>
                <td><strong>Consistency</strong></td>
                <td>Strong consistency for seat inventory</td>
                <td>Cannot allow double-booking of the same seat</td>
            </tr>
            <tr>
                <td><strong>Scalability</strong></td>
                <td>Handle 10M+ concurrent users during peak sales</td>
                <td>Taylor Swift Eras Tour had 14M+ users in queue; need to handle extreme spikes</td>
            </tr>
            <tr>
                <td><strong>Throughput</strong></td>
                <td>100K+ ticket transactions per second during peak</td>
                <td>High-demand events sell out in minutes</td>
            </tr>
            <tr>
                <td><strong>Durability</strong></td>
                <td>Zero data loss for completed transactions</td>
                <td>Financial and legal requirements</td>
            </tr>
            <tr>
                <td><strong>Fairness</strong></td>
                <td>First-come-first-served with verified ordering</td>
                <td>Prevent bots and ensure fair access for genuine customers</td>
            </tr>
            <tr>
                <td><strong>Security</strong></td>
                <td>PCI-DSS compliance, bot prevention, fraud detection</td>
                <td>Handle payment data; prevent scalping bots</td>
            </tr>
        </table>

        <h3>1.3 Capacity Estimation</h3>
        <div class="info-box">
            <h4>Traffic Estimates</h4>
            <ul>
                <li><strong>Daily Active Users (DAU):</strong> 5 million (normal) / 50 million (peak event)</li>
                <li><strong>Events:</strong> 500,000 active events at any time</li>
                <li><strong>Tickets per event:</strong> Average 20,000 seats per venue</li>
                <li><strong>Peak concurrent users:</strong> 10-15 million during major on-sales</li>
                <li><strong>Search queries:</strong> 50,000 QPS (normal) / 500,000 QPS (peak)</li>
                <li><strong>Booking transactions:</strong> 1,000 TPS (normal) / 100,000 TPS (peak)</li>
            </ul>
            <h4>Storage Estimates</h4>
            <ul>
                <li><strong>Events data:</strong> 500K events √ó 10KB = ~5GB</li>
                <li><strong>Tickets/Seats:</strong> 500K events √ó 20K seats √ó 500B = ~5TB</li>
                <li><strong>User data:</strong> 100M users √ó 5KB = ~500GB</li>
                <li><strong>Order history:</strong> 500M orders/year √ó 2KB = ~1TB/year</li>
                <li><strong>Event images/media:</strong> 500K events √ó 10MB = ~5TB (served via CDN)</li>
            </ul>
        </div>
    </div>

    <!-- FLOW DIAGRAMS SECTION -->
    <div class="section" id="flow-diagrams">
        <h2>2. Flow Diagrams</h2>

        <!-- FLOW 1: Event Discovery -->
        <div id="flow1">
            <h3>Flow 1: Event Discovery & Search</h3>
            <p>This flow handles users browsing, searching, and filtering events.</p>
            
            <div class="diagram-container">
                <div class="mermaid">
graph LR
    subgraph Client
        A[Mobile App / Web Browser]
    end
    
    subgraph Edge Layer
        B[CDN]
        C[Load Balancer]
    end
    
    subgraph API Layer
        D[API Gateway]
        E[Search Service]
    end
    
    subgraph Data Layer
        F[Search Index]
        G[(Events DB)]
        H[Cache Layer]
    end
    
    A -->|1. GET /events?q=...| B
    B -->|2. Cache Miss| C
    C -->|3. Route Request| D
    D -->|4. Search Query| E
    E -->|5. Query| F
    E -->|6. Enrich Data| H
    H -->|7. Cache Miss| G
    F -->|8. Results| E
    H -->|9. Event Details| E
    E -->|10. Response| D
    D -->|11. JSON Response| A
                </div>
            </div>

            <div class="example-box">
                <h4>Example 1: Basic Event Search</h4>
                <p><strong>Scenario:</strong> User searches for "Taylor Swift concerts in Los Angeles"</p>
                <ol>
                    <li>User types "Taylor Swift Los Angeles" in the search bar on the mobile app</li>
                    <li>App sends HTTP GET request: <code>GET /api/v1/events?q=taylor+swift&location=los+angeles&type=concert</code></li>
                    <li>Request hits CDN - cache miss for this specific query</li>
                    <li>Load balancer routes to available API Gateway instance</li>
                    <li>API Gateway authenticates request and forwards to Search Service</li>
                    <li>Search Service queries the Search Index with tokenized terms: "taylor", "swift", "los", "angeles", "concert"</li>
                    <li>Search Index returns matching event IDs with relevance scores</li>
                    <li>Search Service checks Cache for event details - partial hit</li>
                    <li>For cache misses, fetches from Events DB</li>
                    <li>Response returned with list of matching events, each containing: event_id, name, venue, date, price_range, thumbnail_url, availability_status</li>
                </ol>
            </div>

            <div class="example-box">
                <h4>Example 2: Filtered Browse</h4>
                <p><strong>Scenario:</strong> User browses rock concerts this weekend under $100</p>
                <ol>
                    <li>User applies filters: Category = "Rock", Date = "This Weekend", Price = "$0-$100"</li>
                    <li>App sends: <code>GET /api/v1/events?category=rock&date_start=2024-03-15&date_end=2024-03-17&price_max=100&location=user_geo</code></li>
                    <li>CDN caches this type of filtered query for 60 seconds (popular filter combinations)</li>
                    <li>Search Index applies faceted search with all filters</li>
                    <li>Returns paginated results sorted by date (default) or relevance</li>
                </ol>
            </div>

            <div class="example-box">
                <h4>Example 3: Event Detail View</h4>
                <p><strong>Scenario:</strong> User clicks on a specific event to view details</p>
                <ol>
                    <li>User taps on "Taylor Swift - Eras Tour - SoFi Stadium" from search results</li>
                    <li>App sends: <code>GET /api/v1/events/evt_12345</code></li>
                    <li>CDN likely has this cached (popular event) - returns immediately</li>
                    <li>If cache miss, API Gateway routes to Search Service</li>
                    <li>Returns full event details: description, venue info, seating chart URL, all price tiers, general availability status, artist info</li>
                </ol>
            </div>

            <h4>Component Deep Dive: Flow 1</h4>
            
            <table>
                <tr>
                    <th>Component</th>
                    <th>Protocol/Type</th>
                    <th>Description</th>
                    <th>Input</th>
                    <th>Output</th>
                </tr>
                <tr>
                    <td><strong>Mobile App / Web Browser</strong></td>
                    <td>HTTPS</td>
                    <td>Client applications (iOS, Android, Web) that users interact with. Renders search UI and displays results.</td>
                    <td>User interactions (search terms, filters, clicks)</td>
                    <td>HTTP requests to backend</td>
                </tr>
                <tr>
                    <td><strong>CDN</strong></td>
                    <td>HTTPS</td>
                    <td>Caches static assets (images, JS, CSS) and cacheable API responses. Geographically distributed edge nodes reduce latency. TTL for search results: 30-60 seconds.</td>
                    <td>HTTP requests from clients</td>
                    <td>Cached responses or forwards to origin</td>
                </tr>
                <tr>
                    <td><strong>Load Balancer</strong></td>
                    <td>HTTPS/HTTP</td>
                    <td>Layer 7 load balancer distributing traffic across API Gateway instances. Uses round-robin with health checks. Terminates SSL.</td>
                    <td>HTTP requests from CDN</td>
                    <td>Routed requests to healthy API instances</td>
                </tr>
                <tr>
                    <td><strong>API Gateway</strong></td>
                    <td>HTTP REST</td>
                    <td>Handles authentication, rate limiting, request validation, API versioning. Routes to appropriate microservice.</td>
                    <td>
                        <code>GET /api/v1/events</code><br>
                        Query params: q, location, category, date_start, date_end, price_min, price_max, page, limit
                    </td>
                    <td>JSON response with event list or single event</td>
                </tr>
                <tr>
                    <td><strong>Search Service</strong></td>
                    <td>HTTP REST / gRPC</td>
                    <td>Stateless service handling search queries. Tokenizes input, queries search index, enriches results with cached data.</td>
                    <td>Search query object with filters</td>
                    <td>Ranked list of event objects</td>
                </tr>
                <tr>
                    <td><strong>Search Index</strong></td>
                    <td>Custom protocol</td>
                    <td>Inverted index optimized for full-text search. Supports geo-spatial queries, faceted search, and relevance scoring. Updated asynchronously when events change.</td>
                    <td>Tokenized search terms, filters</td>
                    <td>Ranked document IDs with scores</td>
                </tr>
                <tr>
                    <td><strong>Cache Layer</strong></td>
                    <td>In-memory key-value</td>
                    <td>Distributed in-memory cache storing hot event data. TTL: 5 minutes for event details, 30 seconds for availability.</td>
                    <td>Cache key (event_id)</td>
                    <td>Serialized event object or cache miss</td>
                </tr>
                <tr>
                    <td><strong>Events DB</strong></td>
                    <td>SQL (Read Replicas)</td>
                    <td>Primary source of truth for event data. Read replicas handle search enrichment queries.</td>
                    <td>SQL queries by event_id</td>
                    <td>Event records</td>
                </tr>
            </table>
        </div>

        <!-- FLOW 2: Seat Selection -->
        <div id="flow2">
            <h3>Flow 2: Seat Selection & Temporary Hold</h3>
            <p>This flow handles users viewing available seats and temporarily holding selected seats.</p>
            
            <div class="diagram-container">
                <div class="mermaid">
graph TB
    subgraph Client
        A[Mobile App / Web Browser]
    end
    
    subgraph Edge Layer
        B[Load Balancer]
    end
    
    subgraph API Layer
        C[API Gateway]
        D[Inventory Service]
    end
    
    subgraph Data Layer
        E[Distributed Lock Manager]
        F[(Inventory DB)]
        G[Cache Layer]
    end
    
    subgraph Async
        H[Hold Expiration Scheduler]
    end
    
    A -->|1. GET /events/{id}/seats| B
    B --> C
    C -->|2. Fetch Availability| D
    D -->|3. Query Inventory| G
    G -->|4. Cache Miss| F
    D -->|5. Return Seat Map| A
    
    A -->|6. POST /seats/hold| B
    B --> C
    C -->|7. Hold Request| D
    D -->|8. Acquire Lock| E
    E -->|9. Lock Acquired| D
    D -->|10. Update Status| F
    D -->|11. Invalidate Cache| G
    D -->|12. Schedule Expiration| H
    D -->|13. Hold Confirmed| A
    
    H -->|14. TTL Expired| D
    D -->|15. Release Seats| F
                </div>
            </div>

            <div class="example-box">
                <h4>Example 1: Viewing Seat Map</h4>
                <p><strong>Scenario:</strong> User views available seats for a concert</p>
                <ol>
                    <li>User navigates to the Taylor Swift concert at SoFi Stadium and taps "View Seats"</li>
                    <li>App sends: <code>GET /api/v1/events/evt_12345/seats?section=all</code></li>
                    <li>API Gateway routes to Inventory Service</li>
                    <li>Inventory Service checks Cache for seat availability bitmap</li>
                    <li>Returns seat map data: section IDs, seat IDs within sections, status (available/held/sold), price per seat</li>
                    <li>App renders interactive SVG seat map with color-coded availability</li>
                    <li>Available seats: Green, Held by others: Yellow, Sold: Gray</li>
                </ol>
            </div>

            <div class="example-box">
                <h4>Example 2: Successful Seat Hold</h4>
                <p><strong>Scenario:</strong> User selects 2 seats and they are held successfully</p>
                <ol>
                    <li>User clicks on seats A-101 and A-102 in Section 112</li>
                    <li>App sends: <code>POST /api/v1/seats/hold</code> with body: <code>{"event_id": "evt_12345", "seats": ["A-101", "A-102"], "section": "112"}</code></li>
                    <li>Inventory Service receives request, validates seats exist and user has valid session</li>
                    <li>Attempts to acquire distributed lock on seats "evt_12345:112:A-101" and "evt_12345:112:A-102"</li>
                    <li>Lock acquired successfully (seats were available)</li>
                    <li>Updates Inventory DB: sets seat status to "HELD", hold_user_id, hold_expires_at (current_time + 10 minutes)</li>
                    <li>Invalidates cache for this event's seat map</li>
                    <li>Schedules hold expiration job for 10 minutes</li>
                    <li>Returns: <code>{"hold_id": "hold_abc123", "seats": ["A-101", "A-102"], "expires_at": "2024-03-15T10:15:00Z", "total_price": 450.00}</code></li>
                    <li>App shows countdown timer: "Complete purchase within 9:58 to keep your seats"</li>
                </ol>
            </div>

            <div class="example-box">
                <h4>Example 3: Seat Hold Conflict</h4>
                <p><strong>Scenario:</strong> User tries to select seats already held by another user</p>
                <ol>
                    <li>User clicks on seats A-103 and A-104 (held by another user 2 minutes ago)</li>
                    <li>App sends: <code>POST /api/v1/seats/hold</code></li>
                    <li>Inventory Service attempts to acquire lock</li>
                    <li>Lock acquisition fails - seats already locked by another session</li>
                    <li>Returns HTTP 409 Conflict: <code>{"error": "SEATS_UNAVAILABLE", "unavailable_seats": ["A-103", "A-104"], "message": "These seats are currently held by another customer"}</code></li>
                    <li>App displays error and suggests nearby available seats</li>
                </ol>
            </div>

            <div class="example-box">
                <h4>Example 4: Hold Expiration</h4>
                <p><strong>Scenario:</strong> User's hold expires without completing purchase</p>
                <ol>
                    <li>User held seats A-101 and A-102 at 10:05 AM with 10-minute expiration</li>
                    <li>User gets distracted and doesn't complete checkout</li>
                    <li>At 10:15 AM, Hold Expiration Scheduler triggers expiration job for hold_abc123</li>
                    <li>Inventory Service releases locks on seats</li>
                    <li>Updates Inventory DB: sets seat status back to "AVAILABLE", clears hold_user_id and hold_expires_at</li>
                    <li>Invalidates cache to reflect availability</li>
                    <li>If user returns to checkout page, they see: "Your hold has expired. Please select seats again."</li>
                </ol>
            </div>

            <h4>Component Deep Dive: Flow 2</h4>
            
            <table>
                <tr>
                    <th>Component</th>
                    <th>Protocol/Type</th>
                    <th>Description</th>
                    <th>Input</th>
                    <th>Output</th>
                </tr>
                <tr>
                    <td><strong>Inventory Service</strong></td>
                    <td>HTTP REST</td>
                    <td>Manages seat inventory, holds, and availability. Stateless, scales horizontally. Critical for consistency.</td>
                    <td>
                        <code>GET /events/{id}/seats</code> - View seats<br>
                        <code>POST /seats/hold</code> - Hold seats<br>
                        <code>DELETE /seats/hold/{id}</code> - Release hold
                    </td>
                    <td>Seat availability map, hold confirmation, release confirmation</td>
                </tr>
                <tr>
                    <td><strong>Distributed Lock Manager</strong></td>
                    <td>In-memory with TTL</td>
                    <td>Provides distributed locking for seat holds. Uses atomic operations (SET NX with TTL). Lock key format: <code>{event_id}:{section}:{seat}</code>. Lock TTL matches hold duration (10 min).</td>
                    <td>Lock key, TTL, requestor ID</td>
                    <td>Lock acquired/denied</td>
                </tr>
                <tr>
                    <td><strong>Inventory DB</strong></td>
                    <td>SQL with Row-Level Locking</td>
                    <td>Stores seat inventory with ACID guarantees. Uses row-level locking for updates. Indexed on (event_id, section, seat_id).</td>
                    <td>SQL queries with SELECT FOR UPDATE</td>
                    <td>Seat records with current status</td>
                </tr>
                <tr>
                    <td><strong>Hold Expiration Scheduler</strong></td>
                    <td>Scheduled Jobs</td>
                    <td>Distributed job scheduler that releases expired holds. Uses sorted set with expiration timestamps. Polls every second for expired holds.</td>
                    <td>Hold ID with expiration timestamp</td>
                    <td>Triggers release callback on expiration</td>
                </tr>
            </table>

            <div class="warning-box">
                <h4>Critical Design Decision: Distributed Locking</h4>
                <p>The Distributed Lock Manager is crucial for preventing double-booking. We use a combination of:</p>
                <ul>
                    <li><strong>Optimistic Locking:</strong> For the initial availability check (fast reads)</li>
                    <li><strong>Distributed Lock:</strong> For the hold operation (prevents race conditions)</li>
                    <li><strong>Database Row Lock:</strong> As a secondary safeguard when updating inventory</li>
                </ul>
                <p>This provides multiple layers of protection against concurrent booking of the same seat.</p>
            </div>
        </div>

        <!-- FLOW 3: Ticket Booking & Payment -->
        <div id="flow3">
            <h3>Flow 3: Ticket Booking & Payment</h3>
            <p>This flow handles the checkout process, payment processing, and ticket confirmation.</p>
            
            <div class="diagram-container">
                <div class="mermaid">
graph TB
    subgraph Client
        A[Mobile App / Web Browser]
    end
    
    subgraph Edge Layer
        B[Load Balancer]
    end
    
    subgraph API Layer
        C[API Gateway]
        D[Booking Service]
        E[Payment Service]
    end
    
    subgraph External
        F[Payment Gateway]
    end
    
    subgraph Data Layer
        G[(Bookings DB)]
        H[(Inventory DB)]
        I[Distributed Lock Manager]
    end
    
    subgraph Async Layer
        J[Message Queue]
        K[Ticket Generator]
        L[Notification Service]
    end
    
    A -->|1. POST /bookings| B
    B --> C
    C -->|2. Create Booking| D
    D -->|3. Validate Hold| I
    D -->|4. Create Pending Booking| G
    D -->|5. Initiate Payment| E
    E -->|6. Process Payment| F
    F -->|7. Payment Result| E
    E -->|8. Payment Confirmed| D
    D -->|9. Convert Hold to Sold| H
    D -->|10. Update Booking Status| G
    D -->|11. Queue Ticket Generation| J
    J --> K
    K -->|12. Generate Tickets| G
    D -->|13. Queue Notification| J
    J --> L
    L -->|14. Send Confirmation| A
    D -->|15. Booking Confirmed| A
                </div>
            </div>

            <div class="example-box">
                <h4>Example 1: Successful Booking</h4>
                <p><strong>Scenario:</strong> User completes purchase successfully</p>
                <ol>
                    <li>User on checkout page with held seats A-101, A-102 (hold_id: hold_abc123)</li>
                    <li>User enters payment info and clicks "Complete Purchase"</li>
                    <li>App sends: <code>POST /api/v1/bookings</code> with body:
                        <pre><code>{
    "hold_id": "hold_abc123",
    "payment_method": {
        "type": "credit_card",
        "token": "tok_visa_4242"
    },
    "billing_address": {...}
}</code></pre>
                    </li>
                    <li>Booking Service validates hold_abc123 is still valid and belongs to this user</li>
                    <li>Creates pending booking record: booking_id = "bk_xyz789", status = "PAYMENT_PENDING"</li>
                    <li>Calls Payment Service: process $450.00 for booking bk_xyz789</li>
                    <li>Payment Service calls external Payment Gateway</li>
                    <li>Payment Gateway returns success: charge_id = "ch_123abc"</li>
                    <li>Booking Service updates Inventory DB: seats A-101, A-102 status = "SOLD", booking_id = "bk_xyz789"</li>
                    <li>Updates booking status to "CONFIRMED", stores charge_id</li>
                    <li>Releases distributed lock (seats are now permanently sold)</li>
                    <li>Publishes message to queue: "GENERATE_TICKETS" for bk_xyz789</li>
                    <li>Publishes message to queue: "SEND_CONFIRMATION" for bk_xyz789</li>
                    <li>Returns to client: <code>{"booking_id": "bk_xyz789", "status": "CONFIRMED", "tickets_url": "/bookings/bk_xyz789/tickets"}</code></li>
                    <li>User sees confirmation screen with order number</li>
                </ol>
            </div>

            <div class="example-box">
                <h4>Example 2: Payment Declined</h4>
                <p><strong>Scenario:</strong> User's payment card is declined</p>
                <ol>
                    <li>User submits payment for held seats</li>
                    <li>Booking Service creates pending booking, calls Payment Service</li>
                    <li>Payment Gateway returns: "CARD_DECLINED" - insufficient funds</li>
                    <li>Payment Service returns failure to Booking Service</li>
                    <li>Booking Service updates booking status to "PAYMENT_FAILED"</li>
                    <li><strong>Important:</strong> Hold is NOT released - user still has time to retry</li>
                    <li>Returns HTTP 402: <code>{"error": "PAYMENT_DECLINED", "message": "Your card was declined. Please try another payment method.", "hold_expires_at": "2024-03-15T10:15:00Z"}</code></li>
                    <li>User can enter different card and retry while hold is still valid</li>
                </ol>
            </div>

            <div class="example-box">
                <h4>Example 3: Hold Expired During Checkout</h4>
                <p><strong>Scenario:</strong> User's hold expires while entering payment info</p>
                <ol>
                    <li>User submits payment, but hold expired 30 seconds ago</li>
                    <li>Booking Service checks hold_abc123 - finds it expired</li>
                    <li>Does NOT proceed with payment</li>
                    <li>Returns HTTP 410 Gone: <code>{"error": "HOLD_EXPIRED", "message": "Your seat hold has expired. Please select seats again."}</code></li>
                    <li>User must start seat selection over</li>
                </ol>
            </div>

            <div class="example-box">
                <h4>Example 4: Idempotent Retry</h4>
                <p><strong>Scenario:</strong> Network timeout during booking, user retries</p>
                <ol>
                    <li>User clicks "Complete Purchase", network times out after 30 seconds</li>
                    <li>User clicks "Complete Purchase" again</li>
                    <li>App sends same request with idempotency key in header: <code>Idempotency-Key: user123-hold_abc123-1234567890</code></li>
                    <li>Booking Service checks idempotency key - finds existing booking bk_xyz789</li>
                    <li>Returns the existing booking result (does NOT charge twice)</li>
                    <li>User sees confirmation</li>
                </ol>
            </div>

            <h4>Component Deep Dive: Flow 3</h4>
            
            <table>
                <tr>
                    <th>Component</th>
                    <th>Protocol/Type</th>
                    <th>Description</th>
                    <th>Input</th>
                    <th>Output</th>
                </tr>
                <tr>
                    <td><strong>Booking Service</strong></td>
                    <td>HTTP REST</td>
                    <td>Orchestrates the booking flow. Validates holds, creates bookings, coordinates with payment. Implements saga pattern for distributed transaction.</td>
                    <td>
                        <code>POST /bookings</code> - Create booking<br>
                        <code>GET /bookings/{id}</code> - Get booking<br>
                        <code>POST /bookings/{id}/cancel</code> - Cancel
                    </td>
                    <td>Booking confirmation with ticket references</td>
                </tr>
                <tr>
                    <td><strong>Payment Service</strong></td>
                    <td>HTTP REST (internal) / HTTPS (external)</td>
                    <td>Handles payment processing. Abstracts multiple payment gateways. PCI-DSS compliant - never logs card numbers. Supports retries and refunds.</td>
                    <td>Payment amount, tokenized card, idempotency key</td>
                    <td>Payment result (success/failure), charge ID</td>
                </tr>
                <tr>
                    <td><strong>Payment Gateway</strong></td>
                    <td>HTTPS REST</td>
                    <td>External payment processor (e.g., Stripe, Adyen). Handles actual card charging. Returns synchronous result.</td>
                    <td>Tokenized payment method, amount, currency</td>
                    <td>Charge result, transaction ID</td>
                </tr>
                <tr>
                    <td><strong>Bookings DB</strong></td>
                    <td>SQL with ACID</td>
                    <td>Stores booking records. Strong consistency required. Contains booking metadata, payment references, user info.</td>
                    <td>Booking objects</td>
                    <td>Booking records</td>
                </tr>
                <tr>
                    <td><strong>Message Queue</strong></td>
                    <td>Async Messaging (Pub/Sub)</td>
                    <td>Decouples booking completion from ticket generation and notifications. At-least-once delivery with deduplication. Supports retries with exponential backoff.</td>
                    <td>Message with booking_id and action type</td>
                    <td>Guaranteed delivery to consumers</td>
                </tr>
                <tr>
                    <td><strong>Ticket Generator</strong></td>
                    <td>Queue Consumer</td>
                    <td>Generates digital tickets with QR codes. Creates unique, cryptographically signed ticket tokens. Stores in database and object storage.</td>
                    <td>Booking ID from queue</td>
                    <td>Generated ticket PDFs and QR codes</td>
                </tr>
            </table>

            <div class="critical-box">
                <h4>Why Message Queue is Used</h4>
                <p>The Message Queue is critical for:</p>
                <ul>
                    <li><strong>Decoupling:</strong> Ticket generation can take 1-2 seconds; we don't want users waiting</li>
                    <li><strong>Reliability:</strong> If ticket generator is down, messages are preserved and processed later</li>
                    <li><strong>Scalability:</strong> Can scale ticket generators independently during high-load periods</li>
                    <li><strong>Retries:</strong> Failed ticket generation can be automatically retried</li>
                </ul>
                <p><strong>Why not direct API call?</strong> Direct calls would block the booking response and create tight coupling. If the ticket service is slow or down, bookings would fail.</p>
                <p><strong>Why not polling?</strong> Polling would waste resources and add latency. Message queues provide push-based, real-time processing.</p>
                <p><strong>Why not WebSocket here?</strong> WebSockets are for client-server real-time communication. This is server-to-server async processing where queues are more appropriate.</p>
            </div>
        </div>

        <!-- FLOW 4: Ticket Delivery & Notifications -->
        <div id="flow4">
            <h3>Flow 4: Ticket Delivery & Notifications</h3>
            <p>This flow handles generating tickets and sending notifications after booking.</p>
            
            <div class="diagram-container">
                <div class="mermaid">
graph TB
    subgraph Async Processing
        A[Message Queue]
        B[Ticket Generator Service]
        C[Notification Service]
    end
    
    subgraph Data Layer
        D[(Bookings DB)]
        E[Object Storage]
        F[Ticket Token Store]
    end
    
    subgraph External
        G[Email Provider]
        H[Push Notification Service]
    end
    
    subgraph Client
        I[Mobile App / Web Browser]
    end
    
    A -->|1. GENERATE_TICKETS message| B
    B -->|2. Fetch Booking Details| D
    B -->|3. Generate QR Code/Barcode| F
    B -->|4. Store Ticket PDF| E
    B -->|5. Update Booking with Ticket URLs| D
    B -->|6. Ack Message| A
    
    A -->|7. SEND_CONFIRMATION message| C
    C -->|8. Fetch Booking & User| D
    C -->|9. Send Email| G
    C -->|10. Send Push| H
    H -->|11. Push Notification| I
    C -->|12. Ack Message| A
    
    I -->|13. GET /bookings/{id}/tickets| D
    I -->|14. Download Ticket| E
                </div>
            </div>

            <div class="example-box">
                <h4>Example 1: Ticket Generation</h4>
                <p><strong>Scenario:</strong> System generates tickets after successful booking</p>
                <ol>
                    <li>Message Queue delivers: <code>{"type": "GENERATE_TICKETS", "booking_id": "bk_xyz789"}</code></li>
                    <li>Ticket Generator Service picks up message</li>
                    <li>Fetches booking details: 2 tickets for seats A-101, A-102 for Taylor Swift at SoFi Stadium on 2024-08-15</li>
                    <li>For each seat, generates:
                        <ul>
                            <li>Unique ticket token: <code>TKT-xyz789-A101-abc123</code> (cryptographically signed)</li>
                            <li>QR code encoding the ticket token</li>
                            <li>PDF ticket with event details, seat info, QR code, terms</li>
                        </ul>
                    </li>
                    <li>Stores tokens in Ticket Token Store (for validation at venue)</li>
                    <li>Uploads PDFs to Object Storage: <code>/tickets/bk_xyz789/ticket_A101.pdf</code></li>
                    <li>Updates Bookings DB with ticket URLs and tokens</li>
                    <li>Acknowledges message (removed from queue)</li>
                </ol>
            </div>

            <div class="example-box">
                <h4>Example 2: Confirmation Notification</h4>
                <p><strong>Scenario:</strong> User receives booking confirmation</p>
                <ol>
                    <li>Message Queue delivers: <code>{"type": "SEND_CONFIRMATION", "booking_id": "bk_xyz789"}</code></li>
                    <li>Notification Service fetches booking and user details</li>
                    <li>Constructs email with:
                        <ul>
                            <li>Subject: "Your tickets for Taylor Swift at SoFi Stadium"</li>
                            <li>Body: Order summary, event details, venue map link, ticket download link</li>
                            <li>Attachments: Ticket PDFs</li>
                        </ul>
                    </li>
                    <li>Sends via Email Provider</li>
                    <li>Constructs push notification: "üé´ Tickets confirmed! You're going to see Taylor Swift on Aug 15"</li>
                    <li>Sends via Push Notification Service to user's registered devices</li>
                    <li>User's phone displays push notification</li>
                    <li>User taps notification, app opens to booking details</li>
                </ol>
            </div>

            <div class="example-box">
                <h4>Example 3: User Views/Downloads Tickets</h4>
                <p><strong>Scenario:</strong> User opens app to view their tickets</p>
                <ol>
                    <li>User opens app and navigates to "My Tickets"</li>
                    <li>App sends: <code>GET /api/v1/users/me/bookings</code></li>
                    <li>Returns list of bookings with ticket status</li>
                    <li>User taps on the Taylor Swift booking</li>
                    <li>App sends: <code>GET /api/v1/bookings/bk_xyz789/tickets</code></li>
                    <li>Returns ticket metadata with signed download URLs (time-limited)</li>
                    <li>App displays tickets with QR codes rendered from tokens</li>
                    <li>User can tap "Download PDF" which fetches from Object Storage via signed URL</li>
                    <li>User can add tickets to Apple Wallet / Google Pay</li>
                </ol>
            </div>

            <div class="example-box">
                <h4>Example 4: Event Reminder Notification</h4>
                <p><strong>Scenario:</strong> System sends reminder 24 hours before event</p>
                <ol>
                    <li>Scheduled job runs daily to find events happening in 24 hours</li>
                    <li>For Taylor Swift show on 2024-08-15, queries all confirmed bookings</li>
                    <li>Publishes message for each booking: <code>{"type": "SEND_REMINDER", "booking_id": "bk_xyz789"}</code></li>
                    <li>Notification Service sends push: "‚è∞ Reminder: Taylor Swift at SoFi Stadium tomorrow at 7:00 PM. Don't forget your tickets!"</li>
                    <li>Includes deep link to tickets in app</li>
                </ol>
            </div>

            <h4>Component Deep Dive: Flow 4</h4>
            
            <table>
                <tr>
                    <th>Component</th>
                    <th>Protocol/Type</th>
                    <th>Description</th>
                    <th>Input</th>
                    <th>Output</th>
                </tr>
                <tr>
                    <td><strong>Ticket Generator Service</strong></td>
                    <td>Queue Consumer</td>
                    <td>Generates unique ticket tokens with cryptographic signing. Creates QR codes and PDF tickets. Idempotent - safe to retry.</td>
                    <td>Booking ID</td>
                    <td>Ticket tokens, QR codes, PDF files</td>
                </tr>
                <tr>
                    <td><strong>Notification Service</strong></td>
                    <td>Queue Consumer / HTTP</td>
                    <td>Handles all user notifications. Supports email, push, SMS. Implements templates and localization. Tracks delivery status.</td>
                    <td>Notification type, booking ID, user preferences</td>
                    <td>Sent notifications</td>
                </tr>
                <tr>
                    <td><strong>Object Storage</strong></td>
                    <td>HTTPS</td>
                    <td>Stores ticket PDFs and images. Provides signed URLs for secure, time-limited downloads. Highly durable.</td>
                    <td>File upload with path</td>
                    <td>Storage URL, signed download URL</td>
                </tr>
                <tr>
                    <td><strong>Ticket Token Store</strong></td>
                    <td>Key-Value (NoSQL)</td>
                    <td>Fast lookup store for ticket validation at venues. Key: ticket_token, Value: ticket metadata + used status.</td>
                    <td>Token operations</td>
                    <td>Token validation result</td>
                </tr>
                <tr>
                    <td><strong>Push Notification Service</strong></td>
                    <td>HTTPS / FCM / APNS</td>
                    <td>Abstracts iOS (APNS) and Android (FCM) push notifications. Manages device tokens. Handles retries and failures.</td>
                    <td>Device tokens, notification payload</td>
                    <td>Delivery status</td>
                </tr>
            </table>
        </div>

        <!-- FLOW 5: Virtual Queue -->
        <div id="flow5">
            <h3>Flow 5: Waiting Room / Virtual Queue</h3>
            <p>This flow handles high-demand events where users must wait in a virtual queue before accessing ticket purchase.</p>
            
            <div class="diagram-container">
                <div class="mermaid">
graph TB
    subgraph Client
        A[Mobile App / Web Browser]
    end
    
    subgraph Edge Layer
        B[Load Balancer]
        C[CDN - Static Waiting Room Page]
    end
    
    subgraph API Layer
        D[API Gateway]
        E[Queue Service]
    end
    
    subgraph Data Layer
        F[Queue Store - Sorted Set]
        G[(Event Config DB)]
    end
    
    subgraph Real-time
        H[WebSocket Server]
        I[Position Update Publisher]
    end
    
    A -->|1. Navigate to Event| C
    C -->|2. Check Queue Status| D
    D -->|3. Is Queue Active?| E
    E -->|4. Check Config| G
    E -->|5. Add to Queue| F
    E -->|6. Return Queue Token| A
    
    A -->|7. Establish WebSocket| H
    H -->|8. Subscribe to Position| I
    I -->|9. Poll Queue Position| F
    F -->|10. Position Data| I
    I -->|11. Broadcast Position| H
    H -->|12. Position Update| A
    
    E -->|13. User's Turn| A
    A -->|14. Access Granted - Proceed to Seats| D
                </div>
            </div>

            <div class="example-box">
                <h4>Example 1: Joining the Queue</h4>
                <p><strong>Scenario:</strong> User arrives for a high-demand event sale</p>
                <ol>
                    <li>Taylor Swift Eras Tour tickets go on sale at 10:00 AM</li>
                    <li>User opens app at 9:55 AM, navigates to event page</li>
                    <li>App sends: <code>GET /api/v1/events/evt_12345/queue-status</code></li>
                    <li>Queue Service checks Event Config DB: queue enabled, sale starts 10:00 AM</li>
                    <li>Returns: <code>{"queue_active": true, "sale_starts_at": "2024-03-15T10:00:00Z", "pre_queue_open": true}</code></li>
                    <li>User sees waiting room page served from CDN (static HTML/JS)</li>
                    <li>At 9:58 AM, user clicks "Join Waiting Room"</li>
                    <li>App sends: <code>POST /api/v1/events/evt_12345/queue/join</code></li>
                    <li>Queue Service:
                        <ul>
                            <li>Validates user is authenticated and not a bot (CAPTCHA, device fingerprint)</li>
                            <li>Generates queue token: <code>qt_abc123</code></li>
                            <li>Adds to sorted set with timestamp score: <code>ZADD queue:evt_12345 1710496680 qt_abc123</code></li>
                        </ul>
                    </li>
                    <li>Returns: <code>{"queue_token": "qt_abc123", "estimated_position": 245000}</code></li>
                    <li>User sees: "You're in the waiting room. When tickets go on sale, you'll be randomly assigned a place in line."</li>
                </ol>
            </div>

            <div class="example-box">
                <h4>Example 2: Random Assignment at Sale Start</h4>
                <p><strong>Scenario:</strong> Sale starts and queue positions are randomized</p>
                <ol>
                    <li>At 10:00 AM exactly, Queue Service triggers sale start</li>
                    <li>All users who joined between 9:55-10:00 are in the pre-queue pool</li>
                    <li>System randomizes order: assigns random scores to all pre-queue entries</li>
                    <li>User's position changes from "waiting room" to actual queue position</li>
                    <li>User qt_abc123 gets assigned position #12,543 out of 245,000</li>
                    <li>Position Update Publisher broadcasts to all WebSocket connections</li>
                    <li>User's app receives WebSocket message: <code>{"position": 12543, "total": 245000, "estimated_wait": "15 minutes"}</code></li>
                    <li>User sees: "You are #12,543 in line. Estimated wait: 15 minutes"</li>
                </ol>
            </div>

            <div class="example-box">
                <h4>Example 3: Queue Progression</h4>
                <p><strong>Scenario:</strong> User moves through the queue</p>
                <ol>
                    <li>System processes users in batches of 1,000 every 30 seconds</li>
                    <li>When batch completes checkout (purchase or timeout), next batch is admitted</li>
                    <li>Position Update Publisher calculates new positions</li>
                    <li>Every 30 seconds, user receives WebSocket update: <code>{"position": 10543, "estimated_wait": "12 minutes"}</code></li>
                    <li>Progress bar updates on user's screen</li>
                    <li>When position reaches threshold (e.g., position ‚â§ 1000), user is flagged for entry</li>
                </ol>
            </div>

            <div class="example-box">
                <h4>Example 4: User's Turn to Purchase</h4>
                <p><strong>Scenario:</strong> User reaches front of queue</p>
                <ol>
                    <li>User's position becomes #1 in current admission batch</li>
                    <li>WebSocket message: <code>{"status": "YOUR_TURN", "access_token": "acc_xyz789", "expires_at": "2024-03-15T10:25:00Z"}</code></li>
                    <li>App displays: "It's your turn! You have 15 minutes to complete your purchase"</li>
                    <li>App redirects to seat selection, including access_token in subsequent requests</li>
                    <li>API Gateway validates access_token on seat/booking requests</li>
                    <li>User proceeds with normal seat selection and booking flow</li>
                    <li>If user doesn't complete in 15 minutes, access_token expires and they must rejoin queue</li>
                </ol>
            </div>

            <div class="example-box">
                <h4>Example 5: Sold Out While in Queue</h4>
                <p><strong>Scenario:</strong> Event sells out before user reaches front</p>
                <ol>
                    <li>User at position #150,000, inventory drops to 0</li>
                    <li>Inventory Service publishes event: "evt_12345 SOLD_OUT"</li>
                    <li>Queue Service receives event, stops admitting users</li>
                    <li>Broadcasts to all remaining queued users via WebSocket: <code>{"status": "SOLD_OUT", "message": "Sorry, this event is now sold out"}</code></li>
                    <li>User sees sold out message with option to join waitlist</li>
                    <li>Queue is cleared for this event</li>
                </ol>
            </div>

            <h4>Component Deep Dive: Flow 5</h4>
            
            <table>
                <tr>
                    <th>Component</th>
                    <th>Protocol/Type</th>
                    <th>Description</th>
                    <th>Input</th>
                    <th>Output</th>
                </tr>
                <tr>
                    <td><strong>Queue Service</strong></td>
                    <td>HTTP REST</td>
                    <td>Manages virtual queue operations. Adds users, tracks positions, admits users when capacity available. Implements fairness algorithms.</td>
                    <td>
                        <code>POST /queue/join</code> - Join queue<br>
                        <code>GET /queue/status</code> - Check position<br>
                        <code>POST /queue/admit</code> - Admit next batch
                    </td>
                    <td>Queue token, position, access token</td>
                </tr>
                <tr>
                    <td><strong>Queue Store (Sorted Set)</strong></td>
                    <td>In-memory data structure</td>
                    <td>Stores queue using sorted set data structure. Score = timestamp or random value for ordering. O(log n) insertions, O(1) position lookup.</td>
                    <td>ZADD, ZRANK, ZRANGE operations</td>
                    <td>Position, batch of tokens</td>
                </tr>
                <tr>
                    <td><strong>WebSocket Server</strong></td>
                    <td>WebSocket (WSS)</td>
                    <td>Maintains persistent connections with queued users. Pushes real-time position updates. Horizontally scaled with sticky sessions or shared state.</td>
                    <td>WebSocket connection with queue_token</td>
                    <td>Real-time position updates</td>
                </tr>
                <tr>
                    <td><strong>Position Update Publisher</strong></td>
                    <td>Internal Service / Pub-Sub</td>
                    <td>Calculates positions and broadcasts updates. Runs periodically (every 5-30 seconds). Publishes to all WebSocket server instances.</td>
                    <td>Queue state changes</td>
                    <td>Position updates to all connections</td>
                </tr>
            </table>

            <div class="info-box">
                <h4>Why WebSocket is Used</h4>
                <p>WebSocket is chosen for the virtual queue because:</p>
                <ul>
                    <li><strong>Real-time updates:</strong> Users need to see position changes immediately</li>
                    <li><strong>Server-initiated messages:</strong> Server pushes updates, not client polling</li>
                    <li><strong>Reduced load:</strong> 1 persistent connection vs. polling every 5 seconds</li>
                    <li><strong>Better UX:</strong> Smooth progress updates without page refreshes</li>
                </ul>
                <h4>WebSocket Connection Details</h4>
                <ol>
                    <li><strong>Connection Establishment:</strong>
                        <ul>
                            <li>Client initiates: <code>wss://queue.ticketmaster.com/ws?token=qt_abc123&event=evt_12345</code></li>
                            <li>WebSocket server validates token, accepts connection</li>
                            <li>Connection stored in memory with mapping: connection_id ‚Üí queue_token</li>
                        </ul>
                    </li>
                    <li><strong>Connection Storage:</strong>
                        <ul>
                            <li>In-memory connection map on each WebSocket server instance</li>
                            <li>Shared state in distributed cache for cross-instance lookup: queue_token ‚Üí server_instance</li>
                        </ul>
                    </li>
                    <li><strong>Finding Other Connections:</strong>
                        <ul>
                            <li>Position Publisher uses Pub/Sub to broadcast to all server instances</li>
                            <li>Each server instance delivers to its local connections</li>
                        </ul>
                    </li>
                </ol>
                <h4>Why Not Alternatives?</h4>
                <ul>
                    <li><strong>Long Polling:</strong> Higher server load, more latency, less efficient</li>
                    <li><strong>Server-Sent Events (SSE):</strong> Unidirectional only; WebSocket allows bidirectional if needed (heartbeats, user actions)</li>
                    <li><strong>Regular Polling:</strong> Would create massive load with millions of users polling every few seconds</li>
                </ul>
            </div>
        </div>

        <!-- OVERALL COMBINED FLOW -->
        <div id="overall-flow">
            <h3>Overall Combined Flow</h3>
            <p>This diagram shows how all flows integrate together for a complete user journey.</p>
            
            <div class="diagram-container">
                <div class="mermaid">
graph TB
    subgraph Client Layer
        A[Mobile App / Web Browser]
    end
    
    subgraph Edge Layer
        B[CDN]
        C[Load Balancer]
    end
    
    subgraph Gateway Layer
        D[API Gateway]
        E[WebSocket Gateway]
    end
    
    subgraph Service Layer
        F[Search Service]
        G[Inventory Service]
        H[Booking Service]
        I[Payment Service]
        J[Queue Service]
        K[Notification Service]
        L[Ticket Generator]
        M[User Service]
    end
    
    subgraph Data Layer
        N[Search Index]
        O[(Events DB - SQL)]
        P[(Inventory DB - SQL)]
        Q[(Bookings DB - SQL)]
        R[(Users DB - SQL)]
        S[Distributed Lock Manager]
        T[Cache Layer]
        U[Queue Store]
    end
    
    subgraph Async Layer
        V[Message Queue]
    end
    
    subgraph Storage Layer
        W[Object Storage]
    end
    
    subgraph External
        X[Payment Gateway]
        Y[Email Provider]
        Z[Push Service]
    end
    
    A --> B
    A --> C
    A --> E
    B --> C
    C --> D
    
    D --> F
    D --> G
    D --> H
    D --> I
    D --> J
    D --> M
    
    E --> J
    
    F --> N
    F --> T
    F --> O
    
    G --> P
    G --> S
    G --> T
    
    H --> Q
    H --> G
    H --> I
    H --> V
    
    I --> X
    
    J --> U
    J --> T
    
    V --> K
    V --> L
    
    K --> Y
    K --> Z
    K --> A
    
    L --> Q
    L --> W
    
    M --> R
                </div>
            </div>

            <div class="example-box">
                <h4>Example: Complete User Journey</h4>
                <p><strong>Scenario:</strong> User discovers, queues, selects, and purchases tickets for a high-demand event</p>
                <ol>
                    <li><strong>Discovery Phase:</strong>
                        <ul>
                            <li>User searches "Taylor Swift Los Angeles" in the app</li>
                            <li>Request: <code>GET /events?q=taylor+swift+los+angeles</code> ‚Üí CDN ‚Üí Load Balancer ‚Üí API Gateway ‚Üí Search Service</li>
                            <li>Search Service queries Search Index, enriches with cached event data</li>
                            <li>Returns list of matching events with availability status</li>
                        </ul>
                    </li>
                    <li><strong>Queue Phase:</strong>
                        <ul>
                            <li>User clicks on high-demand event, sees "Join Waiting Room"</li>
                            <li>Request: <code>POST /events/evt_12345/queue/join</code> ‚Üí Queue Service</li>
                            <li>Added to Queue Store with timestamp, receives queue token</li>
                            <li>Establishes WebSocket connection for position updates</li>
                            <li>Waits 15 minutes, receives position updates via WebSocket</li>
                            <li>Receives "YOUR_TURN" with access token</li>
                        </ul>
                    </li>
                    <li><strong>Seat Selection Phase:</strong>
                        <ul>
                            <li>Redirected to seat selection with access token</li>
                            <li>Request: <code>GET /events/evt_12345/seats</code> ‚Üí Inventory Service</li>
                            <li>Views seat map, selects 2 seats</li>
                            <li>Request: <code>POST /seats/hold</code> ‚Üí Inventory Service ‚Üí Distributed Lock ‚Üí Inventory DB</li>
                            <li>Receives 10-minute hold confirmation</li>
                        </ul>
                    </li>
                    <li><strong>Booking & Payment Phase:</strong>
                        <ul>
                            <li>Enters payment details, submits</li>
                            <li>Request: <code>POST /bookings</code> ‚Üí Booking Service ‚Üí Payment Service ‚Üí Payment Gateway</li>
                            <li>Payment approved, seats marked as SOLD</li>
                            <li>Booking confirmed, messages queued for ticket generation and notification</li>
                        </ul>
                    </li>
                    <li><strong>Delivery Phase:</strong>
                        <ul>
                            <li>Ticket Generator consumes message, generates QR codes and PDFs</li>
                            <li>Stores tickets in Object Storage</li>
                            <li>Notification Service sends confirmation email with tickets</li>
                            <li>Sends push notification to user's device</li>
                            <li>User views tickets in app: <code>GET /bookings/bk_xyz789/tickets</code></li>
                        </ul>
                    </li>
                </ol>
            </div>

            <div class="example-box">
                <h4>Example: Normal Event (No Queue)</h4>
                <p><strong>Scenario:</strong> User purchases tickets for a normal-demand event</p>
                <ol>
                    <li>User searches "Local Jazz Concert", finds event</li>
                    <li>Queue check returns: <code>{"queue_active": false}</code></li>
                    <li>User goes directly to seat selection (no waiting room)</li>
                    <li>Selects seats, receives hold, completes purchase</li>
                    <li>Same booking and delivery flow as above</li>
                </ol>
            </div>

            <div class="example-box">
                <h4>Example: Mobile Ticket Entry at Venue</h4>
                <p><strong>Scenario:</strong> User enters venue using digital ticket</p>
                <ol>
                    <li>Day of event, user opens app, navigates to tickets</li>
                    <li>App displays QR code for ticket token</li>
                    <li>Venue scanner reads QR code: <code>TKT-xyz789-A101-abc123</code></li>
                    <li>Scanner service calls: <code>POST /tickets/validate</code> with token</li>
                    <li>Ticket Token Store validates: token exists, not used, event matches, time valid</li>
                    <li>Marks token as "USED" with timestamp</li>
                    <li>Returns: <code>{"valid": true, "seat": "Section 112, Row A, Seat 101"}</code></li>
                    <li>Gate opens, user enters</li>
                    <li>Second scan of same ticket: returns <code>{"valid": false, "reason": "ALREADY_USED"}</code></li>
                </ol>
            </div>
        </div>
    </div>

    <!-- DATABASE SCHEMA SECTION -->
    <div class="section" id="schema">
        <h2>3. Database Schema</h2>

        <h3>3.1 SQL Tables</h3>
        <p>SQL is used for tables requiring ACID compliance, complex queries, and strong consistency.</p>

        <h4>Users Table</h4>
        <table>
            <tr>
                <th>Column</th>
                <th>Type</th>
                <th>Constraints</th>
                <th>Description</th>
            </tr>
            <tr><td>user_id</td><td>UUID</td><td>PRIMARY KEY</td><td>Unique user identifier</td></tr>
            <tr><td>email</td><td>VARCHAR(255)</td><td>UNIQUE, NOT NULL</td><td>User email address</td></tr>
            <tr><td>password_hash</td><td>VARCHAR(255)</td><td>NOT NULL</td><td>Bcrypt hashed password</td></tr>
            <tr><td>name</td><td>VARCHAR(255)</td><td>NOT NULL</td><td>User's full name</td></tr>
            <tr><td>phone</td><td>VARCHAR(20)</td><td></td><td>Phone number for SMS</td></tr>
            <tr><td>created_at</td><td>TIMESTAMP</td><td>NOT NULL</td><td>Account creation time</td></tr>
            <tr><td>updated_at</td><td>TIMESTAMP</td><td>NOT NULL</td><td>Last update time</td></tr>
        </table>
        <div class="info-box">
            <p><strong>Why SQL:</strong> User data requires ACID compliance for registration, authentication, and account updates. Complex queries for user lookups. Relatively low write volume.</p>
            <p><strong>Indexes:</strong>
                <ul>
                    <li><code>email</code> - Hash index for O(1) login lookups</li>
                </ul>
            </p>
            <p><strong>Read/Write Events:</strong>
                <ul>
                    <li><strong>Write:</strong> User registration, profile updates</li>
                    <li><strong>Read:</strong> Login authentication, booking creation (to get user details)</li>
                </ul>
            </p>
        </div>

        <h4>Events Table</h4>
        <table>
            <tr>
                <th>Column</th>
                <th>Type</th>
                <th>Constraints</th>
                <th>Description</th>
            </tr>
            <tr><td>event_id</td><td>UUID</td><td>PRIMARY KEY</td><td>Unique event identifier</td></tr>
            <tr><td>name</td><td>VARCHAR(500)</td><td>NOT NULL</td><td>Event name</td></tr>
            <tr><td>description</td><td>TEXT</td><td></td><td>Full description</td></tr>
            <tr><td>venue_id</td><td>UUID</td><td>FOREIGN KEY</td><td>Reference to venues table</td></tr>
            <tr><td>artist_id</td><td>UUID</td><td>FOREIGN KEY</td><td>Reference to artists table</td></tr>
            <tr><td>category</td><td>VARCHAR(50)</td><td>NOT NULL</td><td>Concert, Sports, Theater, etc.</td></tr>
            <tr><td>event_date</td><td>TIMESTAMP</td><td>NOT NULL</td><td>Event date and time</td></tr>
            <tr><td>doors_open</td><td>TIMESTAMP</td><td></td><td>When doors open</td></tr>
            <tr><td>sale_start</td><td>TIMESTAMP</td><td></td><td>When tickets go on sale</td></tr>
            <tr><td>queue_enabled</td><td>BOOLEAN</td><td>DEFAULT FALSE</td><td>Virtual queue enabled</td></tr>
            <tr><td>status</td><td>VARCHAR(20)</td><td>NOT NULL</td><td>UPCOMING, CANCELLED, COMPLETED</td></tr>
            <tr><td>price_min</td><td>DECIMAL(10,2)</td><td></td><td>Minimum ticket price (denormalized)</td></tr>
            <tr><td>price_max</td><td>DECIMAL(10,2)</td><td></td><td>Maximum ticket price (denormalized)</td></tr>
            <tr><td>total_seats</td><td>INTEGER</td><td></td><td>Total capacity (denormalized)</td></tr>
            <tr><td>available_seats</td><td>INTEGER</td><td></td><td>Current availability (denormalized)</td></tr>
            <tr><td>image_url</td><td>VARCHAR(500)</td><td></td><td>Event poster image</td></tr>
            <tr><td>created_at</td><td>TIMESTAMP</td><td>NOT NULL</td><td>Creation time</td></tr>
        </table>
        <div class="info-box">
            <p><strong>Why SQL:</strong> Events require complex queries (filtering, sorting, joining with venues/artists). Moderate write frequency. Need transactional updates.</p>
            <p><strong>Denormalization:</strong> <code>price_min</code>, <code>price_max</code>, <code>total_seats</code>, <code>available_seats</code> are denormalized from seat inventory. This avoids expensive aggregation queries on every search. Updated via triggers or async jobs when inventory changes.</p>
            <p><strong>Indexes:</strong>
                <ul>
                    <li><code>(category, event_date)</code> - B-tree composite index for filtered browsing</li>
                    <li><code>(venue_id)</code> - B-tree for venue-based queries</li>
                    <li><code>(event_date)</code> - B-tree for date range queries</li>
                    <li><code>(status, event_date)</code> - Composite for active event queries</li>
                </ul>
            </p>
            <p><strong>Read/Write Events:</strong>
                <ul>
                    <li><strong>Write:</strong> Event creation by administrators, status updates, availability updates (async)</li>
                    <li><strong>Read:</strong> Search results, event detail page, seat selection page</li>
                </ul>
            </p>
        </div>

        <h4>Venues Table</h4>
        <table>
            <tr>
                <th>Column</th>
                <th>Type</th>
                <th>Constraints</th>
                <th>Description</th>
            </tr>
            <tr><td>venue_id</td><td>UUID</td><td>PRIMARY KEY</td><td>Unique venue identifier</td></tr>
            <tr><td>name</td><td>VARCHAR(255)</td><td>NOT NULL</td><td>Venue name</td></tr>
            <tr><td>address</td><td>VARCHAR(500)</td><td>NOT NULL</td><td>Street address</td></tr>
            <tr><td>city</td><td>VARCHAR(100)</td><td>NOT NULL</td><td>City</td></tr>
            <tr><td>state</td><td>VARCHAR(50)</td><td></td><td>State/Province</td></tr>
            <tr><td>country</td><td>VARCHAR(50)</td><td>NOT NULL</td><td>Country</td></tr>
            <tr><td>latitude</td><td>DECIMAL(10,7)</td><td></td><td>Geo coordinate</td></tr>
            <tr><td>longitude</td><td>DECIMAL(10,7)</td><td></td><td>Geo coordinate</td></tr>
            <tr><td>capacity</td><td>INTEGER</td><td></td><td>Total venue capacity</td></tr>
            <tr><td>seating_map_url</td><td>VARCHAR(500)</td><td></td><td>URL to seating chart SVG</td></tr>
        </table>
        <div class="info-box">
            <p><strong>Why SQL:</strong> Reference data with low write frequency. Joined with events table. Geo-spatial queries for "events near me".</p>
            <p><strong>Indexes:</strong>
                <ul>
                    <li><code>(city, state)</code> - B-tree for location filtering</li>
                    <li><code>(latitude, longitude)</code> - R-tree/spatial index for geo queries</li>
                </ul>
            </p>
        </div>

        <h4>Seats (Inventory) Table</h4>
        <table>
            <tr>
                <th>Column</th>
                <th>Type</th>
                <th>Constraints</th>
                <th>Description</th>
            </tr>
            <tr><td>seat_id</td><td>UUID</td><td>PRIMARY KEY</td><td>Unique seat instance ID</td></tr>
            <tr><td>event_id</td><td>UUID</td><td>FOREIGN KEY, NOT NULL</td><td>Reference to event</td></tr>
            <tr><td>section</td><td>VARCHAR(50)</td><td>NOT NULL</td><td>Section identifier</td></tr>
            <tr><td>row</td><td>VARCHAR(10)</td><td>NOT NULL</td><td>Row identifier</td></tr>
            <tr><td>seat_number</td><td>VARCHAR(10)</td><td>NOT NULL</td><td>Seat number in row</td></tr>
            <tr><td>price</td><td>DECIMAL(10,2)</td><td>NOT NULL</td><td>Ticket price</td></tr>
            <tr><td>price_tier</td><td>VARCHAR(50)</td><td></td><td>VIP, Premium, Standard, etc.</td></tr>
            <tr><td>status</td><td>VARCHAR(20)</td><td>NOT NULL</td><td>AVAILABLE, HELD, SOLD, BLOCKED</td></tr>
            <tr><td>hold_user_id</td><td>UUID</td><td>FOREIGN KEY</td><td>User holding the seat</td></tr>
            <tr><td>hold_expires_at</td><td>TIMESTAMP</td><td></td><td>Hold expiration time</td></tr>
            <tr><td>booking_id</td><td>UUID</td><td>FOREIGN KEY</td><td>Reference to booking if sold</td></tr>
            <tr><td>version</td><td>INTEGER</td><td>DEFAULT 0</td><td>Optimistic locking version</td></tr>
        </table>
        <div class="info-box">
            <p><strong>Why SQL:</strong> <strong>CRITICAL for consistency.</strong> Seat inventory must be ACID compliant to prevent double-booking. Uses row-level locking for concurrent updates. Optimistic locking via version column for additional safety.</p>
            <p><strong>Indexes:</strong>
                <ul>
                    <li><code>(event_id, status)</code> - B-tree composite for fetching available seats</li>
                    <li><code>(event_id, section, row, seat_number)</code> - Unique constraint and index</li>
                    <li><code>(hold_expires_at)</code> - B-tree for expiration job to find expired holds</li>
                    <li><code>(booking_id)</code> - B-tree for looking up seats by booking</li>
                </ul>
            </p>
            <p><strong>Sharding Strategy:</strong> Sharded by <code>event_id</code>. All seats for an event reside on the same shard, enabling transactional operations across multiple seats in a booking. Hot events might need dedicated shards.</p>
            <p><strong>Read/Write Events:</strong>
                <ul>
                    <li><strong>Write:</strong> Seat hold (user selects), hold release (expiration), seat purchase (booking confirmation)</li>
                    <li><strong>Read:</strong> Seat map display, availability check before hold</li>
                </ul>
            </p>
        </div>

        <h4>Bookings Table</h4>
        <table>
            <tr>
                <th>Column</th>
                <th>Type</th>
                <th>Constraints</th>
                <th>Description</th>
            </tr>
            <tr><td>booking_id</td><td>UUID</td><td>PRIMARY KEY</td><td>Unique booking identifier</td></tr>
            <tr><td>user_id</td><td>UUID</td><td>FOREIGN KEY, NOT NULL</td><td>User who made booking</td></tr>
            <tr><td>event_id</td><td>UUID</td><td>FOREIGN KEY, NOT NULL</td><td>Event booked</td></tr>
            <tr><td>status</td><td>VARCHAR(20)</td><td>NOT NULL</td><td>PENDING, CONFIRMED, CANCELLED, REFUNDED</td></tr>
            <tr><td>total_amount</td><td>DECIMAL(10,2)</td><td>NOT NULL</td><td>Total price paid</td></tr>
            <tr><td>service_fee</td><td>DECIMAL(10,2)</td><td></td><td>Service fees</td></tr>
            <tr><td>tax</td><td>DECIMAL(10,2)</td><td></td><td>Tax amount</td></tr>
            <tr><td>payment_id</td><td>VARCHAR(100)</td><td></td><td>External payment reference</td></tr>
            <tr><td>payment_method</td><td>VARCHAR(50)</td><td></td><td>Card type, PayPal, etc.</td></tr>
            <tr><td>idempotency_key</td><td>VARCHAR(100)</td><td>UNIQUE</td><td>For preventing duplicate charges</td></tr>
            <tr><td>created_at</td><td>TIMESTAMP</td><td>NOT NULL</td><td>Booking creation time</td></tr>
            <tr><td>confirmed_at</td><td>TIMESTAMP</td><td></td><td>When booking was confirmed</td></tr>
        </table>
        <div class="info-box">
            <p><strong>Why SQL:</strong> Financial transactions require ACID compliance. Audit trail for payments. Complex queries for reporting. Joins with users and events.</p>
            <p><strong>Indexes:</strong>
                <ul>
                    <li><code>(user_id, created_at DESC)</code> - B-tree for user's order history</li>
                    <li><code>(event_id, status)</code> - B-tree for event booking reports</li>
                    <li><code>(idempotency_key)</code> - Unique index for duplicate prevention</li>
                    <li><code>(created_at)</code> - B-tree for time-based queries/reports</li>
                </ul>
            </p>
            <p><strong>Read/Write Events:</strong>
                <ul>
                    <li><strong>Write:</strong> Booking creation, payment confirmation, cancellation, refund</li>
                    <li><strong>Read:</strong> User views order history, admin views bookings for event</li>
                </ul>
            </p>
        </div>

        <h4>Booking_Tickets Table (Junction)</h4>
        <table>
            <tr>
                <th>Column</th>
                <th>Type</th>
                <th>Constraints</th>
                <th>Description</th>
            </tr>
            <tr><td>booking_ticket_id</td><td>UUID</td><td>PRIMARY KEY</td><td>Unique ID</td></tr>
            <tr><td>booking_id</td><td>UUID</td><td>FOREIGN KEY, NOT NULL</td><td>Reference to booking</td></tr>
            <tr><td>seat_id</td><td>UUID</td><td>FOREIGN KEY, NOT NULL</td><td>Reference to seat</td></tr>
            <tr><td>ticket_token</td><td>VARCHAR(100)</td><td>UNIQUE</td><td>Unique ticket identifier for entry</td></tr>
            <tr><td>ticket_pdf_url</td><td>VARCHAR(500)</td><td></td><td>URL to ticket PDF</td></tr>
            <tr><td>qr_code_data</td><td>VARCHAR(500)</td><td></td><td>QR code encoded data</td></tr>
            <tr><td>status</td><td>VARCHAR(20)</td><td></td><td>ACTIVE, USED, CANCELLED</td></tr>
            <tr><td>used_at</td><td>TIMESTAMP</td><td></td><td>When ticket was scanned at venue</td></tr>
        </table>
        <div class="info-box">
            <p><strong>Why SQL:</strong> Links bookings to individual tickets. Transactional updates when tickets are used. Normalized to support multiple tickets per booking.</p>
            <p><strong>Indexes:</strong>
                <ul>
                    <li><code>(booking_id)</code> - B-tree for fetching all tickets in a booking</li>
                    <li><code>(ticket_token)</code> - Hash index for O(1) ticket validation at venue</li>
                </ul>
            </p>
        </div>

        <h3>3.2 NoSQL Tables</h3>
        <p>NoSQL is used for high-throughput operations, flexible schemas, and data that benefits from denormalization.</p>

        <h4>Queue State Store (Key-Value / Sorted Set)</h4>
        <table>
            <tr>
                <th>Key Pattern</th>
                <th>Value Type</th>
                <th>Description</th>
            </tr>
            <tr><td><code>queue:{event_id}</code></td><td>Sorted Set</td><td>All users in queue for event. Score = join timestamp or random value</td></tr>
            <tr><td><code>queue_token:{token}</code></td><td>Hash</td><td>Token details: user_id, event_id, join_time, status</td></tr>
            <tr><td><code>access_token:{token}</code></td><td>Hash</td><td>Active access tokens: user_id, event_id, expires_at, granted_at</td></tr>
        </table>
        <div class="info-box">
            <p><strong>Why NoSQL (In-memory Key-Value):</strong></p>
            <ul>
                <li>Extremely high throughput needed (millions of queue operations during sale)</li>
                <li>Sorted set provides O(log n) insertions and O(1) position lookups</li>
                <li>TTL support for automatic expiration</li>
                <li>Data is ephemeral - doesn't need durability guarantees of SQL</li>
                <li>Horizontal scaling via sharding on event_id</li>
            </ul>
            <p><strong>Read/Write Events:</strong>
                <ul>
                    <li><strong>Write:</strong> User joins queue, position randomized, user admitted, queue cleared</li>
                    <li><strong>Read:</strong> Position checks, batch admission queries</li>
                </ul>
            </p>
        </div>

        <h4>Session / Hold Store (Key-Value)</h4>
        <table>
            <tr>
                <th>Key Pattern</th>
                <th>Value Type</th>
                <th>TTL</th>
                <th>Description</th>
            </tr>
            <tr><td><code>hold:{event_id}:{section}:{seat}</code></td><td>String (user_id)</td><td>10 min</td><td>Distributed lock for seat holds</td></tr>
            <tr><td><code>hold_meta:{hold_id}</code></td><td>Hash</td><td>10 min</td><td>Hold metadata: seats, user_id, created_at, expires_at</td></tr>
            <tr><td><code>session:{session_id}</code></td><td>Hash</td><td>24 hr</td><td>User session data for authentication</td></tr>
        </table>
        <div class="info-box">
            <p><strong>Why NoSQL (In-memory Key-Value):</strong></p>
            <ul>
                <li>Atomic operations (SET NX) for distributed locking</li>
                <li>Built-in TTL for automatic hold expiration</li>
                <li>Sub-millisecond latency for lock checks</li>
                <li>High write throughput during high-demand sales</li>
            </ul>
        </div>

        <h4>Cache Layer (Key-Value)</h4>
        <table>
            <tr>
                <th>Key Pattern</th>
                <th>Value Type</th>
                <th>TTL</th>
                <th>Description</th>
            </tr>
            <tr><td><code>event:{event_id}</code></td><td>JSON</td><td>5 min</td><td>Cached event details</td></tr>
            <tr><td><code>event:{event_id}:seats</code></td><td>Bitmap/JSON</td><td>30 sec</td><td>Seat availability map</td></tr>
            <tr><td><code>search:{query_hash}</code></td><td>JSON</td><td>60 sec</td><td>Cached search results</td></tr>
            <tr><td><code>user:{user_id}:bookings</code></td><td>JSON</td><td>5 min</td><td>User's recent bookings</td></tr>
        </table>
        <div class="info-box">
            <p><strong>Why NoSQL (In-memory Cache):</strong></p>
            <ul>
                <li>Reduce load on SQL databases</li>
                <li>Sub-millisecond reads for hot data</li>
                <li>Flexible TTLs per data type</li>
                <li>See Caching section for detailed strategies</li>
            </ul>
        </div>

        <h4>Ticket Token Store (Key-Value)</h4>
        <table>
            <tr>
                <th>Key Pattern</th>
                <th>Value Type</th>
                <th>Description</th>
            </tr>
            <tr><td><code>ticket:{token}</code></td><td>Hash</td><td>booking_id, seat_id, event_id, status (VALID/USED), used_at</td></tr>
        </table>
        <div class="info-box">
            <p><strong>Why NoSQL (Key-Value):</strong></p>
            <ul>
                <li>O(1) lookups required at venue scanners</li>
                <li>Simple key-value access pattern</li>
                <li>Atomic status updates (VALID ‚Üí USED)</li>
                <li>Geographically distributed for venue proximity</li>
            </ul>
            <p><strong>Read/Write Events:</strong>
                <ul>
                    <li><strong>Write:</strong> Ticket generation after booking, ticket used at venue</li>
                    <li><strong>Read:</strong> Venue scanner validates ticket</li>
                </ul>
            </p>
        </div>
    </div>

    <!-- CACHING SECTION -->
    <div class="section" id="caching">
        <h2>4. Caching Strategy</h2>

        <h3>4.1 In-Memory Cache Overview</h3>
        <p>A distributed in-memory cache is used to reduce database load and improve latency for read-heavy operations.</p>

        <h4>Cache Architecture</h4>
        <div class="diagram-container">
            <div class="mermaid">
graph LR
    A[Service] -->|1. Check Cache| B[Cache Cluster]
    B -->|2a. Cache Hit| A
    B -->|2b. Cache Miss| C[(Database)]
    C -->|3. Return Data| A
    A -->|4. Populate Cache| B
            </div>
        </div>

        <h3>4.2 Caching Strategies by Data Type</h3>

        <table>
            <tr>
                <th>Data Type</th>
                <th>Strategy</th>
                <th>TTL</th>
                <th>Eviction Policy</th>
                <th>Rationale</th>
            </tr>
            <tr>
                <td><strong>Event Details</strong></td>
                <td>Cache-Aside (Lazy Loading)</td>
                <td>5 minutes</td>
                <td>LRU</td>
                <td>Events change infrequently. Read-heavy. Stale data acceptable for 5 min.</td>
            </tr>
            <tr>
                <td><strong>Seat Availability</strong></td>
                <td>Write-Through + Short TTL</td>
                <td>30 seconds</td>
                <td>LRU</td>
                <td>Must be relatively fresh. Written on every hold/release. Short TTL ensures consistency.</td>
            </tr>
            <tr>
                <td><strong>Search Results</strong></td>
                <td>Cache-Aside</td>
                <td>60 seconds</td>
                <td>LRU</td>
                <td>Popular searches cached. Stale results acceptable briefly.</td>
            </tr>
            <tr>
                <td><strong>User Sessions</strong></td>
                <td>Write-Through</td>
                <td>24 hours</td>
                <td>TTL-based</td>
                <td>Sessions written on login, read on every request. Must be consistent.</td>
            </tr>
            <tr>
                <td><strong>Queue Positions</strong></td>
                <td>Write-Through (Primary Store)</td>
                <td>Event duration</td>
                <td>Manual cleanup</td>
                <td>Queue IS the cache. No backing database. Ephemeral by design.</td>
            </tr>
        </table>

        <h3>4.3 Cache-Aside (Lazy Loading) Deep Dive</h3>
        <div class="info-box">
            <h4>How It Works</h4>
            <ol>
                <li>Application requests data</li>
                <li>Check cache first</li>
                <li>If hit: return cached data</li>
                <li>If miss: query database, store in cache, return data</li>
            </ol>
            <h4>Pros</h4>
            <ul>
                <li>Only caches data that is actually requested (memory efficient)</li>
                <li>Cache failures don't break the system (degrades to DB reads)</li>
            </ul>
            <h4>Cons</h4>
            <ul>
                <li>First request always hits database (cold start)</li>
                <li>Data can become stale between writes and cache expiration</li>
            </ul>
            <h4>Used For</h4>
            <p>Event details, search results, user profiles - data that is read frequently but updated infrequently.</p>
        </div>

        <h3>4.4 Write-Through Deep Dive</h3>
        <div class="info-box">
            <h4>How It Works</h4>
            <ol>
                <li>Application writes data</li>
                <li>Write to cache AND database synchronously</li>
                <li>Return success only after both writes complete</li>
            </ol>
            <h4>Pros</h4>
            <ul>
                <li>Cache is always consistent with database</li>
                <li>No stale data issues</li>
            </ul>
            <h4>Cons</h4>
            <ul>
                <li>Higher write latency (must wait for both)</li>
                <li>Cache may store data that's never read</li>
            </ul>
            <h4>Used For</h4>
            <p>Seat availability - consistency is critical, and we accept slight write latency overhead.</p>
        </div>

        <h3>4.5 Eviction Policies</h3>
        <table>
            <tr>
                <th>Policy</th>
                <th>Description</th>
                <th>Used When</th>
            </tr>
            <tr>
                <td><strong>LRU (Least Recently Used)</strong></td>
                <td>Evict items that haven't been accessed recently</td>
                <td>Event details, search results - keeps hot data in cache</td>
            </tr>
            <tr>
                <td><strong>TTL-based</strong></td>
                <td>Items expire after fixed time regardless of access</td>
                <td>Sessions, seat availability - ensures freshness</td>
            </tr>
            <tr>
                <td><strong>Manual/Explicit</strong></td>
                <td>Application explicitly removes items</td>
                <td>Queue data - cleaned up after event sale ends</td>
            </tr>
        </table>

        <h3>4.6 Cache Invalidation</h3>
        <div class="warning-box">
            <h4>Invalidation Triggers</h4>
            <ul>
                <li><strong>Seat held/released:</strong> Invalidate <code>event:{id}:seats</code></li>
                <li><strong>Event updated:</strong> Invalidate <code>event:{id}</code></li>
                <li><strong>Booking completed:</strong> Invalidate user's booking cache</li>
            </ul>
            <h4>Invalidation Strategy</h4>
            <p>We use <strong>event-driven invalidation</strong>: when data changes, publish invalidation event to message queue. Cache invalidation workers consume events and delete relevant cache keys. This is more reliable than time-based expiration for critical data.</p>
        </div>
    </div>

    <!-- CDN SECTION -->
    <div class="section" id="cdn">
        <h2>5. CDN Strategy</h2>

        <h3>5.1 What is Cached at CDN</h3>
        <table>
            <tr>
                <th>Content Type</th>
                <th>Cache Duration</th>
                <th>Rationale</th>
            </tr>
            <tr>
                <td><strong>Static Assets</strong> (JS, CSS, images)</td>
                <td>1 year (immutable with hash)</td>
                <td>Versioned filenames; never changes once deployed</td>
            </tr>
            <tr>
                <td><strong>Event Images / Posters</strong></td>
                <td>24 hours</td>
                <td>Rarely change; high traffic for popular events</td>
            </tr>
            <tr>
                <td><strong>Seating Chart SVGs</strong></td>
                <td>7 days</td>
                <td>Static venue layouts; rarely updated</td>
            </tr>
            <tr>
                <td><strong>Waiting Room HTML</strong></td>
                <td>5 minutes</td>
                <td>Static page during queue; reduces origin load during surge</td>
            </tr>
            <tr>
                <td><strong>Search API (popular queries)</strong></td>
                <td>30-60 seconds</td>
                <td>Edge caching for common searches; slight staleness acceptable</td>
            </tr>
            <tr>
                <td><strong>Event List API</strong></td>
                <td>60 seconds</td>
                <td>Homepage event lists; highly cacheable</td>
            </tr>
        </table>

        <h3>5.2 Why CDN is Critical</h3>
        <div class="critical-box">
            <h4>Traffic Surge Protection</h4>
            <p>During high-demand event sales (e.g., Taylor Swift), millions of users hit the site simultaneously. Without CDN:</p>
            <ul>
                <li>Origin servers would be overwhelmed</li>
                <li>Latency would spike globally</li>
                <li>Users far from data centers would have poor experience</li>
            </ul>
            <h4>CDN Benefits</h4>
            <ul>
                <li><strong>Absorb traffic:</strong> 90%+ of requests served from edge</li>
                <li><strong>Global latency:</strong> Users hit nearby edge nodes</li>
                <li><strong>DDoS protection:</strong> CDN absorbs attack traffic</li>
                <li><strong>Cost reduction:</strong> Less origin infrastructure needed</li>
            </ul>
        </div>

        <h3>5.3 CDN Architecture</h3>
        <div class="diagram-container">
            <div class="mermaid">
graph LR
    A[User in LA] --> B[CDN Edge - LA]
    C[User in NYC] --> D[CDN Edge - NYC]
    E[User in London] --> F[CDN Edge - London]
    
    B --> G[Origin - US West]
    D --> G
    D --> H[Origin - US East]
    F --> I[Origin - Europe]
    
    G --> J[(Database)]
    H --> J
    I --> J
            </div>
        </div>

        <h3>5.4 API Caching at Edge</h3>
        <div class="info-box">
            <h4>Edge API Caching Strategy</h4>
            <p>Some API responses are cached at CDN edge with short TTLs:</p>
            <ul>
                <li><strong>Cache Key:</strong> URL + relevant query params (excluding user-specific params)</li>
                <li><strong>Cache-Control Headers:</strong> <code>Cache-Control: public, max-age=60, stale-while-revalidate=30</code></li>
                <li><strong>Vary Header:</strong> <code>Vary: Accept-Encoding</code> (not on auth headers for public data)</li>
            </ul>
            <h4>What is NOT Cached at CDN</h4>
            <ul>
                <li>User-specific data (bookings, profile)</li>
                <li>Real-time seat availability (changes too frequently)</li>
                <li>Booking/payment endpoints (must be fresh)</li>
                <li>Queue position data (real-time via WebSocket)</li>
            </ul>
        </div>
    </div>

    <!-- SCALING SECTION -->
    <div class="section" id="scaling">
        <h2>6. Scaling Considerations</h2>

        <h3>6.1 Load Balancer Deep Dive</h3>

        <h4>Load Balancer Placement</h4>
        <div class="diagram-container">
            <div class="mermaid">
graph TB
    subgraph Internet
        A[Users]
    end
    
    subgraph Edge
        B[CDN with Built-in LB]
    end
    
    subgraph LB Layer 1
        C[Global Load Balancer]
    end
    
    subgraph Regions
        D[Regional LB - US West]
        E[Regional LB - US East]
        F[Regional LB - Europe]
    end
    
    subgraph Services US-West
        G[API Gateway 1]
        H[API Gateway 2]
        I[API Gateway N]
    end
    
    A --> B
    B --> C
    C --> D
    C --> E
    C --> F
    D --> G
    D --> H
    D --> I
            </div>
        </div>

        <table>
            <tr>
                <th>Load Balancer</th>
                <th>Type</th>
                <th>Algorithm</th>
                <th>Purpose</th>
            </tr>
            <tr>
                <td><strong>Global LB</strong></td>
                <td>DNS-based / Anycast</td>
                <td>Geo-routing + Health checks</td>
                <td>Route users to nearest healthy region</td>
            </tr>
            <tr>
                <td><strong>Regional LB</strong></td>
                <td>Layer 7 (Application)</td>
                <td>Least connections + Health checks</td>
                <td>Distribute across API Gateway instances</td>
            </tr>
            <tr>
                <td><strong>Service LB</strong></td>
                <td>Layer 4/7</td>
                <td>Round robin / Least connections</td>
                <td>Internal service-to-service traffic</td>
            </tr>
            <tr>
                <td><strong>WebSocket LB</strong></td>
                <td>Layer 7 with sticky sessions</td>
                <td>IP hash / Cookie-based</td>
                <td>Maintain WebSocket connections to same server</td>
            </tr>
        </table>

        <div class="info-box">
            <h4>Load Balancer Features</h4>
            <ul>
                <li><strong>SSL Termination:</strong> Decrypt HTTPS at load balancer, use HTTP internally</li>
                <li><strong>Health Checks:</strong> Periodic pings to detect unhealthy instances</li>
                <li><strong>Connection Draining:</strong> Gracefully handle in-flight requests during scale-down</li>
                <li><strong>Rate Limiting:</strong> Protect against abuse (implemented at API Gateway)</li>
                <li><strong>Session Affinity:</strong> For WebSocket connections and stateful operations</li>
            </ul>
        </div>

        <h3>6.2 Horizontal Scaling Strategy</h3>

        <table>
            <tr>
                <th>Component</th>
                <th>Scaling Approach</th>
                <th>Scaling Trigger</th>
            </tr>
            <tr>
                <td><strong>API Gateway</strong></td>
                <td>Auto-scale based on CPU/request count</td>
                <td>CPU > 70% or requests > threshold</td>
            </tr>
            <tr>
                <td><strong>Search Service</strong></td>
                <td>Auto-scale, stateless</td>
                <td>Request latency or queue depth</td>
            </tr>
            <tr>
                <td><strong>Inventory Service</strong></td>
                <td>Pre-scale before major sales + auto-scale</td>
                <td>Known event sale times + CPU</td>
            </tr>
            <tr>
                <td><strong>Booking Service</strong></td>
                <td>Pre-scale before major sales + auto-scale</td>
                <td>Known event sale times + CPU</td>
            </tr>
            <tr>
                <td><strong>WebSocket Servers</strong></td>
                <td>Pre-scale based on expected queue size</td>
                <td>Connection count per server</td>
            </tr>
            <tr>
                <td><strong>Database (SQL)</strong></td>
                <td>Vertical scaling + Read replicas + Sharding</td>
                <td>Query latency, connection pool exhaustion</td>
            </tr>
            <tr>
                <td><strong>Cache Cluster</strong></td>
                <td>Horizontal (add nodes)</td>
                <td>Memory utilization > 70%</td>
            </tr>
            <tr>
                <td><strong>Message Queue</strong></td>
                <td>Add partitions + consumers</td>
                <td>Queue lag (messages backing up)</td>
            </tr>
        </table>

        <h3>6.3 Database Scaling</h3>

        <h4>Read Replicas</h4>
        <div class="info-box">
            <p>SQL databases use read replicas for scaling read-heavy operations:</p>
            <ul>
                <li><strong>Events/Venues:</strong> 5+ read replicas for search queries</li>
                <li><strong>Users:</strong> 2-3 read replicas for authentication</li>
                <li><strong>Bookings:</strong> Read replicas for order history queries</li>
            </ul>
            <p><strong>Replication Lag:</strong> Acceptable (seconds) for most reads. Critical reads go to primary.</p>
        </div>

        <h4>Sharding Strategy - Seats/Inventory Table</h4>
        <div class="critical-box">
            <h4>Sharding Key: event_id</h4>
            <p>The Seats table is sharded by <code>event_id</code> because:</p>
            <ul>
                <li>All seat operations for a booking are within same event</li>
                <li>Enables transactional operations across multiple seats</li>
                <li>Hot events can be isolated to dedicated shards</li>
                <li>Avoids cross-shard transactions</li>
            </ul>
            <h4>Shard Assignment</h4>
            <ul>
                <li><strong>Default:</strong> Consistent hashing: <code>shard = hash(event_id) % num_shards</code></li>
                <li><strong>Hot Events:</strong> Manually assigned to dedicated high-capacity shards</li>
            </ul>
            <h4>Number of Shards</h4>
            <p>Start with 16 shards, can reshard as needed. Each shard handles ~30K events.</p>
        </div>

        <h3>6.4 Pre-Scaling for Major Events</h3>
        <div class="warning-box">
            <h4>Known High-Demand Events</h4>
            <p>For events like Taylor Swift, Super Bowl, etc.:</p>
            <ol>
                <li><strong>48 hours before:</strong> Pre-provision 10x normal capacity</li>
                <li><strong>Enable virtual queue:</strong> Prevents thundering herd</li>
                <li><strong>Dedicated infrastructure:</strong> Isolate event to prevent affecting other sales</li>
                <li><strong>Cache warming:</strong> Pre-populate caches with event data</li>
                <li><strong>Database hot standby:</strong> Ready to promote if primary fails</li>
            </ol>
        </div>

        <h3>6.5 Rate Limiting</h3>
        <table>
            <tr>
                <th>Endpoint</th>
                <th>Rate Limit</th>
                <th>Window</th>
                <th>Rationale</th>
            </tr>
            <tr>
                <td>Search API</td>
                <td>100 requests</td>
                <td>Per minute per user</td>
                <td>Prevent search abuse</td>
            </tr>
            <tr>
                <td>Seat Hold API</td>
                <td>10 requests</td>
                <td>Per minute per user</td>
                <td>Prevent hold abuse</td>
            </tr>
            <tr>
                <td>Queue Join</td>
                <td>1 request</td>
                <td>Per event per user</td>
                <td>One queue entry per person</td>
            </tr>
            <tr>
                <td>Booking API</td>
                <td>5 requests</td>
                <td>Per minute per user</td>
                <td>Allow retries, prevent abuse</td>
            </tr>
        </table>

        <h3>6.6 Bot Prevention</h3>
        <div class="info-box">
            <h4>Anti-Bot Measures</h4>
            <ul>
                <li><strong>CAPTCHA:</strong> Required to join queue for high-demand events</li>
                <li><strong>Device Fingerprinting:</strong> Detect multiple accounts from same device</li>
                <li><strong>Behavioral Analysis:</strong> Detect automated clicking patterns</li>
                <li><strong>Verified Fan Program:</strong> Pre-registration with identity verification</li>
                <li><strong>Rate Limiting:</strong> Per-IP and per-user limits</li>
                <li><strong>Queue Randomization:</strong> Joining early doesn't guarantee front position</li>
            </ul>
        </div>
    </div>

    <!-- TRADEOFFS SECTION -->
    <div class="section" id="tradeoffs">
        <h2>7. Tradeoffs & Deep Dives</h2>

        <h3>7.1 Consistency vs. Availability</h3>
        <div class="info-box">
            <h4>Where We Choose Consistency (CP)</h4>
            <ul>
                <li><strong>Seat Inventory:</strong> Cannot allow double-booking. Use strong consistency with distributed locks.</li>
                <li><strong>Booking Transactions:</strong> Payment and booking must be ACID compliant.</li>
                <li><strong>Queue Ordering:</strong> Fair ordering requires consistent state.</li>
            </ul>
            <h4>Where We Choose Availability (AP)</h4>
            <ul>
                <li><strong>Search Results:</strong> Slightly stale results acceptable. High availability preferred.</li>
                <li><strong>Event Details:</strong> Can serve cached data if database is slow.</li>
                <li><strong>Notifications:</strong> Eventual delivery is acceptable.</li>
            </ul>
        </div>

        <h3>7.2 Synchronous vs. Asynchronous Processing</h3>
        <table>
            <tr>
                <th>Operation</th>
                <th>Mode</th>
                <th>Rationale</th>
            </tr>
            <tr>
                <td>Seat Hold</td>
                <td>Synchronous</td>
                <td>User needs immediate confirmation</td>
            </tr>
            <tr>
                <td>Payment Processing</td>
                <td>Synchronous</td>
                <td>User needs immediate result</td>
            </tr>
            <tr>
                <td>Ticket Generation</td>
                <td>Asynchronous (Queue)</td>
                <td>Can take seconds; user doesn't wait</td>
            </tr>
            <tr>
                <td>Email Notification</td>
                <td>Asynchronous (Queue)</td>
                <td>External service; don't block booking</td>
            </tr>
            <tr>
                <td>Analytics/Logging</td>
                <td>Asynchronous (Queue)</td>
                <td>Non-critical; process in background</td>
            </tr>
        </table>

        <h3>7.3 Distributed Lock Implementation</h3>
        <div class="critical-box">
            <h4>Lock Acquisition Algorithm</h4>
            <pre><code>
function acquireSeatLock(eventId, seatId, userId, ttl) {
    key = "lock:{eventId}:{seatId}"
    
    // Atomic SET if not exists with TTL
    result = cache.SET(key, userId, NX, EX, ttl)
    
    if (result == OK) {
        return {success: true, lockId: generateLockId()}
    } else {
        existingHolder = cache.GET(key)
        return {success: false, heldBy: existingHolder}
    }
}

function releaseSeatLock(eventId, seatId, userId) {
    key = "lock:{eventId}:{seatId}"
    
    // Only release if we own the lock
    script = """
        if redis.call('get', KEYS[1]) == ARGV[1] then
            return redis.call('del', KEYS[1])
        else
            return 0
        end
    """
    return cache.EVAL(script, key, userId)
}
            </code></pre>
            <h4>Why This Approach</h4>
            <ul>
                <li><strong>Atomic operations:</strong> SET NX is atomic, preventing race conditions</li>
                <li><strong>TTL prevents deadlocks:</strong> Lock auto-releases if holder crashes</li>
                <li><strong>Lua script for release:</strong> Ensures only lock owner can release</li>
            </ul>
        </div>

        <h3>7.4 Idempotency Implementation</h3>
        <div class="info-box">
            <h4>Why Idempotency is Critical</h4>
            <p>Network failures during booking can cause retries. Without idempotency, user could be charged twice.</p>
            <h4>Implementation</h4>
            <ol>
                <li>Client generates unique idempotency key: <code>{userId}-{holdId}-{timestamp}</code></li>
                <li>Includes in request header: <code>Idempotency-Key: user123-hold_abc-1234567890</code></li>
                <li>Server checks if key exists in database/cache</li>
                <li>If exists: return cached response (no re-processing)</li>
                <li>If not: process request, store result with key, return response</li>
            </ol>
            <h4>Storage</h4>
            <p>Idempotency keys stored in cache with 24-hour TTL. For critical operations, also stored in SQL.</p>
        </div>

        <h3>7.5 Message Queue Deep Dive</h3>
        <div class="info-box">
            <h4>Queue Configuration</h4>
            <ul>
                <li><strong>Delivery:</strong> At-least-once (consumers must be idempotent)</li>
                <li><strong>Ordering:</strong> Per-partition ordering (partition by booking_id)</li>
                <li><strong>Retention:</strong> 7 days (for replay/debugging)</li>
                <li><strong>Consumer Groups:</strong> Separate groups for tickets, notifications, analytics</li>
            </ul>
            <h4>Message Flow</h4>
            <ol>
                <li><strong>Producer:</strong> Booking Service publishes after successful payment</li>
                <li><strong>Topic:</strong> <code>booking-events</code></li>
                <li><strong>Message:</strong> <code>{"type": "BOOKING_CONFIRMED", "booking_id": "bk_xyz", "timestamp": "..."}</code></li>
                <li><strong>Consumers:</strong>
                    <ul>
                        <li>Ticket Generator: generates tickets, updates booking</li>
                        <li>Notification Service: sends email, push</li>
                        <li>Analytics Service: records metrics</li>
                    </ul>
                </li>
                <li><strong>Acknowledgment:</strong> Consumer acks after processing; if fails, message re-delivered</li>
            </ol>
            <h4>Retry Strategy</h4>
            <ul>
                <li>Initial retry: 1 second</li>
                <li>Exponential backoff: 1s, 2s, 4s, 8s, 16s</li>
                <li>Max retries: 5</li>
                <li>Dead letter queue: Failed messages after max retries</li>
            </ul>
        </div>

        <h3>7.6 WebSocket Scaling Deep Dive</h3>
        <div class="info-box">
            <h4>Challenge</h4>
            <p>Millions of concurrent WebSocket connections during major sales. Single server can handle ~100K connections.</p>
            <h4>Solution: Horizontally Scaled WebSocket Servers</h4>
            <ol>
                <li><strong>Connection Distribution:</strong> Load balancer distributes connections across servers</li>
                <li><strong>Sticky Sessions:</strong> Same user reconnects to same server (IP hash or cookie)</li>
                <li><strong>Shared State:</strong> Connection registry in distributed cache
                    <ul>
                        <li>Key: <code>ws_conn:{queue_token}</code></li>
                        <li>Value: <code>server_instance_id</code></li>
                    </ul>
                </li>
                <li><strong>Cross-Server Communication:</strong> Pub/Sub for broadcasting
                    <ul>
                        <li>Position Publisher publishes to channel: <code>queue_updates:{event_id}</code></li>
                        <li>All WebSocket servers subscribe to relevant channels</li>
                        <li>Each server delivers to its local connections</li>
                    </ul>
                </li>
            </ol>
            <h4>Connection Lifecycle</h4>
            <pre><code>
1. Client connects: wss://queue.example.com/ws?token=qt_abc123
2. Load balancer routes to Server-3 (based on IP hash)
3. Server-3 validates token, accepts connection
4. Server-3 stores: connections[qt_abc123] = websocket_handle
5. Server-3 registers in cache: ws_conn:qt_abc123 = "server-3"
6. Server-3 subscribes to: queue_updates:evt_12345
7. Position Publisher publishes: {"positions": [...]}
8. Server-3 receives, sends to local connections
9. Client disconnects: Server-3 cleans up local state and cache
            </code></pre>
        </div>
    </div>

    <!-- ALTERNATIVES SECTION -->
    <div class="section" id="alternatives">
        <h2>8. Alternative Approaches</h2>

        <h3>8.1 Seat Inventory Management</h3>
        <table>
            <tr>
                <th>Approach</th>
                <th>Description</th>
                <th>Why Not Chosen</th>
            </tr>
            <tr>
                <td><strong>Optimistic Locking Only</strong></td>
                <td>Use version numbers and retry on conflict</td>
                <td>High contention during popular sales causes too many retries. User experience suffers.</td>
            </tr>
            <tr>
                <td><strong>Database Row Locking Only</strong></td>
                <td>Use SELECT FOR UPDATE in SQL</td>
                <td>Works but slower than distributed cache locks. Creates database hotspots.</td>
            </tr>
            <tr>
                <td><strong>Pre-allocated Tokens</strong></td>
                <td>Generate fixed number of "purchase tokens" before sale</td>
                <td>Less flexible; can't handle dynamic inventory changes during sale.</td>
            </tr>
            <tr>
                <td><strong>Event Sourcing</strong></td>
                <td>Store all seat state changes as events</td>
                <td>Added complexity. Traditional CRUD sufficient for our consistency needs.</td>
            </tr>
        </table>
        <div class="info-box">
            <p><strong>Chosen Approach:</strong> Distributed locks in cache + SQL row locking as backup. Provides speed of in-memory locks with durability of database.</p>
        </div>

        <h3>8.2 Queue Position Updates</h3>
        <table>
            <tr>
                <th>Approach</th>
                <th>Description</th>
                <th>Why Not Chosen</th>
            </tr>
            <tr>
                <td><strong>Short Polling</strong></td>
                <td>Client polls every 5 seconds</td>
                <td>1 million users √ó 12 requests/min = 12M requests/min. Massive server load. High latency for updates.</td>
            </tr>
            <tr>
                <td><strong>Long Polling</strong></td>
                <td>Client holds connection, server responds when update available</td>
                <td>Still requires reconnection after each update. More complex than WebSocket. Higher latency.</td>
            </tr>
            <tr>
                <td><strong>Server-Sent Events (SSE)</strong></td>
                <td>Unidirectional server-to-client stream</td>
                <td>Would work, but WebSocket provides bidirectional capability for heartbeats and user actions. WebSocket has better browser support for reconnection.</td>
            </tr>
        </table>
        <div class="info-box">
            <p><strong>Chosen Approach:</strong> WebSocket for real-time bidirectional communication. Most efficient for high-frequency updates to many concurrent users.</p>
        </div>

        <h3>8.3 Payment Processing</h3>
        <table>
            <tr>
                <th>Approach</th>
                <th>Description</th>
                <th>Why Not Chosen</th>
            </tr>
            <tr>
                <td><strong>Two-Phase Commit</strong></td>
                <td>Distributed transaction across booking and payment</td>
                <td>Complex, slow, and payment gateways don't support 2PC. Not practical.</td>
            </tr>
            <tr>
                <td><strong>Synchronous with Timeout</strong></td>
                <td>Wait for payment gateway with strict timeout</td>
                <td>Gateway timeouts can leave state uncertain. Need compensating transactions anyway.</td>
            </tr>
        </table>
        <div class="info-box">
            <p><strong>Chosen Approach:</strong> Saga pattern with compensating transactions. Create pending booking ‚Üí Process payment ‚Üí Confirm booking OR Rollback on failure. Idempotency keys prevent double-charging.</p>
        </div>

        <h3>8.4 Search Architecture</h3>
        <table>
            <tr>
                <th>Approach</th>
                <th>Description</th>
                <th>Why Not Chosen</th>
            </tr>
            <tr>
                <td><strong>SQL LIKE Queries</strong></td>
                <td>Use database full-text search</td>
                <td>Slow for complex queries. Doesn't scale for millions of searches. Poor relevance ranking.</td>
            </tr>
            <tr>
                <td><strong>SQL Full-Text Index</strong></td>
                <td>Native database full-text indexing</td>
                <td>Better than LIKE but still limited. Doesn't support faceted search, geo queries as well.</td>
            </tr>
        </table>
        <div class="info-box">
            <p><strong>Chosen Approach:</strong> Dedicated search index with inverted indexes. Optimized for text search, faceted filtering, geo-spatial queries, and relevance scoring. Synced from primary database asynchronously.</p>
        </div>

        <h3>8.5 Ticket Delivery</h3>
        <table>
            <tr>
                <th>Approach</th>
                <th>Description</th>
                <th>Why Not Chosen</th>
            </tr>
            <tr>
                <td><strong>Physical Mail</strong></td>
                <td>Mail printed tickets</td>
                <td>Slow, expensive, risk of loss. Only offered as premium option.</td>
            </tr>
            <tr>
                <td><strong>Will Call</strong></td>
                <td>Pick up at venue</td>
                <td>Creates lines at venue. Still offered as backup option.</td>
            </tr>
            <tr>
                <td><strong>Static PDF Email</strong></td>
                <td>Email PDF without dynamic verification</td>
                <td>Easier to counterfeit. No way to invalidate after transfer.</td>
            </tr>
        </table>
        <div class="info-box">
            <p><strong>Chosen Approach:</strong> Digital tickets with dynamic QR codes. Token validated at venue in real-time. Can be transferred, invalidated, and tracked. Mobile wallet integration (Apple Wallet, Google Pay).</p>
        </div>
    </div>

    <!-- ADDITIONAL CONSIDERATIONS SECTION -->
    <div class="section" id="additional">
        <h2>9. Additional Considerations</h2>

        <h3>9.1 Disaster Recovery</h3>
        <div class="critical-box">
            <h4>Multi-Region Deployment</h4>
            <ul>
                <li><strong>Active-Active:</strong> Multiple regions serving traffic simultaneously</li>
                <li><strong>Data Replication:</strong> Async replication between regions (eventual consistency for reads)</li>
                <li><strong>Failover:</strong> Automatic DNS failover if region goes down (< 1 minute)</li>
            </ul>
            <h4>Backup Strategy</h4>
            <ul>
                <li><strong>Database:</strong> Point-in-time recovery with 30-day retention</li>
                <li><strong>Object Storage:</strong> Cross-region replication</li>
                <li><strong>Configuration:</strong> Version controlled, can redeploy in minutes</li>
            </ul>
        </div>

        <h3>9.2 Security Considerations</h3>
        <table>
            <tr>
                <th>Threat</th>
                <th>Mitigation</th>
            </tr>
            <tr>
                <td><strong>Scalping Bots</strong></td>
                <td>CAPTCHA, device fingerprinting, verified fan program, rate limiting, queue randomization</td>
            </tr>
            <tr>
                <td><strong>Payment Fraud</strong></td>
                <td>CVV verification, address verification, velocity checks, 3D Secure</td>
            </tr>
            <tr>
                <td><strong>Ticket Counterfeiting</strong></td>
                <td>Cryptographically signed tokens, real-time validation, rotating barcodes</td>
            </tr>
            <tr>
                <td><strong>Account Takeover</strong></td>
                <td>MFA, session management, suspicious login detection</td>
            </tr>
            <tr>
                <td><strong>DDoS Attacks</strong></td>
                <td>CDN protection, rate limiting, auto-scaling, traffic scrubbing</td>
            </tr>
            <tr>
                <td><strong>Data Breaches</strong></td>
                <td>Encryption at rest/transit, PCI-DSS compliance, minimal data retention</td>
            </tr>
        </table>

        <h3>9.3 Monitoring & Observability</h3>
        <div class="info-box">
            <h4>Key Metrics to Monitor</h4>
            <ul>
                <li><strong>Business:</strong> Tickets sold/min, conversion rate, cart abandonment, queue wait times</li>
                <li><strong>Technical:</strong> Request latency (p50, p95, p99), error rates, throughput, queue depth</li>
                <li><strong>Infrastructure:</strong> CPU, memory, disk, network, connection pools</li>
                <li><strong>Availability:</strong> Uptime, health check status, failover events</li>
            </ul>
            <h4>Alerting Thresholds</h4>
            <ul>
                <li>Error rate > 1% ‚Üí Warning</li>
                <li>Error rate > 5% ‚Üí Critical</li>
                <li>P99 latency > 1s ‚Üí Warning</li>
                <li>P99 latency > 3s ‚Üí Critical</li>
                <li>Queue depth growing continuously ‚Üí Warning</li>
            </ul>
        </div>

        <h3>9.4 Compliance Requirements</h3>
        <table>
            <tr>
                <th>Requirement</th>
                <th>Implication</th>
            </tr>
            <tr>
                <td><strong>PCI-DSS</strong></td>
                <td>Payment data handling. Use tokenization, don't store card numbers, secure network.</td>
            </tr>
            <tr>
                <td><strong>GDPR</strong></td>
                <td>European user data. Right to deletion, data portability, consent management.</td>
            </tr>
            <tr>
                <td><strong>CCPA</strong></td>
                <td>California privacy. Disclosure of data collection, opt-out of sale.</td>
            </tr>
            <tr>
                <td><strong>ADA</strong></td>
                <td>Accessibility. Screen reader support, keyboard navigation, accessible seat selection.</td>
            </tr>
        </table>

        <h3>9.5 Internationalization</h3>
        <div class="info-box">
            <ul>
                <li><strong>Multi-currency:</strong> Display and charge in local currency</li>
                <li><strong>Multi-language:</strong> Localized UI, event descriptions, notifications</li>
                <li><strong>Time zones:</strong> Display event times in user's local timezone</li>
                <li><strong>Payment methods:</strong> Support regional payment options (iDEAL, Alipay, etc.)</li>
            </ul>
        </div>

        <h3>9.6 Future Enhancements</h3>
        <ul>
            <li><strong>Dynamic Pricing:</strong> Adjust prices based on demand (like airlines)</li>
            <li><strong>Waitlist:</strong> Notify users when sold-out events have cancellations</li>
            <li><strong>Resale Marketplace:</strong> Official ticket transfer/resale platform</li>
            <li><strong>NFT Tickets:</strong> Blockchain-based ticket ownership for collectibles</li>
            <li><strong>AR Seat Preview:</strong> View seat perspective before purchase</li>
            <li><strong>AI Recommendations:</strong> Personalized event suggestions</li>
        </ul>
    </div>

    <!-- VENDOR SECTION -->
    <div class="section" id="vendors">
        <h2>10. Vendor Recommendations</h2>
        <p>While the design is vendor-agnostic, here are potential vendors for each component:</p>

        <h3>10.1 Databases</h3>
        <table>
            <tr>
                <th>Component</th>
                <th>Potential Vendors</th>
                <th>Rationale</th>
            </tr>
            <tr>
                <td><strong>SQL Database</strong></td>
                <td>PostgreSQL, MySQL, CockroachDB, Amazon Aurora, Google Cloud Spanner</td>
                <td>PostgreSQL: mature, ACID, good performance. CockroachDB/Spanner: global distribution, automatic sharding.</td>
            </tr>
            <tr>
                <td><strong>In-Memory Cache/Lock</strong></td>
                <td>Redis, Memcached, Hazelcast, Amazon ElastiCache</td>
                <td>Redis: sorted sets for queue, atomic operations for locks, pub/sub for WebSocket coordination.</td>
            </tr>
            <tr>
                <td><strong>Search Index</strong></td>
                <td>Elasticsearch, Apache Solr, Algolia, Meilisearch</td>
                <td>Elasticsearch: powerful full-text search, faceting, geo-queries, widely adopted.</td>
            </tr>
        </table>

        <h3>10.2 Message Queue / Pub-Sub</h3>
        <table>
            <tr>
                <th>Component</th>
                <th>Potential Vendors</th>
                <th>Rationale</th>
            </tr>
            <tr>
                <td><strong>Message Queue</strong></td>
                <td>Apache Kafka, RabbitMQ, Amazon SQS, Google Pub/Sub, Apache Pulsar</td>
                <td>Kafka: high throughput, durability, replay capability, partitioning for scalability.</td>
            </tr>
            <tr>
                <td><strong>Pub/Sub for WebSocket</strong></td>
                <td>Redis Pub/Sub, NATS, Apache Kafka</td>
                <td>Redis Pub/Sub: simple, low latency, good for real-time broadcast to WebSocket servers.</td>
            </tr>
        </table>

        <h3>10.3 Object Storage</h3>
        <table>
            <tr>
                <th>Component</th>
                <th>Potential Vendors</th>
                <th>Rationale</th>
            </tr>
            <tr>
                <td><strong>Object Storage</strong></td>
                <td>Amazon S3, Google Cloud Storage, Azure Blob Storage, MinIO</td>
                <td>S3: industry standard, highly durable (11 9's), signed URLs, CDN integration.</td>
            </tr>
        </table>

        <h3>10.4 CDN</h3>
        <table>
            <tr>
                <th>Component</th>
                <th>Potential Vendors</th>
                <th>Rationale</th>
            </tr>
            <tr>
                <td><strong>CDN</strong></td>
                <td>Cloudflare, Akamai, Amazon CloudFront, Fastly, Google Cloud CDN</td>
                <td>Cloudflare: global network, DDoS protection, edge computing. Fastly: real-time purging, edge logic.</td>
            </tr>
        </table>

        <h3>10.5 External Services</h3>
        <table>
            <tr>
                <th>Component</th>
                <th>Potential Vendors</th>
                <th>Rationale</th>
            </tr>
            <tr>
                <td><strong>Payment Gateway</strong></td>
                <td>Stripe, Adyen, Braintree, PayPal, Square</td>
                <td>Stripe: developer-friendly, global coverage, fraud detection, 3D Secure support.</td>
            </tr>
            <tr>
                <td><strong>Email Provider</strong></td>
                <td>SendGrid, Mailgun, Amazon SES, Postmark</td>
                <td>SendGrid: reliable delivery, templates, analytics, high volume support.</td>
            </tr>
            <tr>
                <td><strong>Push Notifications</strong></td>
                <td>Firebase Cloud Messaging (FCM), Apple Push Notification Service (APNS), OneSignal</td>
                <td>FCM/APNS: native platform support. OneSignal: cross-platform abstraction.</td>
            </tr>
            <tr>
                <td><strong>CAPTCHA</strong></td>
                <td>reCAPTCHA, hCaptcha, Cloudflare Turnstile</td>
                <td>reCAPTCHA: widely trusted. Turnstile: privacy-focused, invisible challenge.</td>
            </tr>
        </table>

        <h3>10.6 Infrastructure</h3>
        <table>
            <tr>
                <th>Component</th>
                <th>Potential Vendors</th>
                <th>Rationale</th>
            </tr>
            <tr>
                <td><strong>Container Orchestration</strong></td>
                <td>Kubernetes, Amazon ECS, Google GKE, Azure AKS</td>
                <td>Kubernetes: industry standard, auto-scaling, self-healing, vendor-agnostic.</td>
            </tr>
            <tr>
                <td><strong>Load Balancer</strong></td>
                <td>AWS ALB/NLB, Google Cloud Load Balancing, NGINX, HAProxy, Traefik</td>
                <td>Cloud-native LBs: managed, global, auto-scaling. NGINX/HAProxy: flexible, on-prem option.</td>
            </tr>
            <tr>
                <td><strong>Monitoring</strong></td>
                <td>Datadog, New Relic, Prometheus + Grafana, Splunk</td>
                <td>Datadog: comprehensive APM, logs, metrics, traces. Prometheus: open-source, Kubernetes-native.</td>
            </tr>
        </table>
    </div>

    <!-- SUMMARY SECTION -->
    <div class="section">
        <h2>Summary</h2>
        <p>This Ticketmaster system design addresses the unique challenges of a high-scale ticket booking platform:</p>
        
        <h3>Key Design Decisions</h3>
        <ul>
            <li><strong>Virtual Queue:</strong> Essential for handling millions of concurrent users during high-demand sales while ensuring fairness</li>
            <li><strong>Distributed Locking:</strong> Prevents double-booking with sub-millisecond lock acquisition using in-memory cache</li>
            <li><strong>Temporary Holds:</strong> 10-minute seat reservations balance user experience with inventory availability</li>
            <li><strong>Saga Pattern:</strong> Handles distributed transactions across booking and payment services</li>
            <li><strong>WebSocket:</strong> Real-time queue position updates without polling overhead</li>
            <li><strong>Message Queue:</strong> Decouples booking from ticket generation and notifications</li>
            <li><strong>CDN + Cache:</strong> Handles traffic spikes and reduces origin load</li>
            <li><strong>Sharding by Event:</strong> Isolates high-demand events and enables horizontal scaling</li>
        </ul>

        <h3>Architecture Highlights</h3>
        <ul>
            <li><strong>Availability:</strong> Multi-region deployment with automatic failover</li>
            <li><strong>Consistency:</strong> Strong consistency for inventory, eventual consistency for reads</li>
            <li><strong>Scalability:</strong> Horizontal scaling of stateless services, pre-scaling for known events</li>
            <li><strong>Performance:</strong> Sub-200ms search, sub-100ms seat selection, sub-500ms booking</li>
        </ul>

        <div class="info-box">
            <p><strong>Total Estimated Infrastructure (Peak Event):</strong></p>
            <ul>
                <li>100+ API Gateway instances</li>
                <li>50+ Service instances per microservice</li>
                <li>20+ WebSocket server instances</li>
                <li>100+ node cache cluster</li>
                <li>16+ database shards with replicas</li>
                <li>Global CDN with 200+ edge locations</li>
            </ul>
        </div>
    </div>

    <script>
        mermaid.initialize({ startOnLoad: true, theme: 'default' });
    </script>
</body>
</html>