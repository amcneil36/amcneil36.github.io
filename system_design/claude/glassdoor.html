<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>System Design: Glassdoor</title>
<script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
<style>
  :root { --bg: #0d1117; --card: #161b22; --border: #30363d; --text: #e6edf3; --muted: #8b949e; --accent: #58a6ff; --green: #3fb950; --orange: #d29922; --red: #f85149; --purple: #bc8cff; }
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: var(--bg); color: var(--text); font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif; line-height: 1.7; padding: 2rem; max-width: 1200px; margin: 0 auto; }
  h1 { font-size: 2.4rem; margin-bottom: 0.5rem; color: var(--accent); border-bottom: 2px solid var(--accent); padding-bottom: 0.5rem; }
  h2 { font-size: 1.8rem; margin-top: 3rem; margin-bottom: 1rem; color: var(--green); border-bottom: 1px solid var(--border); padding-bottom: 0.4rem; }
  h3 { font-size: 1.4rem; margin-top: 2rem; margin-bottom: 0.8rem; color: var(--purple); }
  h4 { font-size: 1.15rem; margin-top: 1.5rem; margin-bottom: 0.5rem; color: var(--orange); }
  p, li { font-size: 1rem; margin-bottom: 0.6rem; }
  ul, ol { padding-left: 1.5rem; margin-bottom: 1rem; }
  li { margin-bottom: 0.4rem; }
  code { background: #1f2937; padding: 2px 6px; border-radius: 4px; font-size: 0.92rem; color: var(--orange); }
  pre { background: #1f2937; padding: 1rem; border-radius: 8px; overflow-x: auto; margin-bottom: 1rem; }
  .card { background: var(--card); border: 1px solid var(--border); border-radius: 10px; padding: 1.5rem; margin-bottom: 1.5rem; }
  .example-card { background: #1c2333; border-left: 4px solid var(--accent); padding: 1rem 1.5rem; margin-bottom: 1rem; border-radius: 0 8px 8px 0; }
  .example-card strong { color: var(--accent); }
  .warn { background: #2d1f00; border-left: 4px solid var(--orange); padding: 1rem 1.5rem; margin-bottom: 1rem; border-radius: 0 8px 8px 0; }
  .info { background: #0d2240; border-left: 4px solid var(--accent); padding: 1rem 1.5rem; margin-bottom: 1rem; border-radius: 0 8px 8px 0; }
  table { width: 100%; border-collapse: collapse; margin-bottom: 1.5rem; }
  th, td { border: 1px solid var(--border); padding: 0.6rem 1rem; text-align: left; }
  th { background: #1f2937; color: var(--accent); }
  td { background: var(--card); }
  .mermaid { background: #fff; border-radius: 10px; padding: 1.5rem; margin: 1.5rem 0; text-align: center; }
  .tag { display: inline-block; background: #1f2937; color: var(--accent); padding: 2px 10px; border-radius: 12px; font-size: 0.85rem; margin-right: 0.3rem; }
  .section-divider { border: none; border-top: 2px dashed var(--border); margin: 3rem 0; }
</style>
</head>
<body>

<h1>System Design: Glassdoor</h1>
<p style="color:var(--muted); margin-bottom:2rem;">A platform for anonymous company reviews, salary transparency, job searching, and interview experience sharing.</p>

<!-- ============================================================ -->
<h2>1. Functional Requirements</h2>
<!-- ============================================================ -->
<div class="card">
<ol>
  <li><strong>Anonymous Company Reviews</strong> â€” Users can submit anonymous reviews for companies they have worked at (including ratings for work-life balance, compensation, culture, management, and an overall rating, along with prose for pros/cons/advice).</li>
  <li><strong>Company Profile Browsing</strong> â€” Users can view a company's profile page showing aggregated ratings, paginated reviews, salary summaries, interview experiences, and open jobs.</li>
  <li><strong>Salary Data Submission &amp; Browsing</strong> â€” Users can anonymously submit salary information (base, bonus, stock, total compensation) for a role at a company, and browse aggregated salary data by company and job title.</li>
  <li><strong>Interview Experience Submission &amp; Browsing</strong> â€” Users can anonymously submit interview experiences (difficulty, questions asked, tips, offer outcome) and browse them per company.</li>
  <li><strong>Job Posting (Employer)</strong> â€” Employers/companies can post job listings with title, description, location, salary range, job type, and experience level.</li>
  <li><strong>Job Search</strong> â€” Users can search and filter jobs by keyword, location, job type, salary range, experience level, and company.</li>
  <li><strong>Job Application</strong> â€” Users can apply to job listings by submitting a resume and cover letter, and can track application status.</li>
  <li><strong>Company Search</strong> â€” Users can search for companies by name, industry, or location.</li>
  <li><strong>Content Moderation</strong> â€” Reviews and salary submissions are moderated (automated + manual) before becoming publicly visible.</li>
  <li><strong>Employer Dashboard</strong> â€” Employers can view applicants, respond to reviews, and manage job listings.</li>
</ol>
</div>

<!-- ============================================================ -->
<h2>2. Non-Functional Requirements</h2>
<!-- ============================================================ -->
<div class="card">
<ol>
  <li><strong>High Availability (99.9%+)</strong> â€” The platform should be accessible at all times; downtime impacts job seekers and employers alike.</li>
  <li><strong>Low Read Latency (&lt; 200ms p99)</strong> â€” Company profile pages, search results, and job listings must load fast. This is a read-heavy system (estimated 100:1 read-to-write ratio).</li>
  <li><strong>Anonymity Guarantees</strong> â€” Reviewer identities must be cryptographically protected. Even database administrators should not be able to de-anonymize a review.</li>
  <li><strong>Scalability</strong> â€” Support tens of millions of monthly active users, millions of reviews, and hundreds of thousands of job listings.</li>
  <li><strong>Data Integrity</strong> â€” Reviews, salary data, and job applications must not be lost (durability).</li>
  <li><strong>Eventual Consistency</strong> â€” Aggregated metrics (average ratings, salary ranges) can tolerate seconds to low minutes of staleness. Strict real-time consistency is not required.</li>
  <li><strong>Content Moderation SLA</strong> â€” Reviews should be moderated and published (or rejected) within minutes of submission via automated systems, with human escalation within hours.</li>
  <li><strong>Fault Tolerance</strong> â€” Failure in one service (e.g., moderation) should not cascade to others (e.g., job search).</li>
  <li><strong>SEO Friendly</strong> â€” Company profile pages and job listings should be server-side rendered or pre-rendered for search engine indexing.</li>
</ol>
</div>

<hr class="section-divider">

<!-- ============================================================ -->
<h2>3. Flow 1 â€” Review Submission &amp; Moderation</h2>
<!-- ============================================================ -->

<h3>3.1 Diagram</h3>
<div class="mermaid">
graph LR
    U["ðŸ‘¤ User (Browser/App)"] -->|"HTTP POST /api/reviews"| LB["Load Balancer"]
    LB --> AG["API Gateway"]
    AG -->|"Auth + rate limit"| RS["Review Service"]
    RS -->|"Check duplicate via anonymous_hash"| NDB[("NoSQL DB<br/>(Reviews)")]
    RS -->|"Save review (status=pending)"| NDB
    RS -->|"Enqueue moderation task"| MQ1["Message Queue<br/>(Moderation Queue)"]
    MQ1 --> CMS["Content Moderation<br/>Service"]
    CMS -->|"NLP + rule-based<br/>check"| CMS
    CMS -->|"Update status=approved/rejected"| NDB
    CMS -->|"If approved, enqueue<br/>aggregation task"| MQ2["Message Queue<br/>(Aggregation Queue)"]
    MQ2 --> AW["Aggregation Worker"]
    AW -->|"Recompute avg ratings,<br/>review count"| SDB[("SQL DB<br/>(Companies)")]
    AW -->|"Invalidate company<br/>profile cache"| CACHE[("In-Memory Cache")]
    AW -->|"Update search index"| SI["Search Index"]

    style U fill:#1f6feb,color:#fff
    style LB fill:#6e40c9,color:#fff
    style AG fill:#6e40c9,color:#fff
    style RS fill:#238636,color:#fff
    style NDB fill:#d29922,color:#000
    style MQ1 fill:#f85149,color:#fff
    style MQ2 fill:#f85149,color:#fff
    style CMS fill:#238636,color:#fff
    style AW fill:#238636,color:#fff
    style SDB fill:#d29922,color:#000
    style CACHE fill:#bc8cff,color:#000
    style SI fill:#bc8cff,color:#000
</div>

<h3>3.2 Flow Examples</h3>

<div class="example-card">
<strong>Example 1 â€” Happy Path (Review Approved):</strong><br/>
User "alice" (a current employee at Acme Corp) opens the Glassdoor app, navigates to Acme Corp's page, and clicks "Write a Review." She fills in an overall rating of 4/5, rates work-life balance 5/5, compensation 3/5, culture 4/5, management 4/5, writes pros ("great work-life balance, free lunch"), cons ("below-market pay"), and advice to management ("raise salaries"). She submits the form. This triggers an <code>HTTP POST /api/reviews</code> to the API Gateway via the Load Balancer. The API Gateway authenticates Alice's JWT token, rate-limits the request, and forwards it to the Review Service. The Review Service computes <code>anonymous_hash = SHA-256(alice_user_id + acme_company_id + salt)</code>, checks the NoSQL Reviews DB to ensure no existing review has this hash (preventing duplicates). Finding none, it saves the review with <code>status = "pending"</code> and enqueues a moderation task on the Moderation Queue. The Content Moderation Service picks up the task, runs NLP-based toxicity detection and rule-based checks (no profanity, no PII leakage, minimum word count). The review passes. The service updates the review status to <code>"approved"</code> in the NoSQL DB and enqueues an aggregation task on the Aggregation Queue. The Aggregation Worker reads all approved reviews for Acme Corp, recomputes the average ratings and total review count, updates the Companies SQL table, invalidates the Acme Corp cache entry, and updates the search index. Within 30 seconds, the review is live on Acme Corp's page.
</div>

<div class="example-card">
<strong>Example 2 â€” Review Rejected (Toxic Content):</strong><br/>
User "bob" submits a review for Beta Inc containing profanity and personal attacks against a named manager. The flow proceeds identically through the Review Service saving it as <code>status = "pending"</code> and enqueuing it. The Content Moderation Service detects high toxicity scores and PII (a named individual). It updates the review status to <code>"rejected"</code> in the NoSQL DB. No aggregation task is enqueued. Bob receives a notification (via email or in-app) that his review did not meet community guidelines with a reason code. He can edit and resubmit.
</div>

<div class="example-card">
<strong>Example 3 â€” Duplicate Review Prevented:</strong><br/>
User "alice" tries to submit a second review for Acme Corp. The Review Service computes the same <code>anonymous_hash</code> and finds an existing review in the NoSQL DB with that hash. The service returns <code>HTTP 409 Conflict</code> with a message: "You have already reviewed this company. You may edit your existing review." The request is rejected without hitting the moderation queue.
</div>

<h3>3.3 Component Deep Dive</h3>

<h4>Load Balancer</h4>
<div class="card">
<p>Sits in front of the API Gateway. Distributes incoming HTTP/HTTPS traffic across multiple API Gateway instances using a <strong>least-connections</strong> algorithm (preferred over round-robin because review submissions can vary in processing time). Performs TLS termination, health checks on downstream instances, and connection draining during deployments. Operates at Layer 7 (application layer) to enable path-based routing if needed.</p>
</div>

<h4>API Gateway</h4>
<div class="card">
<p>Single entry point for all client requests. Responsibilities: JWT-based authentication, rate limiting (per-user: 5 review submissions per hour), request validation, and routing to downstream microservices. Also handles CORS and request/response logging.</p>
</div>

<h4>Review Service</h4>
<div class="card">
<p><strong>Protocol:</strong> HTTP/REST</p>
<ul>
  <li><code>POST /api/reviews</code>
    <ul>
      <li><strong>Input:</strong> JSON body â€” <code>{ company_id, overall_rating, work_life_balance_rating, compensation_rating, culture_rating, management_rating, title, pros, cons, advice_to_management, job_title, employment_status, is_current_employee }</code>. Auth token in header.</li>
      <li><strong>Output:</strong> <code>201 Created</code> â€” <code>{ review_id, status: "pending", message: "Your review is under moderation" }</code></li>
      <li><strong>Output (duplicate):</strong> <code>409 Conflict</code> â€” <code>{ error: "Duplicate review for this company" }</code></li>
    </ul>
  </li>
  <li><code>PUT /api/reviews/{review_id}</code>
    <ul>
      <li><strong>Input:</strong> Same JSON body as POST (for editing an existing review).</li>
      <li><strong>Output:</strong> <code>200 OK</code> â€” <code>{ review_id, status: "pending" }</code> (re-enters moderation)</li>
    </ul>
  </li>
  <li><code>GET /api/reviews?company_id={id}&page={n}&sort={recent|helpful}</code>
    <ul>
      <li><strong>Input:</strong> Query parameters for company, pagination, sort order.</li>
      <li><strong>Output:</strong> <code>200 OK</code> â€” <code>{ reviews: [...], total_count, page, has_next }</code></li>
    </ul>
  </li>
</ul>
<p>Computes the <code>anonymous_hash = SHA-256(user_id + company_id + salt)</code> to enforce one-review-per-company-per-user while preserving anonymity. The salt is a server-side secret stored in a secrets manager.</p>
</div>

<h4>NoSQL DB (Reviews)</h4>
<div class="card">
<p>Stores all review documents. Partitioned by <code>company_id</code> for fast lookups of "all reviews for company X." Sort key is <code>created_at</code> for chronological pagination. Chosen as NoSQL because reviews are semi-structured (variable-length text fields), high volume, read-heavy per company, and do not require complex joins. Schema detailed in Section 8.</p>
</div>

<h4>Message Queue (Moderation Queue)</h4>
<div class="card">
<p>A durable, ordered message queue. When the Review Service saves a pending review, it publishes a message containing <code>{ review_id, company_id }</code>. The Content Moderation Service is a consumer that pulls messages, processes them, and acknowledges (removes from queue) after updating the review status. If the consumer fails, the message remains and is retried (at-least-once delivery). Visibility timeout prevents duplicate processing. Dead-letter queue captures messages that fail repeatedly for manual investigation.</p>
</div>

<h4>Content Moderation Service</h4>
<div class="card">
<p>Stateless service that performs automated moderation. Two-phase check:</p>
<ol>
  <li><strong>Automated (NLP-based):</strong> Toxicity scoring, sentiment analysis, PII detection (names, emails, phone numbers), spam detection, minimum quality thresholds (word count, not gibberish).</li>
  <li><strong>Rule-based:</strong> Blocklist of prohibited terms, required fields validation, rating consistency checks.</li>
</ol>
<p>If confidence is low (borderline cases), the review is flagged for human moderator review. Otherwise, auto-approved or auto-rejected. Updates the review status in the NoSQL DB directly.</p>
</div>

<h4>Message Queue (Aggregation Queue)</h4>
<div class="card">
<p>When a review is approved, a message <code>{ company_id, review_id, action: "approved" }</code> is enqueued. The Aggregation Worker consumes this to update company-level statistics. Same durability and retry semantics as the Moderation Queue.</p>
</div>

<h4>Aggregation Worker</h4>
<div class="card">
<p>Consumes messages from the Aggregation Queue. For each approved/deleted review event, it queries the NoSQL Reviews DB for all approved reviews for that <code>company_id</code>, recomputes average ratings and total review count, and performs a transactional update to the Companies SQL table. It then invalidates the company's entry in the in-memory cache and sends an update event to the search index. This is an <strong>asynchronous, eventually consistent</strong> process â€” acceptable because a few seconds of staleness in aggregate ratings is imperceptible to users.</p>
</div>

<h4>SQL DB (Companies)</h4>
<div class="card">
<p>Stores company metadata and <strong>denormalized</strong> aggregate fields (avg_overall_rating, avg_work_life_balance, avg_compensation, avg_culture, avg_management, total_review_count). Denormalized to avoid expensive aggregation queries on every profile view. Updated by the Aggregation Worker. Schema detailed in Section 8.</p>
</div>

<h4>In-Memory Cache</h4>
<div class="card">
<p>Caches company profile data (aggregated ratings, metadata). Deep dive in Section 10.</p>
</div>

<h4>Search Index</h4>
<div class="card">
<p>Inverted index that enables full-text search across company names, review content, and job titles. Updated asynchronously when reviews are approved. Deep dive in Section 12.</p>
</div>

<hr class="section-divider">

<!-- ============================================================ -->
<h2>4. Flow 2 â€” Company Profile Viewing</h2>
<!-- ============================================================ -->

<h3>4.1 Diagram</h3>
<div class="mermaid">
graph LR
    U["ðŸ‘¤ User (Browser/App)"] -->|"HTTP GET /api/companies/{id}"| LB["Load Balancer"]
    LB --> AG["API Gateway"]
    AG --> CS["Company Service"]
    CS -->|"1. Check cache"| CACHE[("In-Memory Cache")]
    CACHE -->|"Cache HIT â†’ return"| CS
    CS -->|"2. Cache MISS â†’ query"| SDB[("SQL DB<br/>(Companies)")]
    SDB -->|"Company metadata +<br/>aggregated ratings"| CS
    CS -->|"3. Populate cache"| CACHE
    CS -->|"Return company profile"| U

    U -->|"HTTP GET /api/reviews?company_id={id}"| LB2["Load Balancer"]
    LB2 --> AG2["API Gateway"]
    AG2 --> RS["Review Service"]
    RS -->|"Query approved reviews<br/>(paginated)"| NDB[("NoSQL DB<br/>(Reviews)")]

    U -->|"HTTP GET /api/salaries?company_id={id}"| LB3["Load Balancer"]
    LB3 --> AG3["API Gateway"]
    AG3 --> SS["Salary Service"]
    SS -->|"Query salary data"| NDB2[("NoSQL DB<br/>(Salaries)")]

    U -->|"HTTP GET /api/jobs?company_id={id}"| LB4["Load Balancer"]
    LB4 --> AG4["API Gateway"]
    AG4 --> JS["Job Service"]
    JS -->|"Query active jobs"| SDB2[("SQL DB<br/>(Jobs)")]

    CDN["CDN"] -->|"Company logo,<br/>static assets"| U

    style U fill:#1f6feb,color:#fff
    style LB fill:#6e40c9,color:#fff
    style LB2 fill:#6e40c9,color:#fff
    style LB3 fill:#6e40c9,color:#fff
    style LB4 fill:#6e40c9,color:#fff
    style AG fill:#6e40c9,color:#fff
    style AG2 fill:#6e40c9,color:#fff
    style AG3 fill:#6e40c9,color:#fff
    style AG4 fill:#6e40c9,color:#fff
    style CS fill:#238636,color:#fff
    style RS fill:#238636,color:#fff
    style SS fill:#238636,color:#fff
    style JS fill:#238636,color:#fff
    style CACHE fill:#bc8cff,color:#000
    style SDB fill:#d29922,color:#000
    style SDB2 fill:#d29922,color:#000
    style NDB fill:#d29922,color:#000
    style NDB2 fill:#d29922,color:#000
    style CDN fill:#f85149,color:#fff
</div>

<h3>4.2 Flow Examples</h3>

<div class="example-card">
<strong>Example 1 â€” Cache Hit (Popular Company):</strong><br/>
User "carol" searches for "Acme Corp" and clicks on the company profile. Her browser makes parallel requests: <code>GET /api/companies/acme123</code> for the profile summary, <code>GET /api/reviews?company_id=acme123&page=1&sort=recent</code> for reviews, <code>GET /api/salaries?company_id=acme123</code> for salary data, and <code>GET /api/jobs?company_id=acme123&status=active</code> for open positions. The Company Service checks the in-memory cache for <code>acme123</code>. Acme Corp is a popular company, so the cache has a valid (non-expired) entry. The cached data (company name, headquarters, industry, size, aggregated ratings: overall 3.8/5, 12,453 reviews) is returned in &lt;5ms. Meanwhile, the Review Service queries the NoSQL Reviews DB with partition key <code>company_id=acme123</code> and sort key descending by <code>created_at</code>, returning the first 20 approved reviews. The Salary Service queries the NoSQL Salaries DB, and the Job Service queries the SQL Jobs DB. The CDN serves the Acme Corp logo. All responses are assembled client-side into the company profile page.
</div>

<div class="example-card">
<strong>Example 2 â€” Cache Miss (Obscure Company):</strong><br/>
User "dave" navigates to "TinyStartup LLC" profile. The Company Service checks the cache â€” no entry found (cache miss). It queries the SQL Companies DB for <code>company_id=tiny456</code>, retrieves the metadata and aggregated ratings (overall 4.2/5, 7 reviews), populates the cache with a 10-minute TTL, and returns the result. Subsequent visitors within 10 minutes will get a cache hit.
</div>

<div class="example-card">
<strong>Example 3 â€” Paginated Reviews:</strong><br/>
User "eve" is reading reviews for MegaCorp and scrolls down past the first 20 reviews. Her browser makes <code>GET /api/reviews?company_id=mega789&page=2&sort=recent</code>. The Review Service queries the NoSQL DB for the next page using the <code>created_at</code> sort key as a cursor, returning reviews 21â€“40. Reviews marked as "rejected" or "pending" are filtered out server-side.
</div>

<h3>4.3 Component Deep Dive</h3>

<h4>Company Service</h4>
<div class="card">
<p><strong>Protocol:</strong> HTTP/REST</p>
<ul>
  <li><code>GET /api/companies/{company_id}</code>
    <ul>
      <li><strong>Input:</strong> Path parameter <code>company_id</code>.</li>
      <li><strong>Output:</strong> <code>200 OK</code> â€” <code>{ company_id, name, headquarters, industry, size, website, logo_url, description, founded_year, avg_overall_rating, avg_work_life_balance, avg_compensation, avg_culture, avg_management, total_review_count, avg_salary }</code></li>
    </ul>
  </li>
  <li><code>GET /api/companies?q={search_term}&industry={ind}&page={n}</code>
    <ul>
      <li><strong>Input:</strong> Query parameters for search, filtering, and pagination.</li>
      <li><strong>Output:</strong> <code>200 OK</code> â€” <code>{ companies: [...], total_count, page, has_next }</code></li>
    </ul>
  </li>
</ul>
<p>Implements cache-aside pattern: check cache first, on miss read from SQL DB and populate cache.</p>
</div>

<h4>Salary Service</h4>
<div class="card">
<p><strong>Protocol:</strong> HTTP/REST</p>
<ul>
  <li><code>GET /api/salaries?company_id={id}&job_title={title}&page={n}</code>
    <ul>
      <li><strong>Input:</strong> Query parameters.</li>
      <li><strong>Output:</strong> <code>200 OK</code> â€” <code>{ salaries: [{ job_title, base_salary, bonus, stock, total_comp, years_experience, location }], aggregated: { avg_base, avg_total, median_base, salary_range }, total_count }</code></li>
    </ul>
  </li>
</ul>
</div>

<h4>Job Service</h4>
<div class="card">
<p><strong>Protocol:</strong> HTTP/REST</p>
<ul>
  <li><code>GET /api/jobs?company_id={id}&status=active&page={n}</code>
    <ul>
      <li><strong>Input:</strong> Query parameters.</li>
      <li><strong>Output:</strong> <code>200 OK</code> â€” <code>{ jobs: [{ job_id, title, location, salary_range, job_type, posted_at }], total_count, page, has_next }</code></li>
    </ul>
  </li>
</ul>
</div>

<h4>CDN (Content Delivery Network)</h4>
<div class="card">
<p>Serves static assets: company logos, user-uploaded images, JavaScript/CSS bundles, and pre-rendered company profile pages for SEO. Company logos are uploaded by employers and stored in Object Storage, then cached on CDN edge nodes globally. Deep dive in Section 10.</p>
</div>

<hr class="section-divider">

<!-- ============================================================ -->
<h2>5. Flow 3 â€” Salary &amp; Interview Experience Submission</h2>
<!-- ============================================================ -->

<h3>5.1 Diagram</h3>
<div class="mermaid">
graph LR
    U["ðŸ‘¤ User (Browser/App)"] -->|"HTTP POST /api/salaries<br/>or /api/interviews"| LB["Load Balancer"]
    LB --> AG["API Gateway"]
    AG -->|"Auth + rate limit"| SVC["Salary Service /<br/>Interview Service"]
    SVC -->|"Check duplicate<br/>via anonymous_hash"| NDB[("NoSQL DB<br/>(Salaries / Interviews)")]
    SVC -->|"Save with status=pending"| NDB
    SVC -->|"Enqueue validation task"| MQ["Message Queue<br/>(Validation Queue)"]
    MQ --> VS["Validation Service"]
    VS -->|"Outlier detection,<br/>sanity checks"| VS
    VS -->|"Update status"| NDB
    VS -->|"If approved, enqueue<br/>aggregation"| MQ2["Message Queue<br/>(Aggregation Queue)"]
    MQ2 --> AW["Aggregation Worker"]
    AW -->|"Update salary stats,<br/>interview stats"| SDB[("SQL DB<br/>(Companies)")]
    AW -->|"Invalidate cache"| CACHE[("In-Memory Cache")]

    style U fill:#1f6feb,color:#fff
    style LB fill:#6e40c9,color:#fff
    style AG fill:#6e40c9,color:#fff
    style SVC fill:#238636,color:#fff
    style NDB fill:#d29922,color:#000
    style MQ fill:#f85149,color:#fff
    style MQ2 fill:#f85149,color:#fff
    style VS fill:#238636,color:#fff
    style AW fill:#238636,color:#fff
    style SDB fill:#d29922,color:#000
    style CACHE fill:#bc8cff,color:#000
</div>

<h3>5.2 Flow Examples</h3>

<div class="example-card">
<strong>Example 1 â€” Salary Submission (Approved):</strong><br/>
User "frank" navigates to Acme Corp's salary page and clicks "Add Salary." He enters: job title "Software Engineer," base salary $150,000, bonus $20,000, stock $30,000, total $200,000, 5 years experience, location "San Francisco." He submits. This triggers <code>HTTP POST /api/salaries</code>. The Salary Service computes <code>anonymous_hash = SHA-256(frank_user_id + acme_company_id + "salary" + salt)</code>, checks for duplicates (Frank hasn't submitted salary data for Acme before), saves with <code>status = "pending"</code>, and enqueues a validation task. The Validation Service checks that the salary values are within reasonable ranges for the role and location (outlier detection using statistical bounds from existing data). $150K base for a Software Engineer in SF is within range. Status is updated to <code>"approved"</code>. Aggregation Worker updates Acme Corp's average salary metrics and invalidates the cache.
</div>

<div class="example-card">
<strong>Example 2 â€” Salary Rejected (Outlier):</strong><br/>
User "grace" submits a salary for "Intern" at a small startup with a base salary of $5,000,000. The Validation Service flags this as a statistical outlier (>3 standard deviations from the mean for that role). Status is set to <code>"rejected"</code> with reason <code>"salary_outlier"</code>. Grace is prompted to double-check her entry.
</div>

<div class="example-card">
<strong>Example 3 â€” Interview Experience Submission:</strong><br/>
User "hank" submits an interview experience for Beta Inc: job title "Product Manager," difficulty 4/5, experience "Positive," offer received "Yes," description of 4-round process, and 3 interview questions. This follows the same flow via <code>HTTP POST /api/interviews</code>. The Validation Service checks for minimum content quality (not empty, no PII). Approved, and aggregated interview stats (average difficulty, % positive experiences) are updated on Beta Inc's profile.
</div>

<h3>5.3 Component Deep Dive</h3>

<h4>Salary Service</h4>
<div class="card">
<p><strong>Protocol:</strong> HTTP/REST</p>
<ul>
  <li><code>POST /api/salaries</code>
    <ul>
      <li><strong>Input:</strong> JSON body â€” <code>{ company_id, job_title, base_salary, bonus, stock_compensation, total_compensation, currency, years_of_experience, location, employment_type }</code></li>
      <li><strong>Output:</strong> <code>201 Created</code> â€” <code>{ salary_id, status: "pending" }</code></li>
    </ul>
  </li>
</ul>
</div>

<h4>Interview Service</h4>
<div class="card">
<p><strong>Protocol:</strong> HTTP/REST</p>
<ul>
  <li><code>POST /api/interviews</code>
    <ul>
      <li><strong>Input:</strong> JSON body â€” <code>{ company_id, job_title, difficulty_rating, overall_experience, offer_received, interview_process_description, questions: [...], tips }</code></li>
      <li><strong>Output:</strong> <code>201 Created</code> â€” <code>{ interview_id, status: "pending" }</code></li>
    </ul>
  </li>
  <li><code>GET /api/interviews?company_id={id}&page={n}</code>
    <ul>
      <li><strong>Input:</strong> Query parameters.</li>
      <li><strong>Output:</strong> <code>200 OK</code> â€” <code>{ interviews: [...], aggregated: { avg_difficulty, pct_positive, pct_offer }, total_count }</code></li>
    </ul>
  </li>
</ul>
</div>

<h4>Validation Service</h4>
<div class="card">
<p>A specialized moderation service for numeric/structured data. Unlike the text-heavy Content Moderation Service for reviews, this focuses on:</p>
<ul>
  <li><strong>Statistical outlier detection:</strong> Compares submitted salary against known distributions for the role, location, and company size.</li>
  <li><strong>Sanity checks:</strong> Base salary > 0, total â‰¥ base, years of experience within reasonable bounds, currency is valid.</li>
  <li><strong>PII detection:</strong> Scans free-text fields in interview experiences for names, emails, etc.</li>
</ul>
</div>

<hr class="section-divider">

<!-- ============================================================ -->
<h2>6. Flow 4 â€” Job Search &amp; Application</h2>
<!-- ============================================================ -->

<h3>6.1 Diagram</h3>
<div class="mermaid">
graph LR
    subgraph Job Posting
        E["ðŸ¢ Employer"] -->|"HTTP POST /api/jobs"| LB["Load Balancer"]
        LB --> AG["API Gateway"]
        AG --> JS["Job Service"]
        JS -->|"Save job listing"| SDB[("SQL DB<br/>(Jobs)")]
        JS -->|"Index for search"| SI["Search Index"]
    end

    subgraph Job Search
        U["ðŸ‘¤ User"] -->|"HTTP GET /api/jobs/search?q=..."| LB2["Load Balancer"]
        LB2 --> AG2["API Gateway"]
        AG2 --> SS["Search Service"]
        SS -->|"Full-text + filter query"| SI
        SI -->|"Ranked results"| SS
        SS -->|"Enrich with company data"| CACHE[("In-Memory Cache")]
        SS -->|"Return results"| U
    end

    subgraph Job Application
        U2["ðŸ‘¤ User"] -->|"HTTP POST /api/applications"| LB3["Load Balancer"]
        LB3 --> AG3["API Gateway"]
        AG3 --> AS["Application Service"]
        AS -->|"Upload resume"| OBJ[("Object Storage")]
        AS -->|"Save application"| SDB2[("SQL DB<br/>(Applications)")]
        AS -->|"Notify employer"| MQ["Message Queue<br/>(Notification Queue)"]
        MQ --> NS["Notification Service"]
        NS -->|"Email employer"| EMAIL["Email Provider"]
    end

    style E fill:#d29922,color:#000
    style U fill:#1f6feb,color:#fff
    style U2 fill:#1f6feb,color:#fff
    style LB fill:#6e40c9,color:#fff
    style LB2 fill:#6e40c9,color:#fff
    style LB3 fill:#6e40c9,color:#fff
    style AG fill:#6e40c9,color:#fff
    style AG2 fill:#6e40c9,color:#fff
    style AG3 fill:#6e40c9,color:#fff
    style JS fill:#238636,color:#fff
    style SS fill:#238636,color:#fff
    style AS fill:#238636,color:#fff
    style NS fill:#238636,color:#fff
    style SDB fill:#d29922,color:#000
    style SDB2 fill:#d29922,color:#000
    style SI fill:#bc8cff,color:#000
    style CACHE fill:#bc8cff,color:#000
    style OBJ fill:#f85149,color:#fff
    style MQ fill:#f85149,color:#fff
    style EMAIL fill:#8b949e,color:#000
</div>

<h3>6.2 Flow Examples</h3>

<div class="example-card">
<strong>Example 1 â€” Employer Posts a Job:</strong><br/>
An HR manager at Acme Corp logs into the employer dashboard and clicks "Post a Job." She fills in: title "Senior Backend Engineer," description (500 words), location "New York, NY," remote-friendly "Yes," salary range "$180Kâ€“$220K," job type "Full-time," experience level "Senior (5+ years)." She clicks Publish. This triggers <code>HTTP POST /api/jobs</code>. The Job Service validates the input, saves the job listing to the SQL Jobs DB with <code>status = "active"</code> and <code>posted_at = now()</code>, and sends the job document to the Search Index for indexing. The job is now searchable within seconds.
</div>

<div class="example-card">
<strong>Example 2 â€” User Searches for Jobs:</strong><br/>
User "ivan" visits Glassdoor and types "backend engineer new york" into the job search bar, selects filters: Full-time, $150K+, Senior level. This triggers <code>GET /api/jobs/search?q=backend+engineer&location=new+york&type=full-time&min_salary=150000&level=senior&page=1</code>. The Search Service constructs a query against the Search Index combining full-text match on "backend engineer," geo filter for New York, and structured filters for type/salary/level. The index returns ranked job IDs. The Search Service enriches results with company names and logos from the cache (or SQL DB on miss) and returns a paginated list of 20 results. Ivan sees Acme Corp's "Senior Backend Engineer" listing at the top.
</div>

<div class="example-card">
<strong>Example 3 â€” User Applies to a Job:</strong><br/>
User "ivan" clicks "Apply" on the Acme Corp listing. He uploads his resume (PDF, 2MB) and writes a cover letter. This triggers <code>HTTP POST /api/applications</code> with a multipart form. The Application Service uploads the resume to Object Storage (returns a <code>resume_url</code>), saves the application record to the SQL Applications DB with <code>status = "submitted"</code>, and enqueues a notification message on the Notification Queue. The Notification Service picks up the message and sends an email to the Acme Corp HR manager: "New application received for Senior Backend Engineer from a candidate." Ivan sees his application in "My Applications" with status "Submitted."
</div>

<div class="example-card">
<strong>Example 4 â€” Application Status Update:</strong><br/>
The Acme Corp HR manager reviews Ivan's application in the employer dashboard and changes the status to "Interviewing." This triggers <code>PATCH /api/applications/{app_id}</code> with <code>{ status: "interviewing" }</code>. The Application Service updates the SQL DB and enqueues a notification. The Notification Service sends Ivan an email: "Your application status for Senior Backend Engineer at Acme Corp has been updated to: Interviewing."
</div>

<h3>6.3 Component Deep Dive</h3>

<h4>Job Service</h4>
<div class="card">
<p><strong>Protocol:</strong> HTTP/REST</p>
<ul>
  <li><code>POST /api/jobs</code> (Employer only)
    <ul>
      <li><strong>Input:</strong> JSON body â€” <code>{ company_id, title, description, location_city, location_state, location_country, is_remote, salary_range_min, salary_range_max, currency, job_type, experience_level }</code></li>
      <li><strong>Output:</strong> <code>201 Created</code> â€” <code>{ job_id, status: "active" }</code></li>
    </ul>
  </li>
  <li><code>GET /api/jobs/{job_id}</code>
    <ul>
      <li><strong>Input:</strong> Path parameter.</li>
      <li><strong>Output:</strong> <code>200 OK</code> â€” Full job details including company info.</li>
    </ul>
  </li>
  <li><code>PATCH /api/jobs/{job_id}</code> (Employer only)
    <ul>
      <li><strong>Input:</strong> Partial update JSON (e.g., <code>{ status: "filled" }</code>).</li>
      <li><strong>Output:</strong> <code>200 OK</code></li>
    </ul>
  </li>
  <li><code>DELETE /api/jobs/{job_id}</code> (Employer only â€” soft delete)
    <ul>
      <li><strong>Output:</strong> <code>204 No Content</code></li>
    </ul>
  </li>
</ul>
</div>

<h4>Search Service</h4>
<div class="card">
<p><strong>Protocol:</strong> HTTP/REST</p>
<ul>
  <li><code>GET /api/jobs/search?q={query}&location={loc}&type={t}&min_salary={s}&level={l}&page={n}</code>
    <ul>
      <li><strong>Input:</strong> Query parameters for keyword, location, filters, pagination.</li>
      <li><strong>Output:</strong> <code>200 OK</code> â€” <code>{ results: [{ job_id, title, company_name, company_logo_url, location, salary_range, posted_at }], total_count, page, has_next }</code></li>
    </ul>
  </li>
  <li><code>GET /api/companies/search?q={query}&industry={ind}&page={n}</code>
    <ul>
      <li><strong>Input:</strong> Query parameters.</li>
      <li><strong>Output:</strong> <code>200 OK</code> â€” <code>{ results: [{ company_id, name, logo_url, avg_rating, total_reviews, industry }], total_count }</code></li>
    </ul>
  </li>
</ul>
<p>The Search Service is a thin orchestration layer that translates user queries into search index queries, applies ranking (relevance + recency + salary match), enriches results with data from the cache, and returns formatted responses.</p>
</div>

<h4>Application Service</h4>
<div class="card">
<p><strong>Protocol:</strong> HTTP/REST</p>
<ul>
  <li><code>POST /api/applications</code>
    <ul>
      <li><strong>Input:</strong> Multipart form â€” resume file + JSON <code>{ job_id, cover_letter_text }</code>. Auth token in header.</li>
      <li><strong>Output:</strong> <code>201 Created</code> â€” <code>{ application_id, status: "submitted" }</code></li>
    </ul>
  </li>
  <li><code>GET /api/applications?user_id={id}&page={n}</code> (User's applications)
    <ul>
      <li><strong>Output:</strong> <code>200 OK</code> â€” <code>{ applications: [{ application_id, job_title, company_name, status, applied_at }] }</code></li>
    </ul>
  </li>
  <li><code>PATCH /api/applications/{app_id}</code> (Employer updates status)
    <ul>
      <li><strong>Input:</strong> <code>{ status: "interviewing" | "offered" | "rejected" }</code></li>
      <li><strong>Output:</strong> <code>200 OK</code></li>
    </ul>
  </li>
</ul>
</div>

<h4>Object Storage</h4>
<div class="card">
<p>Stores binary files: resumes (PDF, DOCX), company logos, and other uploaded assets. Provides durable, highly available storage with unique URLs for each object. Resumes are stored with access controls (only the applicant and the employer for that specific job can access). Company logos are publicly accessible and served through the CDN.</p>
</div>

<h4>Notification Service</h4>
<div class="card">
<p>Consumes messages from the Notification Queue. Supports multiple channels: email (primary), in-app notifications (stored in a notifications table), and optionally push notifications. For job applications, it sends:</p>
<ul>
  <li>To employer: "New application received for [Job Title]"</li>
  <li>To applicant: "Application status updated to [Status]"</li>
  <li>To applicant: "Your review has been approved/rejected"</li>
</ul>
</div>

<h4>Search Index</h4>
<div class="card">
<p>A dedicated <strong>inverted index</strong> for full-text search across multiple entity types (jobs, companies, reviews). Supports:</p>
<ul>
  <li><strong>Full-text search:</strong> Tokenized, stemmed, and analyzed text fields (job titles, descriptions, company names, review content).</li>
  <li><strong>Structured filters:</strong> Exact match on job_type, experience_level, location; range filters on salary.</li>
  <li><strong>Relevance ranking:</strong> TF-IDF or BM25 scoring combined with recency boost and popularity signals.</li>
  <li><strong>Faceted search:</strong> Aggregations for filter counts (e.g., "15 Full-time, 3 Part-time, 2 Contract").</li>
</ul>
<p>Populated asynchronously via message queue events when jobs are posted, reviews are approved, or companies are updated.</p>
</div>

<hr class="section-divider">

<!-- ============================================================ -->
<h2>7. Combined Overall Flow</h2>
<!-- ============================================================ -->

<h3>7.1 Diagram</h3>
<div class="mermaid">
graph TB
    USER["ðŸ‘¤ User / Job Seeker"] --> LB["Load Balancer<br/>(Layer 7)"]
    EMPLOYER["ðŸ¢ Employer"] --> LB

    LB --> AGW["API Gateway<br/>(Auth, Rate Limit, Routing)"]

    AGW --> CS["Company Service"]
    AGW --> RS["Review Service"]
    AGW --> SS["Salary Service"]
    AGW --> IS["Interview Service"]
    AGW --> JS["Job Service"]
    AGW --> AS["Application Service"]
    AGW --> SRCH["Search Service"]

    CS --> CACHE[("In-Memory Cache<br/>(Company Profiles)")]
    CACHE --> SQL_CO[("SQL DB<br/>(Companies, Users)")]
    CS --> SQL_CO

    RS --> NOSQL_R[("NoSQL DB<br/>(Reviews)")]
    SS --> NOSQL_S[("NoSQL DB<br/>(Salaries)")]
    IS --> NOSQL_I[("NoSQL DB<br/>(Interviews)")]

    JS --> SQL_J[("SQL DB<br/>(Jobs)")]
    AS --> SQL_A[("SQL DB<br/>(Applications)")]
    AS --> OBJ[("Object Storage<br/>(Resumes, Logos)")]

    SRCH --> SI[("Search Index<br/>(Inverted Index)")]

    RS -->|"Enqueue"| MQ_MOD["Message Queue<br/>(Moderation)"]
    SS -->|"Enqueue"| MQ_VAL["Message Queue<br/>(Validation)"]
    IS -->|"Enqueue"| MQ_VAL
    AS -->|"Enqueue"| MQ_NOT["Message Queue<br/>(Notification)"]

    MQ_MOD --> CMS["Content Moderation<br/>Service"]
    MQ_VAL --> VALS["Validation Service"]
    MQ_NOT --> NS["Notification Service"]

    CMS -->|"Approved"| MQ_AGG["Message Queue<br/>(Aggregation)"]
    VALS -->|"Approved"| MQ_AGG

    MQ_AGG --> AW["Aggregation Worker"]
    AW --> SQL_CO
    AW --> CACHE
    AW --> SI

    NS --> EMAIL["Email / Push"]

    CDN["CDN<br/>(Logos, Static Assets)"] --> USER
    OBJ --> CDN

    style USER fill:#1f6feb,color:#fff
    style EMPLOYER fill:#d29922,color:#000
    style LB fill:#6e40c9,color:#fff
    style AGW fill:#6e40c9,color:#fff
    style CS fill:#238636,color:#fff
    style RS fill:#238636,color:#fff
    style SS fill:#238636,color:#fff
    style IS fill:#238636,color:#fff
    style JS fill:#238636,color:#fff
    style AS fill:#238636,color:#fff
    style SRCH fill:#238636,color:#fff
    style CMS fill:#238636,color:#fff
    style VALS fill:#238636,color:#fff
    style NS fill:#238636,color:#fff
    style AW fill:#238636,color:#fff
    style CACHE fill:#bc8cff,color:#000
    style SQL_CO fill:#d29922,color:#000
    style SQL_J fill:#d29922,color:#000
    style SQL_A fill:#d29922,color:#000
    style NOSQL_R fill:#d29922,color:#000
    style NOSQL_S fill:#d29922,color:#000
    style NOSQL_I fill:#d29922,color:#000
    style SI fill:#bc8cff,color:#000
    style OBJ fill:#f85149,color:#fff
    style MQ_MOD fill:#f85149,color:#fff
    style MQ_VAL fill:#f85149,color:#fff
    style MQ_NOT fill:#f85149,color:#fff
    style MQ_AGG fill:#f85149,color:#fff
    style CDN fill:#f85149,color:#fff
    style EMAIL fill:#8b949e,color:#000
</div>

<h3>7.2 Combined Flow Examples</h3>

<div class="example-card">
<strong>End-to-End Example â€” Full User Journey:</strong><br/>
<strong>Step 1 (Job Search):</strong> User "ivan" opens Glassdoor and searches "product manager san francisco." The request flows through the Load Balancer â†’ API Gateway â†’ Search Service â†’ Search Index, which returns ranked job results enriched with company data from the cache. Ivan sees 50+ results.<br/><br/>
<strong>Step 2 (Company Research):</strong> Ivan clicks on Acme Corp from the results to research the company before applying. His browser fires parallel requests to the Company Service (cache hit â€” returns aggregated 3.8/5 rating from 12K reviews), Review Service (returns 20 most recent approved reviews from NoSQL), Salary Service (returns PM salary data: avg $180K base from NoSQL), and Interview Service (returns interview experiences: avg difficulty 3.5/5). The CDN serves Acme Corp's logo.<br/><br/>
<strong>Step 3 (Submit Salary):</strong> While browsing, Ivan decides to contribute his own salary data from his current employer. He clicks "Add Salary" and submits $175K base for PM at his current company. This goes through API Gateway â†’ Salary Service â†’ saves to NoSQL (pending) â†’ Validation Queue â†’ Validation Service approves â†’ Aggregation Queue â†’ Aggregation Worker updates company stats and invalidates cache.<br/><br/>
<strong>Step 4 (Apply):</strong> Satisfied with Acme Corp's reviews, Ivan applies to the PM role. He uploads his resume and writes a cover letter. The Application Service uploads the resume to Object Storage, saves the application to the SQL Applications DB, and enqueues a notification. The Notification Service emails Acme Corp's recruiter.<br/><br/>
<strong>Step 5 (Status Update):</strong> Two days later, Acme Corp's recruiter moves Ivan to "Interviewing." The Application Service updates the SQL DB and enqueues a notification. Ivan receives an email and sees the updated status in "My Applications."
</div>

<div class="example-card">
<strong>End-to-End Example â€” Employer Journey:</strong><br/>
<strong>Step 1 (Post Job):</strong> An Acme Corp recruiter logs into the employer dashboard and posts a new "Senior PM" role. Job Service saves to SQL Jobs DB and indexes it in the Search Index.<br/><br/>
<strong>Step 2 (Monitor Reviews):</strong> The recruiter checks Acme Corp's profile and sees a new 2-star review complaining about management. She clicks "Respond" and writes a public employer response. This goes through the Review Service as a special <code>POST /api/reviews/{id}/response</code>.<br/><br/>
<strong>Step 3 (Review Applicants):</strong> She navigates to the "Senior PM" job listing and views 15 applications. Application Service returns paginated applications from the SQL DB. She downloads resumes from Object Storage via pre-signed URLs, updates statuses, and notifications are sent to applicants.
</div>

<hr class="section-divider">

<!-- ============================================================ -->
<h2>8. Database Schema</h2>
<!-- ============================================================ -->

<h3>8.1 SQL Tables</h3>

<h4>Table: <code>users</code></h4>
<div class="card">
<table>
  <tr><th>Column</th><th>Type</th><th>Constraints</th></tr>
  <tr><td>user_id</td><td>UUID</td><td><strong>PRIMARY KEY</strong></td></tr>
  <tr><td>email</td><td>VARCHAR(255)</td><td>UNIQUE, NOT NULL</td></tr>
  <tr><td>hashed_password</td><td>VARCHAR(255)</td><td>NOT NULL</td></tr>
  <tr><td>display_name</td><td>VARCHAR(100)</td><td>NOT NULL</td></tr>
  <tr><td>user_type</td><td>ENUM('job_seeker','employer')</td><td>NOT NULL</td></tr>
  <tr><td>current_company_id</td><td>UUID</td><td><strong>FOREIGN KEY â†’ companies.company_id</strong>, NULLABLE</td></tr>
  <tr><td>current_job_title</td><td>VARCHAR(200)</td><td>NULLABLE</td></tr>
  <tr><td>profile_photo_url</td><td>VARCHAR(500)</td><td>NULLABLE</td></tr>
  <tr><td>created_at</td><td>TIMESTAMP</td><td>NOT NULL, DEFAULT NOW()</td></tr>
  <tr><td>updated_at</td><td>TIMESTAMP</td><td>NOT NULL, DEFAULT NOW()</td></tr>
</table>
<p><strong>Why SQL:</strong> User data requires ACID guarantees (e.g., registration, login are transactional). Relational integrity with companies table (foreign key on <code>current_company_id</code>). User profiles are relatively small in volume and well-structured.</p>
<p><strong>Indexes:</strong></p>
<ul>
  <li><strong>B-tree index on <code>email</code></strong> â€” Used for login lookups (<code>WHERE email = ?</code>). B-tree supports equality lookups efficiently. This is also enforced by the UNIQUE constraint.</li>
</ul>
<p><strong>Read/Write Events:</strong></p>
<ul>
  <li><strong>Write:</strong> User registers (INSERT), user updates profile (UPDATE).</li>
  <li><strong>Read:</strong> User logs in (SELECT by email), profile viewed, Application Service resolves user info.</li>
</ul>
<p><strong>Sharding:</strong> Shard by <code>user_id</code> (hash-based). User IDs are UUIDs, providing even distribution. Most queries are by user_id (profile lookup) or email (login), both of which are efficiently routed with hash sharding. For email lookups across shards, a lightweight emailâ†’shard lookup table or consistent hashing on email can be maintained.</p>
</div>

<h4>Table: <code>companies</code></h4>
<div class="card">
<table>
  <tr><th>Column</th><th>Type</th><th>Constraints</th></tr>
  <tr><td>company_id</td><td>UUID</td><td><strong>PRIMARY KEY</strong></td></tr>
  <tr><td>name</td><td>VARCHAR(300)</td><td>NOT NULL</td></tr>
  <tr><td>headquarters_city</td><td>VARCHAR(100)</td><td></td></tr>
  <tr><td>headquarters_state</td><td>VARCHAR(100)</td><td></td></tr>
  <tr><td>headquarters_country</td><td>VARCHAR(100)</td><td></td></tr>
  <tr><td>industry</td><td>VARCHAR(100)</td><td></td></tr>
  <tr><td>company_size_range</td><td>VARCHAR(50)</td><td></td></tr>
  <tr><td>website_url</td><td>VARCHAR(500)</td><td></td></tr>
  <tr><td>logo_url</td><td>VARCHAR(500)</td><td></td></tr>
  <tr><td>description</td><td>TEXT</td><td></td></tr>
  <tr><td>founded_year</td><td>INTEGER</td><td></td></tr>
  <tr><td>avg_overall_rating</td><td>DECIMAL(3,2)</td><td>DEFAULT 0.00 â€” <span class="tag">DENORMALIZED</span></td></tr>
  <tr><td>avg_work_life_balance</td><td>DECIMAL(3,2)</td><td>DEFAULT 0.00 â€” <span class="tag">DENORMALIZED</span></td></tr>
  <tr><td>avg_compensation_rating</td><td>DECIMAL(3,2)</td><td>DEFAULT 0.00 â€” <span class="tag">DENORMALIZED</span></td></tr>
  <tr><td>avg_culture_rating</td><td>DECIMAL(3,2)</td><td>DEFAULT 0.00 â€” <span class="tag">DENORMALIZED</span></td></tr>
  <tr><td>avg_management_rating</td><td>DECIMAL(3,2)</td><td>DEFAULT 0.00 â€” <span class="tag">DENORMALIZED</span></td></tr>
  <tr><td>total_review_count</td><td>INTEGER</td><td>DEFAULT 0 â€” <span class="tag">DENORMALIZED</span></td></tr>
  <tr><td>avg_salary</td><td>DECIMAL(12,2)</td><td>DEFAULT 0.00 â€” <span class="tag">DENORMALIZED</span></td></tr>
  <tr><td>avg_interview_difficulty</td><td>DECIMAL(3,2)</td><td>DEFAULT 0.00 â€” <span class="tag">DENORMALIZED</span></td></tr>
  <tr><td>total_interview_count</td><td>INTEGER</td><td>DEFAULT 0 â€” <span class="tag">DENORMALIZED</span></td></tr>
  <tr><td>created_at</td><td>TIMESTAMP</td><td>NOT NULL</td></tr>
  <tr><td>updated_at</td><td>TIMESTAMP</td><td>NOT NULL</td></tr>
</table>
<p><strong>Why SQL:</strong> Company metadata is structured and relational (linked to jobs, users). ACID guarantees needed for aggregate updates (concurrent Aggregation Workers must not produce inconsistent counts).</p>
<p><strong>Denormalization Explanation:</strong> The aggregate fields (<code>avg_overall_rating</code>, <code>total_review_count</code>, <code>avg_salary</code>, etc.) are denormalized from the Reviews and Salaries NoSQL tables onto the Companies row. This avoids expensive cross-database aggregation on every company profile view. Given the ~100:1 read-to-write ratio, paying a small write-time cost (Aggregation Worker recomputes on each new review/salary) to avoid expensive read-time aggregations is a clear win. The tradeoff is eventual consistency â€” aggregate values may lag by seconds after a new review is approved â€” which is acceptable for ratings displays.</p>
<p><strong>Indexes:</strong></p>
<ul>
  <li><strong>B-tree index on <code>name</code></strong> â€” Used for company name search/autocomplete (<code>WHERE name LIKE 'Acme%'</code>). B-tree supports prefix matching efficiently.</li>
  <li><strong>B-tree index on <code>industry</code></strong> â€” Used for filtering companies by industry (<code>WHERE industry = 'Technology'</code>).</li>
  <li><strong>B-tree index on <code>avg_overall_rating</code></strong> â€” Used for sorting/filtering companies by rating (<code>ORDER BY avg_overall_rating DESC</code>).</li>
</ul>
<p><strong>Read/Write Events:</strong></p>
<ul>
  <li><strong>Write:</strong> New company registered (INSERT), Aggregation Worker updates aggregates (UPDATE), employer updates company profile (UPDATE).</li>
  <li><strong>Read:</strong> User views company profile (SELECT by company_id â€” typically served from cache), company search (SELECT with filters), Search Service enrichment.</li>
</ul>
<p><strong>Sharding:</strong> Shard by <code>company_id</code> (hash-based). Most queries are by company_id. For name-based search, the Search Index handles this (not direct SQL queries), so cross-shard queries are avoided for the primary access pattern.</p>
</div>

<h4>Table: <code>jobs</code></h4>
<div class="card">
<table>
  <tr><th>Column</th><th>Type</th><th>Constraints</th></tr>
  <tr><td>job_id</td><td>UUID</td><td><strong>PRIMARY KEY</strong></td></tr>
  <tr><td>company_id</td><td>UUID</td><td><strong>FOREIGN KEY â†’ companies.company_id</strong>, NOT NULL</td></tr>
  <tr><td>posted_by_user_id</td><td>UUID</td><td><strong>FOREIGN KEY â†’ users.user_id</strong>, NOT NULL</td></tr>
  <tr><td>title</td><td>VARCHAR(300)</td><td>NOT NULL</td></tr>
  <tr><td>description</td><td>TEXT</td><td>NOT NULL</td></tr>
  <tr><td>location_city</td><td>VARCHAR(100)</td><td></td></tr>
  <tr><td>location_state</td><td>VARCHAR(100)</td><td></td></tr>
  <tr><td>location_country</td><td>VARCHAR(100)</td><td></td></tr>
  <tr><td>is_remote</td><td>BOOLEAN</td><td>DEFAULT FALSE</td></tr>
  <tr><td>salary_range_min</td><td>DECIMAL(12,2)</td><td></td></tr>
  <tr><td>salary_range_max</td><td>DECIMAL(12,2)</td><td></td></tr>
  <tr><td>currency</td><td>VARCHAR(3)</td><td>DEFAULT 'USD'</td></tr>
  <tr><td>job_type</td><td>ENUM('full_time','part_time','contract','internship')</td><td>NOT NULL</td></tr>
  <tr><td>experience_level</td><td>ENUM('entry','mid','senior','lead','executive')</td><td></td></tr>
  <tr><td>status</td><td>ENUM('active','expired','filled','draft')</td><td>NOT NULL, DEFAULT 'draft'</td></tr>
  <tr><td>posted_at</td><td>TIMESTAMP</td><td></td></tr>
  <tr><td>expires_at</td><td>TIMESTAMP</td><td></td></tr>
  <tr><td>created_at</td><td>TIMESTAMP</td><td>NOT NULL</td></tr>
  <tr><td>updated_at</td><td>TIMESTAMP</td><td>NOT NULL</td></tr>
</table>
<p><strong>Why SQL:</strong> Jobs have strict relational integrity (foreign keys to companies and users). Transactional guarantees needed for status transitions (draft â†’ active â†’ filled). Structured, well-defined schema that doesn't change.</p>
<p><strong>Indexes:</strong></p>
<ul>
  <li><strong>B-tree index on <code>company_id</code></strong> â€” Used for "all jobs at company X" queries (<code>WHERE company_id = ?</code>).</li>
  <li><strong>B-tree composite index on <code>(status, posted_at DESC)</code></strong> â€” Used for listing active jobs sorted by recency (<code>WHERE status = 'active' ORDER BY posted_at DESC</code>). Composite index allows the DB to satisfy both filter and sort from the index.</li>
  <li><strong>B-tree composite index on <code>(location_city, job_type, experience_level)</code></strong> â€” Used for filtered job browsing (<code>WHERE location_city = ? AND job_type = ? AND experience_level = ?</code>).</li>
  <li><strong>Full-text / Inverted index on <code>(title, description)</code></strong> â€” Enables keyword search within the SQL DB as a fallback to the Search Index. The primary search path uses the dedicated Search Index, but this index supports direct DB queries for admin tools or simple lookups.</li>
</ul>
<p><strong>Read/Write Events:</strong></p>
<ul>
  <li><strong>Write:</strong> Employer posts job (INSERT), employer updates job (UPDATE), job expires via scheduled task (UPDATE status).</li>
  <li><strong>Read:</strong> User views job listing (SELECT by job_id), jobs for a company (SELECT by company_id), employer views own listings.</li>
</ul>
<p><strong>Sharding:</strong> Shard by <code>company_id</code> (hash-based). Most queries are scoped to a company. For cross-company job search, the Search Index handles this, so the SQL DB is not queried across shards for search.</p>
</div>

<h4>Table: <code>applications</code></h4>
<div class="card">
<table>
  <tr><th>Column</th><th>Type</th><th>Constraints</th></tr>
  <tr><td>application_id</td><td>UUID</td><td><strong>PRIMARY KEY</strong></td></tr>
  <tr><td>job_id</td><td>UUID</td><td><strong>FOREIGN KEY â†’ jobs.job_id</strong>, NOT NULL</td></tr>
  <tr><td>user_id</td><td>UUID</td><td><strong>FOREIGN KEY â†’ users.user_id</strong>, NOT NULL</td></tr>
  <tr><td>resume_url</td><td>VARCHAR(500)</td><td>NOT NULL</td></tr>
  <tr><td>cover_letter_text</td><td>TEXT</td><td></td></tr>
  <tr><td>status</td><td>ENUM('submitted','reviewed','interviewing','offered','rejected','withdrawn')</td><td>NOT NULL, DEFAULT 'submitted'</td></tr>
  <tr><td>applied_at</td><td>TIMESTAMP</td><td>NOT NULL, DEFAULT NOW()</td></tr>
  <tr><td>updated_at</td><td>TIMESTAMP</td><td>NOT NULL</td></tr>
</table>
<p><strong>Unique constraint:</strong> <code>(job_id, user_id)</code> â€” prevents a user from applying to the same job twice.</p>
<p><strong>Why SQL:</strong> Strong relational integrity needed (ties together users, jobs, and companies). ACID guarantees for status transitions (cannot skip states). Relatively modest volume compared to reviews.</p>
<p><strong>Indexes:</strong></p>
<ul>
  <li><strong>B-tree index on <code>user_id</code></strong> â€” Used for "My Applications" page (<code>WHERE user_id = ? ORDER BY applied_at DESC</code>).</li>
  <li><strong>B-tree index on <code>job_id</code></strong> â€” Used for employer viewing applicants for a job (<code>WHERE job_id = ?</code>).</li>
  <li><strong>B-tree composite index on <code>(job_id, status)</code></strong> â€” Used for filtering applicants by status (<code>WHERE job_id = ? AND status = 'submitted'</code>).</li>
</ul>
<p><strong>Read/Write Events:</strong></p>
<ul>
  <li><strong>Write:</strong> User applies to job (INSERT), employer updates application status (UPDATE), user withdraws (UPDATE).</li>
  <li><strong>Read:</strong> User views "My Applications" (SELECT by user_id), employer views applicants (SELECT by job_id).</li>
</ul>
<p><strong>Sharding:</strong> Shard by <code>job_id</code> (hash-based). Employer queries (view applicants for a job) are the most common pattern and are single-shard. For user-centric queries ("my applications"), a Global Secondary Index or a separate user_id â†’ application_id mapping table routes the query.</p>
</div>

<h3>8.2 NoSQL Tables</h3>

<h4>Table: <code>reviews</code></h4>
<div class="card">
<table>
  <tr><th>Field</th><th>Type</th><th>Key</th></tr>
  <tr><td>review_id</td><td>UUID</td><td><strong>PRIMARY KEY (unique item identifier)</strong></td></tr>
  <tr><td>company_id</td><td>UUID</td><td><strong>PARTITION KEY</strong></td></tr>
  <tr><td>created_at</td><td>TIMESTAMP</td><td><strong>SORT KEY</strong></td></tr>
  <tr><td>anonymous_author_hash</td><td>VARCHAR(64)</td><td>Unique (for duplicate check)</td></tr>
  <tr><td>overall_rating</td><td>INTEGER (1-5)</td><td></td></tr>
  <tr><td>work_life_balance_rating</td><td>INTEGER (1-5)</td><td></td></tr>
  <tr><td>compensation_rating</td><td>INTEGER (1-5)</td><td></td></tr>
  <tr><td>culture_rating</td><td>INTEGER (1-5)</td><td></td></tr>
  <tr><td>management_rating</td><td>INTEGER (1-5)</td><td></td></tr>
  <tr><td>title</td><td>VARCHAR(300)</td><td></td></tr>
  <tr><td>pros</td><td>TEXT</td><td></td></tr>
  <tr><td>cons</td><td>TEXT</td><td></td></tr>
  <tr><td>advice_to_management</td><td>TEXT</td><td></td></tr>
  <tr><td>job_title</td><td>VARCHAR(200)</td><td></td></tr>
  <tr><td>employment_status</td><td>STRING (current/former)</td><td></td></tr>
  <tr><td>is_current_employee</td><td>BOOLEAN</td><td></td></tr>
  <tr><td>review_status</td><td>STRING (pending/approved/rejected)</td><td></td></tr>
  <tr><td>helpful_count</td><td>INTEGER</td><td>DEFAULT 0</td></tr>
</table>
<p><strong>Why NoSQL:</strong></p>
<ul>
  <li><strong>High volume:</strong> Millions of reviews, write-once-read-many pattern.</li>
  <li><strong>Flexible schema:</strong> Variable-length text fields (pros, cons can be short or very long). Future fields (e.g., CEO approval rating) can be added without schema migration.</li>
  <li><strong>Partitioned access pattern:</strong> Nearly all queries are "get reviews for company X" â†’ natural partition key is <code>company_id</code>. NoSQL excels at single-partition reads.</li>
  <li><strong>No complex joins:</strong> Reviews are self-contained documents. No need to join with other tables at query time.</li>
  <li><strong>Horizontal scalability:</strong> NoSQL scales horizontally by adding nodes, automatically distributing partitions.</li>
</ul>
<p><strong>Indexes:</strong></p>
<ul>
  <li><strong>Global Secondary Index (GSI) on <code>review_status</code></strong> â€” Used by the moderation dashboard to list all pending reviews across companies. This is an infrequent admin query, so a GSI (eventually consistent) is acceptable.</li>
  <li><strong>GSI on <code>anonymous_author_hash</code></strong> â€” Used for duplicate detection (check if hash exists before saving). Supports exact-match lookups.</li>
</ul>
<p><strong>Sharding:</strong> Data is automatically partitioned by <code>company_id</code> (the partition key). NoSQL databases handle this natively. For hot partitions (e.g., a viral company with millions of reviews), write sharding can split the partition using a random suffix appended to the partition key (e.g., <code>company_id#0</code> through <code>company_id#9</code>), with scatter-gather reads across the 10 sub-partitions.</p>
<p><strong>Read/Write Events:</strong></p>
<ul>
  <li><strong>Write:</strong> User submits review (INSERT with status=pending), Content Moderation Service updates status (UPDATE), user marks review as helpful (UPDATE helpful_count).</li>
  <li><strong>Read:</strong> User views company reviews (QUERY by company_id, sorted by created_at), Aggregation Worker reads all approved reviews for recomputation, moderation dashboard queries pending reviews.</li>
</ul>
</div>

<h4>Table: <code>salaries</code></h4>
<div class="card">
<table>
  <tr><th>Field</th><th>Type</th><th>Key</th></tr>
  <tr><td>salary_id</td><td>UUID</td><td><strong>PRIMARY KEY</strong></td></tr>
  <tr><td>company_id</td><td>UUID</td><td><strong>PARTITION KEY</strong></td></tr>
  <tr><td>job_title</td><td>VARCHAR(200)</td><td><strong>SORT KEY</strong></td></tr>
  <tr><td>anonymous_author_hash</td><td>VARCHAR(64)</td><td></td></tr>
  <tr><td>base_salary</td><td>DECIMAL</td><td></td></tr>
  <tr><td>bonus</td><td>DECIMAL</td><td></td></tr>
  <tr><td>stock_compensation</td><td>DECIMAL</td><td></td></tr>
  <tr><td>total_compensation</td><td>DECIMAL</td><td></td></tr>
  <tr><td>currency</td><td>VARCHAR(3)</td><td></td></tr>
  <tr><td>years_of_experience</td><td>INTEGER</td><td></td></tr>
  <tr><td>location</td><td>VARCHAR(200)</td><td></td></tr>
  <tr><td>employment_type</td><td>STRING</td><td></td></tr>
  <tr><td>status</td><td>STRING (pending/approved/rejected)</td><td></td></tr>
  <tr><td>created_at</td><td>TIMESTAMP</td><td></td></tr>
</table>
<p><strong>Why NoSQL:</strong> Same reasoning as reviews â€” high volume, semi-structured, partitioned access pattern by company_id, no complex joins. The sort key on <code>job_title</code> enables efficient queries like "all Software Engineer salaries at Acme Corp."</p>
<p><strong>Indexes:</strong></p>
<ul>
  <li><strong>GSI on <code>(job_title, company_id)</code></strong> â€” Enables cross-company salary comparison ("What do Software Engineers earn across all companies?"). The inverted partition/sort key allows efficient scans by job_title first.</li>
  <li><strong>GSI on <code>anonymous_author_hash</code></strong> â€” For duplicate detection.</li>
</ul>
<p><strong>Sharding:</strong> Automatically partitioned by <code>company_id</code>.</p>
<p><strong>Read/Write Events:</strong></p>
<ul>
  <li><strong>Write:</strong> User submits salary data (INSERT), Validation Service updates status (UPDATE).</li>
  <li><strong>Read:</strong> User views salary page for a company (QUERY by company_id, optionally filtered by job_title), cross-company salary comparison (QUERY GSI by job_title).</li>
</ul>
</div>

<h4>Table: <code>interview_experiences</code></h4>
<div class="card">
<table>
  <tr><th>Field</th><th>Type</th><th>Key</th></tr>
  <tr><td>interview_id</td><td>UUID</td><td><strong>PRIMARY KEY</strong></td></tr>
  <tr><td>company_id</td><td>UUID</td><td><strong>PARTITION KEY</strong></td></tr>
  <tr><td>created_at</td><td>TIMESTAMP</td><td><strong>SORT KEY</strong></td></tr>
  <tr><td>anonymous_author_hash</td><td>VARCHAR(64)</td><td></td></tr>
  <tr><td>job_title</td><td>VARCHAR(200)</td><td></td></tr>
  <tr><td>difficulty_rating</td><td>INTEGER (1-5)</td><td></td></tr>
  <tr><td>overall_experience</td><td>STRING (positive/neutral/negative)</td><td></td></tr>
  <tr><td>offer_received</td><td>STRING (yes/no/pending)</td><td></td></tr>
  <tr><td>interview_process_description</td><td>TEXT</td><td></td></tr>
  <tr><td>interview_questions</td><td>LIST&lt;STRING&gt;</td><td></td></tr>
  <tr><td>tips</td><td>TEXT</td><td></td></tr>
  <tr><td>status</td><td>STRING (pending/approved/rejected)</td><td></td></tr>
</table>
<p><strong>Why NoSQL:</strong> Same as reviews and salaries. The <code>interview_questions</code> field is a list type, which is naturally supported in NoSQL document/wide-column stores but awkward in SQL (would require a separate join table).</p>
<p><strong>Indexes:</strong> GSI on <code>anonymous_author_hash</code> for duplicate detection. GSI on <code>(company_id, job_title)</code> for filtering interviews by role at a company.</p>
<p><strong>Read/Write Events:</strong></p>
<ul>
  <li><strong>Write:</strong> User submits interview experience (INSERT), Validation Service updates status (UPDATE).</li>
  <li><strong>Read:</strong> User views interview experiences for a company (QUERY by company_id).</li>
</ul>
</div>

<hr class="section-divider">

<!-- ============================================================ -->
<h2>9. CDN Deep Dive</h2>
<!-- ============================================================ -->
<div class="card">
<h4>Why a CDN is Appropriate</h4>
<p>Glassdoor serves millions of users globally. Static assets (company logos, JavaScript/CSS bundles, fonts, images) and semi-static content (pre-rendered company profile pages for SEO) benefit enormously from CDN edge caching:</p>
<ul>
  <li><strong>Latency reduction:</strong> Assets served from the nearest edge node (50-100ms vs 200-500ms from origin).</li>
  <li><strong>Origin offload:</strong> 80%+ of requests for static assets never reach the origin servers, dramatically reducing load.</li>
  <li><strong>SEO:</strong> Pre-rendered HTML pages served from CDN edge provide fast Time-to-First-Byte for search engine crawlers.</li>
</ul>

<h4>What is Cached on CDN</h4>
<ul>
  <li><strong>Company logos and images:</strong> Stored in Object Storage, served via CDN with long TTLs (24+ hours). Cache key: URL path (e.g., <code>/logos/acme123.png</code>).</li>
  <li><strong>Static frontend assets:</strong> JS bundles, CSS, fonts. Cache-busted via content hash in filename (e.g., <code>app.a3f8b2c.js</code>). TTL: 1 year (immutable).</li>
  <li><strong>Pre-rendered pages:</strong> Server-side rendered company profiles and job listing pages for SEO. TTL: 10 minutes (stale-while-revalidate pattern).</li>
</ul>

<h4>What is NOT Cached on CDN</h4>
<ul>
  <li>Dynamic API responses (reviews, salary data, search results) â€” these are user-specific or change frequently.</li>
  <li>Authenticated endpoints (my applications, employer dashboard).</li>
</ul>

<h4>CDN Caching Strategy</h4>
<ul>
  <li><strong>Cache-Control headers:</strong> Origin sets <code>Cache-Control: public, max-age=86400</code> for logos, <code>Cache-Control: public, max-age=31536000, immutable</code> for versioned static assets.</li>
  <li><strong>Eviction:</strong> LRU at edge nodes (most CDNs handle this automatically). Rarely accessed company logos are evicted from edge caches but remain in Object Storage.</li>
  <li><strong>Invalidation:</strong> When a company updates its logo, the origin generates a new URL (e.g., <code>/logos/acme123_v2.png</code>) rather than invalidating the old CDN cache entry. This avoids cache invalidation propagation delays.</li>
</ul>
</div>

<!-- ============================================================ -->
<h2>10. In-Memory Cache Deep Dive</h2>
<!-- ============================================================ -->
<div class="card">
<h4>Why an In-Memory Cache is Appropriate</h4>
<p>Company profile data (metadata + aggregated ratings) is the single most frequently accessed data in the system. Every time a user views a company page, this data is needed. With millions of daily page views and only ~1 million companies in the database, caching the most popular company profiles yields massive read latency reduction (1-2ms cache hit vs. 5-20ms DB query) and reduces SQL DB load by 90%+.</p>

<h4>Caching Strategy: Cache-Aside (Lazy Loading)</h4>
<ol>
  <li><strong>On Read (Company Service):</strong> Check cache for <code>company:{company_id}</code>.
    <ul>
      <li><strong>Cache HIT:</strong> Return cached data immediately. Cost: ~1ms.</li>
      <li><strong>Cache MISS:</strong> Query SQL Companies DB, write result to cache with TTL, return to client.</li>
    </ul>
  </li>
  <li><strong>On Write (Aggregation Worker):</strong> After updating company aggregates in SQL DB, <strong>invalidate</strong> (delete) the cache entry for that <code>company_id</code>. The next read will repopulate the cache with fresh data.</li>
</ol>

<h4>Why Cache-Aside over Other Strategies</h4>
<ul>
  <li><strong>vs. Write-Through:</strong> Write-through would update the cache on every write. Since the Aggregation Worker already updates the DB, adding a cache write adds complexity but minimal benefit â€” the next read (which happens within seconds for popular companies) will repopulate anyway. Cache-aside is simpler.</li>
  <li><strong>vs. Write-Behind (Write-Back):</strong> Write-behind caches are risky for durability (cache failure = data loss). Our source of truth is the SQL DB, not the cache.</li>
  <li><strong>vs. Read-Through:</strong> Read-through and cache-aside are similar, but cache-aside gives the application more control over what to cache and how to serialize it.</li>
</ul>

<h4>Eviction Policy: LRU (Least Recently Used)</h4>
<p>LRU evicts the least recently accessed company profiles when the cache reaches capacity. This is ideal because company popularity follows a power-law distribution â€” the top 1% of companies (Google, Apple, Amazon, etc.) receive 50%+ of page views. LRU ensures these hot entries stay cached while rarely viewed companies are evicted.</p>

<h4>Expiration Policy: TTL of 10 Minutes</h4>
<p>Each cache entry expires after 10 minutes regardless of access frequency. This ensures:</p>
<ul>
  <li>Stale data from a failed invalidation is automatically corrected within 10 minutes.</li>
  <li>Edge case: If the Aggregation Worker fails to invalidate the cache after an aggregate update, the data self-heals within 10 minutes.</li>
  <li>10 minutes is chosen because aggregate ratings change slowly (a single new review on a company with thousands barely moves the average), so brief staleness is imperceptible to users.</li>
</ul>

<h4>What is Populated in Cache</h4>
<p>Cache key: <code>company:{company_id}</code><br/>
Cache value: Serialized JSON of company metadata + all aggregated fields (ratings, counts, average salary). Approximately 1-2 KB per entry.</p>

<h4>Capacity Estimation</h4>
<p>With ~1 million companies and ~2KB per entry, caching all companies would require ~2GB. In practice, only the top 100K most accessed companies need to be cached (200MB), which fits easily in a single cache node. A small cluster of 2-3 nodes provides redundancy.</p>
</div>

<hr class="section-divider">

<!-- ============================================================ -->
<h2>11. Message Queue Deep Dive</h2>
<!-- ============================================================ -->
<div class="card">
<h4>Why Message Queues (vs. Alternatives)</h4>
<p>Several operations in Glassdoor are <strong>asynchronous by nature</strong> â€” the user should not wait for moderation, aggregation, or notification delivery before receiving an HTTP response. Message queues provide:</p>
<ul>
  <li><strong>Decoupling:</strong> The Review Service does not need to know about or depend on the Content Moderation Service. They communicate through the queue.</li>
  <li><strong>Resilience:</strong> If the Moderation Service is down, messages accumulate in the queue and are processed when it recovers. No data is lost.</li>
  <li><strong>Backpressure handling:</strong> During traffic spikes (e.g., a viral company scandal triggers a flood of reviews), the queue absorbs the burst. Consumers process at their own rate.</li>
  <li><strong>At-least-once delivery:</strong> Messages are acknowledged only after successful processing. Failures result in retries.</li>
</ul>

<h4>Why Not Pub/Sub</h4>
<p>Pub/sub is better suited for fan-out scenarios where one event needs to reach multiple independent consumers simultaneously (e.g., a new post needs to appear in 1000 followers' feeds). In Glassdoor's case, each message in the Moderation Queue needs to be processed by exactly <strong>one</strong> consumer (one moderation worker). A message queue with competing consumers is the right fit. If in the future we need fan-out (e.g., "review approved" triggers both aggregation AND notification AND search indexing), we can use a message queue with multiple consumer groups or a hybrid pub/sub-to-queue pattern.</p>

<h4>Why Not WebSockets or Polling</h4>
<p>Glassdoor is not a real-time application. Users submit a review and move on. They don't need instant notification that their review was approved (an email 5 minutes later suffices). WebSockets would add unnecessary complexity (persistent connections, connection management, reconnection logic) for a use case that doesn't require real-time bidirectional communication. HTTP polling for application status updates would also be wasteful â€” status changes are infrequent (days between transitions), so even polling every 5 minutes would be 99.99% empty responses.</p>

<h4>Queue Architecture</h4>
<p>Four logical queues (can be separate queues or topics within a single queue cluster):</p>
<table>
  <tr><th>Queue</th><th>Producer</th><th>Consumer</th><th>Message Format</th><th>Delivery</th></tr>
  <tr><td>Moderation Queue</td><td>Review Service</td><td>Content Moderation Service</td><td><code>{ review_id, company_id, type: "review" }</code></td><td>At-least-once, 30s visibility timeout</td></tr>
  <tr><td>Validation Queue</td><td>Salary Service, Interview Service</td><td>Validation Service</td><td><code>{ item_id, company_id, type: "salary"|"interview" }</code></td><td>At-least-once, 30s visibility timeout</td></tr>
  <tr><td>Aggregation Queue</td><td>Content Moderation Service, Validation Service</td><td>Aggregation Worker</td><td><code>{ company_id, item_type, action: "approved" }</code></td><td>At-least-once, 60s visibility timeout</td></tr>
  <tr><td>Notification Queue</td><td>Application Service, Moderation/Validation</td><td>Notification Service</td><td><code>{ recipient_id, channel, template, data }</code></td><td>At-least-once, 30s visibility timeout</td></tr>
</table>

<h4>How Messages are Put on / Removed from the Queue</h4>
<ul>
  <li><strong>Enqueue (Produce):</strong> The producer service serializes the message to JSON and calls the queue's <code>sendMessage()</code> API. The queue persists the message to disk for durability and returns an acknowledgment to the producer.</li>
  <li><strong>Dequeue (Consume):</strong> Consumer services use long-polling to pull messages from the queue. When a message is received, it becomes "invisible" to other consumers for the visibility timeout period (e.g., 30 seconds). The consumer processes the message, then calls <code>deleteMessage()</code> to permanently remove it. If the consumer crashes before acknowledging, the message becomes visible again after the timeout and is redelivered to another consumer.</li>
  <li><strong>Dead-Letter Queue (DLQ):</strong> Messages that fail processing after N retries (e.g., 3) are moved to a DLQ for manual investigation. This prevents poison messages from blocking the queue.</li>
</ul>
</div>

<hr class="section-divider">

<!-- ============================================================ -->
<h2>12. Scaling Considerations</h2>
<!-- ============================================================ -->
<div class="card">

<h4>Load Balancers</h4>
<p>Load balancers are placed at two levels:</p>
<ol>
  <li><strong>External Load Balancer (Internet â†’ API Gateway):</strong> Distributes user traffic across API Gateway instances. Uses <strong>Layer 7 (application layer)</strong> routing to enable path-based routing (e.g., <code>/api/jobs/*</code> routes to Job Service cluster). Algorithm: <strong>least-connections</strong> to handle variable request processing times. Handles TLS termination to offload SSL from backend services. Supports health checks (HTTP <code>/health</code> on each API Gateway instance) and automatic removal of unhealthy instances.</li>
  <li><strong>Internal Load Balancers (API Gateway â†’ Microservices):</strong> Each microservice cluster (Review Service, Job Service, etc.) has its own internal load balancer or uses service discovery with client-side load balancing. Algorithm: <strong>round-robin</strong> (internal services have more uniform request processing times). In a containerized environment, a service mesh (e.g., Envoy sidecar) can handle this transparently.</li>
</ol>

<h4>Horizontal Scaling of Stateless Services</h4>
<p>All services (Review Service, Company Service, Job Service, Application Service, Search Service, Salary Service, Interview Service, Content Moderation Service, Validation Service, Notification Service, Aggregation Worker) are <strong>stateless</strong>. They can be horizontally scaled by adding more instances behind the load balancer. Auto-scaling policies based on CPU utilization (target: 60-70%) and request queue depth handle traffic fluctuations.</p>

<h4>Database Scaling</h4>
<ul>
  <li><strong>SQL (Companies, Users, Jobs, Applications):</strong> Vertical scaling initially (larger instances), then <strong>read replicas</strong> for read-heavy tables (Companies, Jobs). For write scaling, <strong>sharding</strong> as described in Section 8 (hash-based on primary key). Connection pooling at the application layer to manage connection limits.</li>
  <li><strong>NoSQL (Reviews, Salaries, Interviews):</strong> Naturally scales horizontally. Add nodes to the cluster; the database redistributes partitions automatically. Partition key design (company_id) ensures even distribution for most companies. Hot partition mitigation via write sharding for viral companies.</li>
</ul>

<h4>Search Index Scaling</h4>
<p>The search index is sharded across multiple nodes. As the number of indexed documents grows (jobs, companies, reviews), add more shards. Replicas of each shard provide redundancy and increased read throughput. Index updates are batched and applied asynchronously to minimize write amplification.</p>

<h4>Cache Scaling</h4>
<p>The in-memory cache is deployed as a cluster with consistent hashing to distribute keys across nodes. Adding a node requires only ~1/N keys to be remapped. Replication (primary + replica per shard) provides fault tolerance.</p>

<h4>CDN Scaling</h4>
<p>CDNs inherently scale globally with edge PoPs (Points of Presence). No custom scaling needed â€” the CDN provider handles edge node capacity.</p>

<h4>Message Queue Scaling</h4>
<p>Queues are partitioned across multiple brokers. As throughput grows, add more partitions and consumer instances. Consumer group membership automatically rebalances partitions.</p>

<h4>Estimated Traffic &amp; Capacity</h4>
<table>
  <tr><th>Metric</th><th>Estimate</th></tr>
  <tr><td>Monthly Active Users</td><td>50 million</td></tr>
  <tr><td>Daily Company Profile Views</td><td>20 million</td></tr>
  <tr><td>Daily Job Searches</td><td>10 million</td></tr>
  <tr><td>Daily New Reviews</td><td>50,000</td></tr>
  <tr><td>Daily New Salary Submissions</td><td>30,000</td></tr>
  <tr><td>Daily Job Applications</td><td>200,000</td></tr>
  <tr><td>Total Reviews in DB</td><td>100 million+</td></tr>
  <tr><td>Total Jobs (active)</td><td>2 million</td></tr>
  <tr><td>Peak QPS (reads)</td><td>~5,000/s</td></tr>
  <tr><td>Peak QPS (writes)</td><td>~50/s</td></tr>
</table>
</div>

<hr class="section-divider">

<!-- ============================================================ -->
<h2>13. Tradeoffs &amp; Deep Dives</h2>
<!-- ============================================================ -->
<div class="card">

<h4>Tradeoff 1: Eventual Consistency for Aggregated Ratings</h4>
<p><strong>Decision:</strong> Aggregate ratings (avg_overall_rating, total_review_count) are updated asynchronously via the Aggregation Worker, meaning they may lag seconds to minutes behind the latest approved review.</p>
<p><strong>Tradeoff:</strong> Consistency vs. Performance/Availability. We chose availability and performance. Computing aggregates synchronously on every review submission would block the user's request and create a write bottleneck on the Companies table. With 100M+ reviews, computing AVG() in real-time on every profile view is prohibitively expensive.</p>
<p><strong>Mitigation:</strong> The 10-minute cache TTL ensures stale aggregates self-correct. For the rare case where a user submits a review and immediately checks the company page, the difference of one review out of thousands is imperceptible.</p>

<h4>Tradeoff 2: Denormalization of Aggregate Fields</h4>
<p><strong>Decision:</strong> Store computed aggregates directly on the Companies SQL row rather than computing them from the Reviews NoSQL table at read time.</p>
<p><strong>Tradeoff:</strong> Data redundancy and write complexity vs. read performance. The ~100:1 read-to-write ratio makes this overwhelmingly worthwhile. The Aggregation Worker adds write-time complexity, but the alternative (scanning millions of reviews per profile view) is untenable at scale.</p>

<h4>Tradeoff 3: NoSQL for Reviews vs. SQL</h4>
<p><strong>Decision:</strong> Store reviews in NoSQL rather than SQL.</p>
<p><strong>Tradeoff:</strong> We lose JOIN capabilities and ACID transactions for reviews, but gain horizontal scalability, flexible schema, and efficient partition-key-based access. Since reviews are self-contained documents queried primarily by company_id and never joined with other tables in user-facing queries, the loss of relational features is acceptable. The Aggregation Worker handles cross-table coordination (reviews â†’ companies) asynchronously.</p>

<h4>Tradeoff 4: Asynchronous Moderation vs. Synchronous</h4>
<p><strong>Decision:</strong> Reviews are saved immediately as "pending" and moderated asynchronously.</p>
<p><strong>Tradeoff:</strong> User experience vs. content quality. Async moderation means users get immediate acknowledgment ("Your review is under moderation"), but reviews are not instantly visible. Synchronous moderation would block the user's request for seconds (NLP processing) and create availability concerns if the moderation service is slow/down. We chose async for better UX and fault isolation.</p>

<h4>Tradeoff 5: Anonymous Hash vs. Encrypted User ID</h4>
<p><strong>Decision:</strong> Store a one-way SHA-256 hash of (user_id + company_id + salt) instead of an encrypted user_id.</p>
<p><strong>Tradeoff:</strong> Irreversibility vs. recoverability. A one-way hash means even if the database is breached AND the salt is compromised, brute-forcing the hash to recover user_id requires trying all possible user IDs. An encrypted user_id (reversible with a key) would allow de-anonymization if the encryption key is compromised. We prioritize anonymity, accepting that we cannot recover the original user_id from a review (which is the point).</p>

<h4>Deep Dive: Search Ranking</h4>
<p>Job search results are ranked using a composite score:</p>
<ul>
  <li><strong>Relevance (40%):</strong> BM25 text similarity between query and job title/description.</li>
  <li><strong>Recency (25%):</strong> Exponential decay function based on <code>posted_at</code>. Newer jobs score higher.</li>
  <li><strong>Company quality (15%):</strong> Company's avg_overall_rating normalized to [0,1].</li>
  <li><strong>Salary match (10%):</strong> How well the job's salary range matches the user's filter or profile preferences.</li>
  <li><strong>Engagement (10%):</strong> Number of applications and views (popularity signal).</li>
</ul>

<h4>Deep Dive: Anonymity Architecture</h4>
<p>The anonymous_author_hash serves dual purposes:</p>
<ol>
  <li><strong>Duplicate prevention:</strong> <code>hash(user_id + company_id + entity_type + salt)</code> is unique per user-company-entity combination. The entity_type (review, salary, interview) is included so a user can submit one of each per company.</li>
  <li><strong>Anonymity:</strong> The hash is irreversible. The salt is stored in a hardware security module (HSM), not in the application database. Even with database access, an attacker cannot determine which user wrote which review.</li>
  <li><strong>Legal compliance:</strong> If a user invokes GDPR right-to-deletion, the system can recompute all hashes for that user_id and delete/anonymize the corresponding reviews. The salt enables this without storing user_id in the review.</li>
</ol>
</div>

<hr class="section-divider">

<!-- ============================================================ -->
<h2>14. Alternative Approaches</h2>
<!-- ============================================================ -->
<div class="card">

<h4>Alternative 1: Monolithic Architecture</h4>
<p><strong>Approach:</strong> A single application handling reviews, jobs, salaries, search, and applications.</p>
<p><strong>Why not chosen:</strong> Glassdoor's features have vastly different scaling profiles. Reviews are write-heavy during moderation but read-heavy for browsing. Job search is compute-intensive (search index queries). Applications require transactional guarantees. A monolith forces scaling the entire application even when only one feature is bottlenecked. Microservices allow independent scaling, deployment, and technology choices per service.</p>

<h4>Alternative 2: Synchronous Moderation (Block Until Moderated)</h4>
<p><strong>Approach:</strong> The review submission API call blocks until moderation is complete, then returns approved/rejected immediately.</p>
<p><strong>Why not chosen:</strong> NLP-based moderation takes 2-10 seconds. Blocking the user's request for this long degrades UX. If the moderation service is slow or down, the review submission fails entirely â€” poor fault isolation. Async moderation decouples the user experience from the moderation pipeline.</p>

<h4>Alternative 3: Computing Aggregates On-the-Fly</h4>
<p><strong>Approach:</strong> Instead of denormalized aggregate fields on the Companies table, compute AVG(rating) by querying all reviews for a company at read time.</p>
<p><strong>Why not chosen:</strong> A company like Google might have 500,000+ reviews. Running <code>AVG(overall_rating) WHERE company_id = 'google' AND status = 'approved'</code> on every profile view (thousands of times per second) is prohibitively expensive even with a NoSQL partition scan. Denormalized aggregates make this a single-row read from SQL (or cache hit), reducing latency by 100x.</p>

<h4>Alternative 4: Graph Database for Company-User Relationships</h4>
<p><strong>Approach:</strong> Model users, companies, reviews, and applications as nodes/edges in a graph database to enable queries like "friends who reviewed this company" or "recommended companies based on your network."</p>
<p><strong>Why not chosen:</strong> Glassdoor's primary access patterns are simple (get reviews for company, search jobs by keyword). Graph traversals are overkill for these use cases and add operational complexity. If social features (see friends' reviews) become a priority, a graph database could be introduced as an auxiliary store, but it shouldn't be the primary data layer.</p>

<h4>Alternative 5: Event Sourcing for Reviews</h4>
<p><strong>Approach:</strong> Store every action on a review (created, moderated, edited, marked helpful) as an immutable event in an event log. Reconstruct the current state by replaying events.</p>
<p><strong>Why not chosen:</strong> Reviews are predominantly write-once (created, then moderated once, then rarely changed). The event sourcing complexity (event store, projections, replay logic, eventual consistency of projections) is not justified for an entity with such a simple lifecycle. A straightforward CRUD model with status flags (pending â†’ approved/rejected) is simpler and sufficient.</p>

<h4>Alternative 6: WebSockets for Real-Time Moderation Status</h4>
<p><strong>Approach:</strong> After submitting a review, keep a WebSocket connection open so the user sees real-time moderation progress ("Checking content... Approved!").</p>
<p><strong>Why not chosen:</strong> Maintaining millions of WebSocket connections is expensive (memory, connection management, reconnection logic). The benefit is marginal â€” users submit a review and typically leave the page. An email/push notification when moderation completes (5 minutes later) is a better UX pattern for this use case.</p>

<h4>Alternative 7: SQL for All Data (Including Reviews &amp; Salaries)</h4>
<p><strong>Approach:</strong> Use a single SQL database for everything.</p>
<p><strong>Why not chosen:</strong> SQL databases scale vertically (bigger machines) and horizontally through read replicas, but write scaling for 100M+ reviews with partition-key-based access patterns is more naturally served by NoSQL. SQL sharding is complex and loses many relational benefits (cross-shard joins, foreign keys). NoSQL's native partitioning by company_id perfectly matches the access pattern "get all reviews for company X." The structured data (users, companies, jobs, applications) remains in SQL where relational integrity matters.</p>
</div>

<hr class="section-divider">

<!-- ============================================================ -->
<h2>15. Additional Considerations</h2>
<!-- ============================================================ -->
<div class="card">

<h4>Rate Limiting &amp; Abuse Prevention</h4>
<ul>
  <li>Review submission: 1 review per company per user (enforced by anonymous_hash). Rate limit: 5 reviews per user per day globally.</li>
  <li>Salary submission: 1 salary entry per company per user per year.</li>
  <li>Job applications: 50 per user per day.</li>
  <li>Search queries: 100 per minute per IP (unauthenticated), 300 per minute (authenticated).</li>
  <li>Implemented at the API Gateway level using token bucket algorithm.</li>
</ul>

<h4>SEO &amp; Server-Side Rendering</h4>
<p>Company profile pages and job listings are critical for organic search traffic. These pages are server-side rendered (or pre-rendered and cached) so that search engine crawlers receive fully formed HTML. The CDN caches these pre-rendered pages with a 10-minute TTL using <code>stale-while-revalidate</code>.</p>

<h4>Data Privacy &amp; GDPR Compliance</h4>
<ul>
  <li><strong>Right to Deletion:</strong> When a user requests account deletion, all their reviews are either fully deleted or permanently anonymized (remove even the anonymous_hash). Salary and interview data can be retained in anonymized form (since it was never linked to a real name).</li>
  <li><strong>Data Export:</strong> Users can request an export of all their data (reviews, applications, salary submissions).</li>
  <li><strong>Consent:</strong> Users explicitly consent to data collection and processing during registration.</li>
</ul>

<h4>Employer Verification</h4>
<p>Employers claiming a company page must verify their affiliation (e.g., via corporate email domain verification or manual review). This prevents unauthorized parties from responding to reviews or posting jobs under a company's name.</p>

<h4>Review Gating / Reciprocity</h4>
<p>Glassdoor's "give to get" model requires users to submit a review, salary, or interview experience before they can access unlimited content. This incentivizes contributions and is enforced at the API Gateway level â€” unauthenticated or non-contributing users see limited data (e.g., only 1 review preview per company).</p>

<h4>Monitoring &amp; Observability</h4>
<ul>
  <li><strong>Metrics:</strong> Request latency (p50, p95, p99), error rates, queue depth, cache hit ratio, moderation approval rate.</li>
  <li><strong>Alerting:</strong> Alert on cache hit ratio drop (indicates cache failure), queue depth growth (indicates consumer lag), moderation latency exceeding SLA.</li>
  <li><strong>Distributed Tracing:</strong> Trace a review submission through Review Service â†’ Queue â†’ Moderation â†’ Queue â†’ Aggregation for debugging.</li>
</ul>

<h4>Disaster Recovery</h4>
<ul>
  <li>SQL databases: Regular automated backups + point-in-time recovery. Cross-region replication for disaster recovery.</li>
  <li>NoSQL databases: Built-in replication across availability zones. Backup to Object Storage.</li>
  <li>Message queues: Durable (persisted to disk), replicated across brokers.</li>
  <li>Object Storage: Inherently durable (designed for 99.999999999% durability).</li>
</ul>

<h4>Content Quality Signals</h4>
<p>Beyond automated moderation, Glassdoor employs crowd-sourced quality signals:</p>
<ul>
  <li><strong>"Helpful" votes:</strong> Users mark reviews as helpful. High-helpful reviews are ranked higher.</li>
  <li><strong>Employer responses:</strong> Companies can respond to reviews, which adds context and increases trust.</li>
  <li><strong>Recency weighting:</strong> More recent reviews are weighted more heavily in aggregate ratings (a company's culture today may differ from 5 years ago).</li>
</ul>
</div>

<hr class="section-divider">

<!-- ============================================================ -->
<h2>16. Vendor Recommendations</h2>
<!-- ============================================================ -->
<div class="card">
<p>While the design is vendor-agnostic, the following vendors would be strong fits for each component:</p>

<table>
  <tr><th>Component</th><th>Vendor Options</th><th>Rationale</th></tr>
  <tr>
    <td>SQL Database</td>
    <td>PostgreSQL, MySQL, Amazon Aurora, CockroachDB</td>
    <td><strong>PostgreSQL</strong> is the strongest default choice â€” excellent full-text search support (GIN indexes), JSONB for semi-structured fields, mature partitioning, and strong community. <strong>CockroachDB</strong> if global distribution and automatic sharding are priorities.</td>
  </tr>
  <tr>
    <td>NoSQL Database</td>
    <td>DynamoDB, Cassandra, ScyllaDB</td>
    <td><strong>DynamoDB</strong> if on AWS â€” fully managed, native partition/sort key model matches our schema exactly, built-in GSIs, auto-scaling. <strong>Cassandra/ScyllaDB</strong> for multi-cloud or self-hosted â€” excellent write throughput and partition-key access patterns.</td>
  </tr>
  <tr>
    <td>In-Memory Cache</td>
    <td>Redis, Memcached, KeyDB</td>
    <td><strong>Redis</strong> is the most versatile â€” supports strings, hashes, sorted sets (useful for leaderboards/rankings), TTL, pub/sub, and clustering. Memcached is simpler but lacks Redis's data structure support.</td>
  </tr>
  <tr>
    <td>Message Queue</td>
    <td>Amazon SQS, RabbitMQ, Apache Kafka</td>
    <td><strong>SQS</strong> for simplicity and managed operations. <strong>RabbitMQ</strong> for rich routing and protocol support. <strong>Kafka</strong> if event streaming / replay capability is desired (over-provisioned for simple task queues but future-proof).</td>
  </tr>
  <tr>
    <td>Search Index</td>
    <td>Elasticsearch, OpenSearch, Apache Solr, Typesense</td>
    <td><strong>Elasticsearch/OpenSearch</strong> â€” industry standard for full-text search with faceted filtering, BM25 ranking, and horizontal scaling. <strong>Typesense</strong> for a simpler, faster alternative if scale is moderate.</td>
  </tr>
  <tr>
    <td>Object Storage</td>
    <td>Amazon S3, Google Cloud Storage, Azure Blob Storage, MinIO</td>
    <td><strong>S3</strong> is the de facto standard â€” 11 9's durability, lifecycle policies, pre-signed URLs for secure access. <strong>MinIO</strong> for self-hosted / multi-cloud with S3-compatible API.</td>
  </tr>
  <tr>
    <td>CDN</td>
    <td>CloudFront, Cloudflare, Fastly, Akamai</td>
    <td><strong>Cloudflare</strong> â€” excellent performance, DDoS protection, edge compute (Workers), generous free tier. <strong>Fastly</strong> for instant cache purges and Varnish-based configurability.</td>
  </tr>
  <tr>
    <td>Container Orchestration</td>
    <td>Kubernetes (EKS, GKE, AKS), AWS ECS</td>
    <td><strong>Kubernetes</strong> â€” industry standard for microservice orchestration, auto-scaling, service discovery, and rolling deployments. All major clouds offer managed Kubernetes.</td>
  </tr>
  <tr>
    <td>NLP / Content Moderation</td>
    <td>Perspective API (Google), Amazon Comprehend, custom models</td>
    <td><strong>Perspective API</strong> for toxicity scoring with low integration effort. Supplement with custom models for PII detection and domain-specific rules.</td>
  </tr>
</table>
</div>

<script>
  mermaid.initialize({ 
    startOnLoad: true, 
    theme: 'default',
    flowchart: { 
      useMaxWidth: true,
      htmlLabels: true,
      curve: 'basis'
    }
  });
</script>

</body>
</html>
