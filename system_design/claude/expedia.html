<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>System Design: Expedia</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <script>mermaid.initialize({startOnLoad:true, theme:'neutral', flowchart:{useMaxWidth:true, htmlLabels:true, curve:'basis'}});</script>
    <style>
        :root { --primary: #1a365d; --accent: #2b6cb0; --bg: #f7fafc; --card: #fff; --border: #e2e8f0; --text: #2d3748; --muted: #718096; }
        * { margin:0; padding:0; box-sizing:border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; color:var(--text); background:var(--bg); line-height:1.7; }
        .container { max-width:1100px; margin:0 auto; padding:2rem; }
        h1 { font-size:2.5rem; color:var(--primary); border-bottom:4px solid var(--accent); padding-bottom:0.5rem; margin-bottom:1.5rem; }
        h2 { font-size:1.8rem; color:var(--primary); margin-top:3rem; margin-bottom:1rem; border-left:4px solid var(--accent); padding-left:0.75rem; }
        h3 { font-size:1.35rem; color:var(--accent); margin-top:2rem; margin-bottom:0.75rem; }
        h4 { font-size:1.1rem; color:var(--primary); margin-top:1.5rem; margin-bottom:0.5rem; }
        p { margin-bottom:1rem; }
        ul, ol { margin-left:1.5rem; margin-bottom:1rem; }
        li { margin-bottom:0.4rem; }
        .card { background:var(--card); border:1px solid var(--border); border-radius:8px; padding:1.5rem; margin-bottom:1.5rem; box-shadow:0 1px 3px rgba(0,0,0,0.06); }
        .example { background:#ebf8ff; border-left:4px solid var(--accent); padding:1rem 1.25rem; margin:1rem 0; border-radius:0 6px 6px 0; }
        .example strong { color:var(--accent); }
        .warn { background:#fffbeb; border-left:4px solid #d69e2e; padding:1rem 1.25rem; margin:1rem 0; border-radius:0 6px 6px 0; }
        .info { background:#f0fff4; border-left:4px solid #38a169; padding:1rem 1.25rem; margin:1rem 0; border-radius:0 6px 6px 0; }
        table { width:100%; border-collapse:collapse; margin:1rem 0 1.5rem; font-size:0.95rem; }
        th { background:var(--primary); color:#fff; padding:0.6rem 0.8rem; text-align:left; }
        td { padding:0.55rem 0.8rem; border-bottom:1px solid var(--border); }
        tr:nth-child(even) { background:#f1f5f9; }
        code { background:#edf2f7; padding:0.15rem 0.4rem; border-radius:4px; font-size:0.9em; }
        pre { background:#1a202c; color:#e2e8f0; padding:1rem; border-radius:8px; overflow-x:auto; margin:1rem 0; font-size:0.9rem; line-height:1.5; }
        .mermaid { background:#fff; padding:1.5rem; border-radius:8px; border:1px solid var(--border); margin:1.5rem 0; text-align:center; }
        .toc { background:var(--card); border:1px solid var(--border); border-radius:8px; padding:1.5rem 2rem; margin-bottom:2rem; }
        .toc a { color:var(--accent); text-decoration:none; }
        .toc a:hover { text-decoration:underline; }
        .toc ol { margin-left:1.25rem; }
        .toc li { margin-bottom:0.3rem; }
        .tag { display:inline-block; background:var(--accent); color:#fff; padding:0.1rem 0.5rem; border-radius:4px; font-size:0.8rem; margin-right:0.3rem; }
        .tag.get { background:#38a169; }
        .tag.post { background:#d69e2e; }
        .tag.patch { background:#805ad5; }
        .tag.put { background:#dd6b20; }
        .tag.delete { background:#e53e3e; }
    </style>
</head>
<body>
<div class="container">

<h1>üè® System Design: Expedia (Travel Booking Platform)</h1>
<p><em>A comprehensive system design for a travel aggregation and booking platform supporting hotels, flights, and car rentals.</em></p>

<!-- TABLE OF CONTENTS -->
<div class="toc">
    <h3 style="margin-top:0;">Table of Contents</h3>
    <ol>
        <li><a href="#fr">Functional Requirements</a></li>
        <li><a href="#nfr">Non-Functional Requirements</a></li>
        <li><a href="#flow1">Flow 1: Search Flow</a></li>
        <li><a href="#flow2">Flow 2: Booking &amp; Payment Flow</a></li>
        <li><a href="#flow3">Flow 3: Notification Flow</a></li>
        <li><a href="#flow4">Flow 4: Cancellation Flow</a></li>
        <li><a href="#overall">Overall Combined Diagram</a></li>
        <li><a href="#schema">Database Schema</a></li>
        <li><a href="#cdn">CDN Deep Dive</a></li>
        <li><a href="#cache">Cache Deep Dive</a></li>
        <li><a href="#mq">Message Queue Deep Dive</a></li>
        <li><a href="#scaling">Scaling Considerations &amp; Load Balancers</a></li>
        <li><a href="#tradeoffs">Tradeoffs &amp; Deep Dives</a></li>
        <li><a href="#alternatives">Alternative Approaches</a></li>
        <li><a href="#additional">Additional Considerations</a></li>
        <li><a href="#vendors">Vendor Section</a></li>
    </ol>
</div>

<!-- ================================================================== -->
<h2 id="fr">1. Functional Requirements</h2>
<!-- ================================================================== -->
<div class="card">
<ol>
    <li><strong>Search</strong> ‚Äî Users can search for hotels, flights, and car rentals by destination, dates, guest/passenger count, and filters (price range, star rating, airline, amenities, etc.).</li>
    <li><strong>View Listing Details</strong> ‚Äî Users can view detailed information about a hotel, flight, or car rental including photos, descriptions, amenities, reviews, and pricing.</li>
    <li><strong>Book</strong> ‚Äî Users can book one or more travel products (hotel room, flight seat, car rental) in a single transaction.</li>
    <li><strong>Package Booking</strong> ‚Äî Users can book bundled packages (e.g., flight + hotel) at a discounted price.</li>
    <li><strong>Payment</strong> ‚Äî Users can pay for bookings using credit/debit cards or other payment methods.</li>
    <li><strong>Booking Management</strong> ‚Äî Users can view their booking history, check booking status, and retrieve itineraries.</li>
    <li><strong>Cancellation &amp; Modification</strong> ‚Äî Users can cancel or modify existing bookings subject to cancellation policies.</li>
    <li><strong>Refunds</strong> ‚Äî Cancelled bookings are refunded per the cancellation policy (full, partial, or none).</li>
    <li><strong>Reviews &amp; Ratings</strong> ‚Äî Users can leave reviews and ratings for hotels, flights, and car rentals after their trip.</li>
    <li><strong>Notifications</strong> ‚Äî Users receive booking confirmations, cancellation confirmations, itinerary updates, and price alerts via email, push notification, or SMS.</li>
    <li><strong>User Accounts</strong> ‚Äî Users can register, log in, and manage their profiles and saved payment methods.</li>
</ol>
</div>

<!-- ================================================================== -->
<h2 id="nfr">2. Non-Functional Requirements</h2>
<!-- ================================================================== -->
<div class="card">
<table>
    <tr><th>Requirement</th><th>Target</th><th>Rationale</th></tr>
    <tr><td><strong>Low Latency (Search)</strong></td><td>&lt; 500ms p99 for search results</td><td>Users expect near-instant search results; slow search kills conversion.</td></tr>
    <tr><td><strong>High Availability</strong></td><td>99.99% uptime</td><td>Travel bookings happen 24/7 globally; downtime means lost revenue.</td></tr>
    <tr><td><strong>Strong Consistency (Bookings)</strong></td><td>Linearizable for inventory/payments</td><td>Double-booking a hotel room or flight seat is unacceptable.</td></tr>
    <tr><td><strong>Eventual Consistency (Search)</strong></td><td>Seconds of staleness tolerable</td><td>Search results can be slightly stale; availability is confirmed at booking time.</td></tr>
    <tr><td><strong>Scalability</strong></td><td>10M+ daily searches, 100K+ daily bookings</td><td>Must handle seasonal spikes (holidays, summer travel).</td></tr>
    <tr><td><strong>Fault Tolerance</strong></td><td>Graceful degradation</td><td>If one supplier is down, other results should still appear.</td></tr>
    <tr><td><strong>Data Durability</strong></td><td>No booking data loss</td><td>Financial and legal obligations require durable booking records.</td></tr>
    <tr><td><strong>Security</strong></td><td>PCI-DSS compliance</td><td>Handles payment card data; must meet regulatory requirements.</td></tr>
    <tr><td><strong>Global Reach</strong></td><td>Multi-region deployment</td><td>Users book travel from every country; need low latency globally.</td></tr>
</table>
</div>

<!-- ================================================================== -->
<h2 id="flow1">3. Flow 1: Search Flow</h2>
<!-- ================================================================== -->

<h3>3.1 Diagram</h3>
<div class="mermaid">
graph LR
    subgraph Client
        A[User / Browser / Mobile App]
    end
    subgraph Edge
        CDN[(CDN<br/>Static Assets & Images)]
        LB1[Load Balancer]
    end
    subgraph Backend
        AG[API Gateway]
        SS[Search Service]
        C[(Cache<br/>Search Results)]
        SI[(Search Index)]
        SIS[Supplier Integration<br/>Service]
        LS[Listing Service]
    end
    subgraph Data
        InvDB[(Inventory DB<br/>NoSQL Document Store)]
        AvDB[(Availability DB<br/>SQL)]
        OS[(Object Storage<br/>Images)]
    end
    subgraph External
        EXT1[Airline GDS APIs]
        EXT2[Hotel Supplier APIs]
        EXT3[Car Rental Supplier APIs]
    end

    A -- "HTTPS GET /search" --> LB1
    LB1 --> AG
    AG --> SS
    SS -- "1. Check cache" --> C
    SS -- "2. Query index<br/>(on cache miss)" --> SI
    SI -- "Read listings" --> InvDB
    SS -- "3. Real-time fares<br/>(flights)" --> SIS
    SIS --> EXT1
    SIS --> EXT2
    SIS --> EXT3
    SS -- "4. Enrich listing<br/>details" --> LS
    LS --> InvDB
    A -- "Load images" --> CDN
    CDN -- "Origin pull" --> OS
</div>

<h3>3.2 Examples</h3>

<div class="example">
<strong>Example 1 ‚Äî Hotel Search (Cache Hit):</strong> User types "New York, March 10‚Äì15, 2 guests" and clicks Search. The browser sends an <code>HTTPS GET /api/v1/search/hotels?city=new_york&check_in=2026-03-10&check_out=2026-03-15&guests=2</code> request through the Load Balancer to the API Gateway, which routes it to the Search Service. The Search Service hashes the query parameters and finds a matching entry in the Cache (populated by a previous identical search 2 minutes ago). The cached results ‚Äî a list of 50 hotel cards with name, thumbnail URL, star rating, price ‚Äî are returned to the client in ~80ms. Hotel thumbnail images are loaded by the browser from the CDN.
</div>

<div class="example">
<strong>Example 2 ‚Äî Hotel Search (Cache Miss):</strong> User searches "Tokyo, April 1‚Äì5, 1 guest." The Search Service finds no cached result. It queries the Search Index with the city, dates, and guest count. The Search Index returns matching hotel listing IDs ranked by relevance. The Search Service fetches enriched listing details (name, images, rating, base price) from the Listing Service and checks the Availability DB for room availability in that date range. Results are assembled, cached with a 5-minute TTL, and returned to the client in ~350ms.
</div>

<div class="example">
<strong>Example 3 ‚Äî Flight Search (Supplier Integration):</strong> User searches "SFO ‚Üí LHR, June 1, 1 passenger." The Search Service checks the cache and finds no result. It queries the Search Index for known flight routes, and <em>simultaneously</em> calls the Supplier Integration Service, which fans out HTTPS requests to multiple airline GDS APIs in parallel. The Supplier Integration Service aggregates responses, normalizes data formats, deduplicates overlapping routes, and returns a unified list. Results are ranked by price, cached, and returned in ~450ms.
</div>

<div class="example">
<strong>Example 4 ‚Äî Filtered Search:</strong> User searches hotels in Paris and then applies filters: "4+ stars, pool, under $200/night." The browser sends a new GET request with additional query parameters. The Search Service queries the Search Index with the composite filter (inverted index on amenities, B-tree range scan on price, filter on star_rating). A new, smaller result set is returned and cached separately.
</div>

<h3>3.3 Component Deep Dive</h3>

<h4>Load Balancer</h4>
<div class="card">
<p>Sits between clients and the API Gateway. Distributes incoming HTTPS requests across multiple API Gateway instances using a <strong>round-robin</strong> or <strong>least-connections</strong> strategy. Terminates TLS at this layer for efficiency. Performs health checks every 5 seconds and removes unhealthy instances from the rotation. For global traffic, a DNS-based global load balancer directs users to the nearest regional cluster.</p>
</div>

<h4>API Gateway</h4>
<div class="card">
<p>Single entry point for all client requests. Responsibilities include:</p>
<ul>
    <li><strong>Authentication &amp; Authorization</strong> ‚Äî Validates JWT tokens, checks permissions.</li>
    <li><strong>Rate Limiting</strong> ‚Äî Prevents abuse (e.g., 100 searches/min per user).</li>
    <li><strong>Request Routing</strong> ‚Äî Routes to the appropriate microservice based on URL path.</li>
    <li><strong>Protocol Translation</strong> ‚Äî Accepts HTTPS from clients, forwards as HTTP internally.</li>
    <li><strong>Request/Response Transformation</strong> ‚Äî Adds correlation IDs, strips internal headers.</li>
</ul>
<p><span class="tag">Protocol:</span> HTTPS (external), HTTP (internal)</p>
</div>

<h4>Search Service</h4>
<div class="card">
<p>Handles all search queries for hotels, flights, and car rentals. Stateless; horizontally scalable.</p>
<p><span class="tag get">GET</span> <code>/api/v1/search/hotels</code></p>
<ul>
    <li><strong>Input:</strong> <code>city</code>, <code>check_in</code>, <code>check_out</code>, <code>guests</code>, <code>min_price</code>, <code>max_price</code>, <code>star_rating</code>, <code>amenities[]</code>, <code>sort_by</code>, <code>page</code>, <code>page_size</code></li>
    <li><strong>Output:</strong> <code>{ results: [{ listing_id, name, thumbnail_url, star_rating, avg_review, price_per_night, location }], total_count, page, page_size }</code></li>
</ul>
<p><span class="tag get">GET</span> <code>/api/v1/search/flights</code></p>
<ul>
    <li><strong>Input:</strong> <code>departure_airport</code>, <code>arrival_airport</code>, <code>departure_date</code>, <code>return_date</code> (optional), <code>passengers</code>, <code>seat_class</code>, <code>max_stops</code>, <code>sort_by</code>, <code>page</code></li>
    <li><strong>Output:</strong> <code>{ results: [{ flight_id, airline, flight_number, departure_time, arrival_time, duration, stops, price, seat_class }], total_count }</code></li>
</ul>
<p><span class="tag get">GET</span> <code>/api/v1/search/cars</code></p>
<ul>
    <li><strong>Input:</strong> <code>pickup_location</code>, <code>pickup_date</code>, <code>dropoff_date</code>, <code>car_type</code>, <code>sort_by</code>, <code>page</code></li>
    <li><strong>Output:</strong> <code>{ results: [{ rental_id, company, car_type, car_model, daily_price, features[], image_url }], total_count }</code></li>
</ul>
<p><strong>Protocol:</strong> HTTP (internal from API Gateway). Uses TCP to connect to the Cache and Search Index.</p>
</div>

<h4>Cache (Search Results)</h4>
<div class="card">
<p>In-memory key-value cache storing recent search results. See the <a href="#cache">Cache Deep Dive</a> section for full details on strategy, eviction, and expiration.</p>
</div>

<h4>Search Index</h4>
<div class="card">
<p>A dedicated full-text and structured search index (separate from the primary databases) that enables fast, complex queries with filtering, sorting, and geo-spatial search. Data is synced from the Inventory DB via a change-data-capture (CDC) pipeline. See the <a href="#schema">Schema section</a> for index details.</p>
</div>

<h4>Supplier Integration Service</h4>
<div class="card">
<p>Adapter layer that connects to external supplier APIs (airline GDS systems, hotel chains, car rental companies). Each supplier has its own data format, so this service normalizes responses into a canonical schema. Uses the <strong>Adapter Pattern</strong>: each supplier gets a dedicated adapter class. Calls suppliers in parallel with a <strong>timeout of 3 seconds</strong> per supplier; if a supplier is slow, the result is excluded rather than blocking the entire search. Implements <strong>circuit breakers</strong> per supplier to avoid cascading failures.</p>
<p><strong>Protocol:</strong> HTTPS to external suppliers. HTTP internally.</p>
</div>

<h4>Listing Service</h4>
<div class="card">
<p>Serves detailed listing information (descriptions, photos, amenities, reviews summary) from the Inventory DB. Used to enrich search results and serve listing detail pages.</p>
<p><span class="tag get">GET</span> <code>/api/v1/hotels/{listing_id}</code></p>
<ul>
    <li><strong>Input:</strong> <code>listing_id</code> (path parameter)</li>
    <li><strong>Output:</strong> Full hotel document: <code>{ listing_id, name, description, address, city, country, lat, lng, star_rating, amenities[], images[], room_types[], avg_rating, review_count, supplier_id }</code></li>
</ul>
<p><span class="tag get">GET</span> <code>/api/v1/flights/{flight_id}</code> ‚Äî Similar pattern for flights.</p>
<p><span class="tag get">GET</span> <code>/api/v1/cars/{rental_id}</code> ‚Äî Similar pattern for car rentals.</p>
<p><strong>Protocol:</strong> HTTP internally.</p>
</div>

<h4>CDN &amp; Object Storage</h4>
<div class="card">
<p>Object Storage holds all hotel photos, car images, and static assets (JS, CSS, fonts). The CDN is a pull-based CDN that caches content at edge locations globally. When a user's browser requests an image URL, the nearest CDN edge serves it; on a cache miss, the CDN pulls from Object Storage. See the <a href="#cdn">CDN Deep Dive</a> for details.</p>
</div>

<!-- ================================================================== -->
<h2 id="flow2">4. Flow 2: Booking &amp; Payment Flow</h2>
<!-- ================================================================== -->

<h3>4.1 Diagram</h3>
<div class="mermaid">
graph TD
    subgraph Client
        A[User / Browser / Mobile App]
    end
    subgraph Edge
        LB1[Load Balancer]
    end
    subgraph Backend
        AG[API Gateway]
        BS[Booking Service]
        IS[Inventory Service]
        PS[Payment Service]
        MQ[(Message Queue)]
    end
    subgraph Data
        BookDB[(Booking DB<br/>SQL)]
        AvDB[(Availability DB<br/>SQL)]
    end
    subgraph External
        EPP[External Payment<br/>Processor]
        SUP[Supplier Confirmation<br/>APIs]
    end

    A -- "HTTPS POST /bookings" --> LB1
    LB1 --> AG
    AG --> BS
    BS -- "1. Check real-time<br/>availability" --> IS
    IS -- "SELECT ... FOR UPDATE" --> AvDB
    IS -- "2. Place temporary<br/>hold (lock row)" --> AvDB
    BS -- "3. Create pending<br/>booking" --> BookDB
    BS -- "4. Process payment" --> PS
    PS -- "HTTPS POST<br/>charge" --> EPP
    EPP -- "Payment result" --> PS
    PS -- "5. Record payment" --> BookDB
    BS -- "6. Confirm booking<br/>& update status" --> BookDB
    IS -- "7. Finalize<br/>inventory deduction" --> AvDB
    BS -- "8. Confirm with<br/>supplier" --> SUP
    BS -- "9. Publish<br/>booking_confirmed event" --> MQ
    BS -- "10. Return confirmation" --> A
</div>

<h3>4.2 Examples</h3>

<div class="example">
<strong>Example 1 ‚Äî Single Hotel Booking (Happy Path):</strong> User selects "Grand Tokyo Hotel, Deluxe Room, March 10‚Äì15" and clicks "Book Now." The browser sends <code>HTTPS POST /api/v1/bookings</code> with the body <code>{ listing_id: "htl_123", listing_type: "hotel", room_type: "deluxe", check_in: "2026-03-10", check_out: "2026-03-15", guests: 2, payment_method_id: "pm_456" }</code>. The Booking Service calls the Inventory Service, which executes a <code>SELECT ... FOR UPDATE</code> on the Availability DB to lock the row for the Deluxe Room on March 10‚Äì15. It confirms availability (available_rooms > 0 for each night) and decrements <code>available_rooms</code> by 1 for each date, setting an <code>expires_at</code> lock of 10 minutes. A pending booking is created in the Booking DB. The Payment Service charges $1,200 via the External Payment Processor. On success, the booking status is updated to <code>confirmed</code>, the inventory hold is finalized (lock removed, deduction permanent), and a <code>booking_confirmed</code> event is published to the Message Queue. The user sees a confirmation page with booking ID <code>BK-789012</code>.
</div>

<div class="example">
<strong>Example 2 ‚Äî Booking Fails Due to Unavailability:</strong> Two users try to book the last available room at the same hotel for the same dates simultaneously. User A's request reaches the Inventory Service first and acquires the row lock via <code>SELECT ... FOR UPDATE</code>. User B's request blocks on the lock. User A's booking proceeds: the room is reserved, payment is processed, booking is confirmed. When User B's request finally acquires the lock, <code>available_rooms = 0</code>. The Inventory Service returns an <code>UNAVAILABLE</code> error. The Booking Service returns <code>HTTP 409 Conflict</code> to User B with a message: "Sorry, this room is no longer available. Please select another room or date."
</div>

<div class="example">
<strong>Example 3 ‚Äî Payment Failure with Inventory Rollback:</strong> User books a flight. The Inventory Service successfully places a hold on the seat. The Payment Service sends a charge request to the External Payment Processor, but the charge is <strong>declined</strong> (insufficient funds). The Payment Service returns a failure. The Booking Service triggers a <strong>compensating transaction</strong>: it releases the inventory hold (increments available seats back), sets the booking status to <code>payment_failed</code>, and returns <code>HTTP 402 Payment Required</code> to the user with a message: "Payment declined. Please try a different payment method."
</div>

<div class="example">
<strong>Example 4 ‚Äî Package Booking (Flight + Hotel ‚Äî Saga Pattern):</strong> User books a "NYC ‚Üí Paris flight + Hotel Le Marais" package. The Booking Service uses the <strong>Saga Pattern</strong> to coordinate:<br/>
<strong>Step 1:</strong> Book the flight seat ‚Üí Inventory Service reserves it ‚Üí success.<br/>
<strong>Step 2:</strong> Book the hotel room ‚Üí Inventory Service reserves it ‚Üí success.<br/>
<strong>Step 3:</strong> Process combined payment ‚Üí Payment Service charges $2,800 ‚Üí success.<br/>
<strong>Step 4:</strong> Confirm both bookings, publish events.<br/><br/>
<em>If Step 2 fails</em> (hotel fully booked), the Saga triggers a <strong>compensating transaction</strong> for Step 1: the flight seat reservation is released. The user is notified: "The hotel is unavailable. Your flight reservation has been released. No charge was made."
</div>

<div class="example">
<strong>Example 5 ‚Äî Temporary Hold Expiration:</strong> User initiates a booking, the inventory is held, but the user abandons the checkout page without completing payment. The temporary hold has an <code>expires_at</code> of 10 minutes. A scheduled <strong>Hold Cleanup Job</strong> runs every minute, finds expired holds, releases the inventory back, and marks the booking as <code>expired</code>. The room/seat becomes available for other users.
</div>

<h3>4.3 Component Deep Dive</h3>

<h4>Booking Service</h4>
<div class="card">
<p>Central orchestrator for all booking operations. Coordinates with the Inventory Service, Payment Service, and Supplier APIs. Implements the <strong>Saga Pattern</strong> for multi-item (package) bookings with compensating transactions for rollback. Stateless; booking state is persisted in the Booking DB.</p>
<p><span class="tag post">POST</span> <code>/api/v1/bookings</code></p>
<ul>
    <li><strong>Input:</strong> <code>{ items: [{ listing_id, listing_type, room_type/seat_class, check_in/departure, check_out/arrival, quantity }], payment_method_id, guest_details: { name, email, phone } }</code></li>
    <li><strong>Output:</strong> <code>{ booking_id, status: "confirmed", items: [...], total_price, currency, confirmation_number, created_at }</code></li>
</ul>
<p><span class="tag get">GET</span> <code>/api/v1/bookings/{booking_id}</code></p>
<ul>
    <li><strong>Input:</strong> <code>booking_id</code> (path param), <code>Authorization</code> header</li>
    <li><strong>Output:</strong> Full booking details including status, items, payment status, and cancellation policy</li>
</ul>
<p><span class="tag get">GET</span> <code>/api/v1/users/{user_id}/bookings</code></p>
<ul>
    <li><strong>Input:</strong> <code>user_id</code> (path param), <code>status</code> (query, optional), <code>page</code>, <code>page_size</code></li>
    <li><strong>Output:</strong> Paginated list of bookings for the user</li>
</ul>
<p><strong>Protocol:</strong> HTTP internally. Communicates with Inventory Service and Payment Service via synchronous HTTP calls. Publishes events to the Message Queue asynchronously via TCP.</p>
</div>

<h4>Inventory Service</h4>
<div class="card">
<p>Manages real-time availability and temporary holds for all listing types. The critical component for preventing double-booking. Uses <strong>pessimistic locking</strong> (<code>SELECT ... FOR UPDATE</code>) on the Availability DB to serialize concurrent booking attempts for the same resource.</p>
<p>Endpoints (internal, not exposed to clients):</p>
<p><span class="tag post">POST</span> <code>/internal/inventory/hold</code></p>
<ul>
    <li><strong>Input:</strong> <code>{ listing_id, listing_type, date_range, quantity }</code></li>
    <li><strong>Output:</strong> <code>{ hold_id, expires_at, status: "held" }</code> or <code>{ status: "unavailable" }</code></li>
</ul>
<p><span class="tag post">POST</span> <code>/internal/inventory/confirm</code></p>
<ul>
    <li><strong>Input:</strong> <code>{ hold_id }</code></li>
    <li><strong>Output:</strong> <code>{ status: "confirmed" }</code></li>
</ul>
<p><span class="tag post">POST</span> <code>/internal/inventory/release</code></p>
<ul>
    <li><strong>Input:</strong> <code>{ hold_id }</code></li>
    <li><strong>Output:</strong> <code>{ status: "released" }</code></li>
</ul>
<p><strong>Protocol:</strong> HTTP internally. Uses TCP to connect to the SQL Availability DB.</p>
</div>

<h4>Payment Service</h4>
<div class="card">
<p>Handles all payment processing: authorization, capture, and refunds. Does <em>not</em> store raw credit card numbers (PCI-DSS compliance); uses tokenized payment method references. Communicates with external payment processors.</p>
<p><span class="tag post">POST</span> <code>/internal/payments/charge</code></p>
<ul>
    <li><strong>Input:</strong> <code>{ booking_id, amount, currency, payment_method_id }</code></li>
    <li><strong>Output:</strong> <code>{ payment_id, status: "captured"|"declined"|"error", transaction_reference }</code></li>
</ul>
<p><span class="tag post">POST</span> <code>/internal/payments/{payment_id}/refund</code></p>
<ul>
    <li><strong>Input:</strong> <code>{ amount, reason }</code></li>
    <li><strong>Output:</strong> <code>{ refund_id, status: "refunded"|"partial_refund", refund_amount }</code></li>
</ul>
<p><strong>Protocol:</strong> HTTP internally. HTTPS to External Payment Processor.</p>
</div>

<h4>Booking DB (SQL)</h4>
<div class="card">
<p>Stores all booking records and payment records. SQL chosen for ACID compliance ‚Äî bookings are financial transactions and must be consistent and durable. See <a href="#schema">Schema</a> for full table details.</p>
</div>

<h4>Availability DB (SQL)</h4>
<div class="card">
<p>Stores real-time inventory counts (rooms available per date, seats available per flight, cars available per date/location). SQL chosen for strong consistency and row-level locking required to prevent double-booking. See <a href="#schema">Schema</a> for full table details.</p>
</div>

<!-- ================================================================== -->
<h2 id="flow3">5. Flow 3: Notification Flow</h2>
<!-- ================================================================== -->

<h3>5.1 Diagram</h3>
<div class="mermaid">
graph LR
    subgraph Async
        MQ[(Message Queue)]
    end
    subgraph Backend
        NS[Notification Service]
        NDB[(Notification DB<br/>NoSQL Document Store)]
    end
    subgraph Delivery Channels
        EM[Email Provider]
        PN[Push Notification<br/>Service]
        SM[SMS Provider]
    end
    subgraph Client Read Path
        A[User / Browser / Mobile App]
        LB1[Load Balancer]
        AG[API Gateway]
    end

    MQ -- "Consume<br/>booking events" --> NS
    NS -- "Send email" --> EM
    NS -- "Send push" --> PN
    NS -- "Send SMS" --> SM
    NS -- "Persist notification<br/>record" --> NDB
    A -- "HTTPS GET<br/>/notifications" --> LB1
    LB1 --> AG
    AG --> NS
    NS -- "Read notifications" --> NDB
</div>

<h3>5.2 Examples</h3>

<div class="example">
<strong>Example 1 ‚Äî Booking Confirmation Notification:</strong> After a booking is confirmed, the Booking Service publishes a <code>booking_confirmed</code> event to the Message Queue with payload <code>{ booking_id: "BK-789012", user_id: "u_123", type: "hotel", hotel_name: "Grand Tokyo Hotel", check_in: "2026-03-10", total: "$1200" }</code>. The Notification Service consumes this message, determines the user's notification preferences (email + push), generates an email with the itinerary (using a template engine), and sends it via the Email Provider. It also sends a push notification: "Your booking at Grand Tokyo Hotel is confirmed! Check-in: March 10." A notification record is stored in the Notification DB.
</div>

<div class="example">
<strong>Example 2 ‚Äî User Reads Notification History:</strong> User opens the app and taps the notifications bell icon. The app sends <code>HTTPS GET /api/v1/users/u_123/notifications?page=1&page_size=20</code>. The Notification Service queries the Notification DB for the user's most recent 20 notifications (sorted by <code>created_at DESC</code>). Results include booking confirmations, cancellation notices, and price alerts. Unread notifications are highlighted in the UI.
</div>

<div class="example">
<strong>Example 3 ‚Äî Cancellation Notification:</strong> After a cancellation is processed, a <code>booking_cancelled</code> event is published. The Notification Service sends an email: "Your booking BK-789012 at Grand Tokyo Hotel has been cancelled. A refund of $1,080 will be processed within 5‚Äì10 business days." A push notification and SMS are also sent per the user's preferences.
</div>

<h3>5.3 Component Deep Dive</h3>

<h4>Notification Service</h4>
<div class="card">
<p>Consumes events from the Message Queue (booking confirmed, cancelled, modified, payment failed, price alert, etc.) and routes notifications to the appropriate delivery channels based on user preferences. Also serves the notification read API for in-app notification history.</p>
<p><strong>Write Path (event-driven):</strong> Message Queue consumer ‚Üí Template rendering ‚Üí Dispatch to Email/Push/SMS providers ‚Üí Persist to Notification DB.</p>
<p><strong>Read Path (request-driven):</strong></p>
<p><span class="tag get">GET</span> <code>/api/v1/users/{user_id}/notifications</code></p>
<ul>
    <li><strong>Input:</strong> <code>user_id</code>, <code>page</code>, <code>page_size</code>, <code>unread_only</code> (optional)</li>
    <li><strong>Output:</strong> <code>{ notifications: [{ id, type, title, body, read, created_at }], total_count }</code></li>
</ul>
<p><span class="tag patch">PATCH</span> <code>/api/v1/notifications/{notification_id}/read</code></p>
<ul>
    <li><strong>Input:</strong> <code>notification_id</code> (path param)</li>
    <li><strong>Output:</strong> <code>{ status: "read" }</code></li>
</ul>
<p><strong>Protocol:</strong> TCP consumer from Message Queue. HTTP for internal/external API calls. HTTPS to external email/push/SMS providers.</p>
</div>

<h4>Notification DB (NoSQL Document Store)</h4>
<div class="card">
<p>Stores notification records. NoSQL chosen because: notifications are write-heavy, read in reverse chronological order (simple access pattern), have a flexible schema (different notification types have different metadata), and don't require joins. Eventual consistency is acceptable ‚Äî a notification appearing a few seconds late is fine.</p>
</div>

<!-- ================================================================== -->
<h2 id="flow4">6. Flow 4: Cancellation Flow</h2>
<!-- ================================================================== -->

<h3>6.1 Diagram</h3>
<div class="mermaid">
graph TD
    subgraph Client
        A[User / Browser / Mobile App]
    end
    subgraph Edge
        LB1[Load Balancer]
    end
    subgraph Backend
        AG[API Gateway]
        BS[Booking Service]
        IS[Inventory Service]
        PS[Payment Service]
        MQ[(Message Queue)]
    end
    subgraph Data
        BookDB[(Booking DB<br/>SQL)]
        AvDB[(Availability DB<br/>SQL)]
    end
    subgraph External
        EPP[External Payment<br/>Processor]
    end

    A -- "HTTPS PATCH<br/>/bookings/{id}/cancel" --> LB1
    LB1 --> AG
    AG --> BS
    BS -- "1. Retrieve booking<br/>& check policy" --> BookDB
    BS -- "2. Calculate refund<br/>amount" --> BS
    BS -- "3. Process refund" --> PS
    PS -- "HTTPS POST<br/>refund" --> EPP
    PS -- "4. Record refund" --> BookDB
    BS -- "5. Release inventory" --> IS
    IS -- "6. Increment<br/>available count" --> AvDB
    BS -- "7. Update booking<br/>status = cancelled" --> BookDB
    BS -- "8. Publish<br/>booking_cancelled event" --> MQ
    BS -- "9. Return cancellation<br/>confirmation" --> A
</div>

<h3>6.2 Examples</h3>

<div class="example">
<strong>Example 1 ‚Äî Full Refund Cancellation:</strong> User navigates to "My Bookings," selects booking BK-789012 (Grand Tokyo Hotel, March 10‚Äì15), and clicks "Cancel Booking." The app sends <code>HTTPS PATCH /api/v1/bookings/BK-789012/cancel</code>. The Booking Service retrieves the booking from the Booking DB, checks the cancellation policy: the hotel allows free cancellation up to 48 hours before check-in. Since today is March 1 (9 days before), a <strong>full refund of $1,200</strong> is issued. The Payment Service sends a refund request to the External Payment Processor. The Inventory Service releases the room (increments <code>available_rooms</code> for each date). The booking status is updated to <code>cancelled</code>. A <code>booking_cancelled</code> event is published to the Message Queue. The user sees: "Booking cancelled. Full refund of $1,200 will appear in 5‚Äì10 business days."
</div>

<div class="example">
<strong>Example 2 ‚Äî Partial Refund (Late Cancellation):</strong> User cancels the same hotel booking on March 9 (1 day before check-in, within the 48-hour penalty window). The cancellation policy dictates a <strong>one-night penalty</strong>. Refund amount = $1,200 ‚àí $240 (one night) = $960. The user sees: "Booking cancelled. A cancellation fee of $240 applies. Refund of $960 will be processed."
</div>

<div class="example">
<strong>Example 3 ‚Äî Non-Refundable Booking:</strong> User booked a non-refundable discounted fare. On cancellation attempt, the Booking Service checks the policy and determines <strong>$0 refund</strong>. Before proceeding, the API returns a confirmation prompt: "This booking is non-refundable. Are you sure you want to cancel?" If the user confirms, the booking is cancelled with no refund. Inventory is released so the seat/room can be resold.
</div>

<div class="example">
<strong>Example 4 ‚Äî Package Cancellation (Saga):</strong> User cancels a flight + hotel package. The Booking Service uses the Saga Pattern to reverse both: release the flight seat, release the hotel room, process a single combined refund. If the flight seat release fails (e.g., supplier API timeout), the system retries with exponential backoff. The hotel room is still released. The user is notified of partial cancellation progress, and a background job continues retrying the flight release.
</div>

<h3>6.3 Component Deep Dive</h3>
<div class="card">
<p>All components in this flow (Booking Service, Inventory Service, Payment Service, Booking DB, Availability DB, Message Queue) are the same as described in <a href="#flow2">Flow 2</a>. The key differences are:</p>
<ul>
    <li>The Booking Service reads cancellation policy metadata stored alongside the booking or in the listing document.</li>
    <li>The Payment Service issues a <strong>refund</strong> rather than a charge.</li>
    <li>The Inventory Service <strong>increments</strong> availability rather than decrementing it.</li>
    <li>The Message Queue event is <code>booking_cancelled</code> instead of <code>booking_confirmed</code>.</li>
</ul>
<p><span class="tag patch">PATCH</span> <code>/api/v1/bookings/{booking_id}/cancel</code></p>
<ul>
    <li><strong>Input:</strong> <code>booking_id</code> (path param), <code>{ reason }</code> (optional body)</li>
    <li><strong>Output:</strong> <code>{ booking_id, status: "cancelled", refund_amount, refund_status, cancellation_fee }</code></li>
</ul>
</div>

<!-- ================================================================== -->
<h2 id="overall">7. Overall Combined Diagram</h2>
<!-- ================================================================== -->

<div class="mermaid">
graph TD
    subgraph Client Layer
        CL[User / Browser / Mobile App]
    end

    subgraph Edge Layer
        CDN[(CDN<br/>Static Assets & Images)]
        GLB[Global Load Balancer<br/>DNS-based]
    end

    subgraph Gateway Layer
        LB1[Regional Load Balancer]
        AG[API Gateway<br/>Auth / Rate Limit / Routing]
    end

    subgraph Application Services
        SS[Search Service]
        LS[Listing Service]
        BS[Booking Service]
        IS[Inventory Service]
        PS[Payment Service]
        NS[Notification Service]
        US[User Service]
        SIS[Supplier Integration<br/>Service]
    end

    subgraph Async Layer
        MQ[(Message Queue)]
    end

    subgraph Data Layer
        InvDB[(Inventory DB<br/>NoSQL Document Store)]
        AvDB[(Availability DB<br/>SQL)]
        BookDB[(Booking DB<br/>SQL)]
        UserDB[(User DB<br/>SQL)]
        NDB[(Notification DB<br/>NoSQL Document Store)]
        SI[(Search Index)]
        Cache[(Cache<br/>In-Memory)]
        OS[(Object Storage<br/>Images)]
    end

    subgraph External Systems
        EPP[External Payment<br/>Processor]
        GDS[Airline GDS APIs]
        HSup[Hotel Supplier APIs]
        CSup[Car Rental Supplier APIs]
        Email[Email Provider]
        PushN[Push Notification Service]
        SMSProv[SMS Provider]
    end

    CL -- "Images" --> CDN
    CDN --> OS
    CL -- "HTTPS" --> GLB
    GLB --> LB1
    LB1 --> AG

    AG --> SS
    AG --> LS
    AG --> BS
    AG --> NS
    AG --> US

    SS --> Cache
    SS --> SI
    SS --> SIS
    SI --> InvDB
    LS --> InvDB
    LS --> Cache

    SIS --> GDS
    SIS --> HSup
    SIS --> CSup

    BS --> IS
    BS --> PS
    BS --> BookDB
    BS --> MQ

    IS --> AvDB
    PS --> EPP
    PS --> BookDB

    US --> UserDB

    MQ --> NS
    NS --> NDB
    NS --> Email
    NS --> PushN
    NS --> SMSProv
</div>

<h3>7.1 Combined Flow Examples</h3>

<div class="example">
<strong>Example 1 ‚Äî Complete End-to-End Hotel Booking Journey:</strong><br/>
<strong>Step 1 (Search):</strong> User opens the Expedia app, which loads static assets and UI images from the <strong>CDN</strong>. User searches "Paris, May 1‚Äì5, 2 guests." The HTTPS GET request travels through the <strong>Global Load Balancer ‚Üí Regional Load Balancer ‚Üí API Gateway ‚Üí Search Service</strong>. The Search Service checks the <strong>Cache</strong> (miss), queries the <strong>Search Index</strong>, fetches enriched data from the <strong>Listing Service</strong> (which reads from <strong>Inventory DB</strong>), and returns 40 hotel results. Results are cached.<br/><br/>
<strong>Step 2 (View Details):</strong> User taps "Hotel Le Marais." The app sends GET <code>/api/v1/hotels/htl_456</code>. The <strong>Listing Service</strong> checks the <strong>Cache</strong> (hit) and returns the full hotel document. Hotel photos load from the <strong>CDN</strong>.<br/><br/>
<strong>Step 3 (Book):</strong> User selects a Superior Room and clicks "Book Now." POST <code>/api/v1/bookings</code> flows through the gateway to the <strong>Booking Service</strong>, which calls the <strong>Inventory Service</strong> (locks the room in <strong>Availability DB</strong>), creates a pending booking in <strong>Booking DB</strong>, calls the <strong>Payment Service</strong> (charges $800 via <strong>External Payment Processor</strong>), confirms the booking, and publishes <code>booking_confirmed</code> to the <strong>Message Queue</strong>.<br/><br/>
<strong>Step 4 (Notification):</strong> The <strong>Notification Service</strong> consumes the event from the <strong>Message Queue</strong>, sends a confirmation email via the <strong>Email Provider</strong>, sends a push notification via the <strong>Push Notification Service</strong>, and stores the notification in the <strong>Notification DB</strong>.
</div>

<div class="example">
<strong>Example 2 ‚Äî Search, Book Package, Then Cancel:</strong><br/>
<strong>Search:</strong> User searches flights "SFO ‚Üí CDG, May 1" and hotels "Paris, May 1‚Äì5." Two parallel search requests go to the <strong>Search Service</strong>. Flight search fans out to <strong>Supplier Integration Service ‚Üí GDS APIs</strong>. Hotel search hits the <strong>Search Index</strong>.<br/>
<strong>Book Package:</strong> User selects a flight + hotel package. The <strong>Booking Service</strong> uses the <strong>Saga Pattern</strong>: reserves flight seat via <strong>Inventory Service ‚Üí Availability DB</strong>, reserves hotel room, processes combined payment of $2,400 via <strong>Payment Service ‚Üí External Payment Processor</strong>. Both bookings confirmed. Events published to <strong>Message Queue</strong>.<br/>
<strong>Cancel (2 weeks later):</strong> User cancels the package. PATCH request goes to <strong>Booking Service</strong>, which checks the cancellation policy, processes a $2,200 refund (flight penalty $200) via <strong>Payment Service</strong>, releases both the flight seat and hotel room via <strong>Inventory Service ‚Üí Availability DB</strong>, publishes <code>booking_cancelled</code> event. <strong>Notification Service</strong> sends cancellation email and push notification.
</div>

<!-- ================================================================== -->
<h2 id="schema">8. Database Schema</h2>
<!-- ================================================================== -->

<h3>8.1 SQL Tables</h3>
<p>SQL databases are used for data requiring <strong>ACID transactions</strong>, <strong>referential integrity</strong>, and <strong>strong consistency</strong> ‚Äî specifically bookings, payments, user accounts, and inventory availability.</p>

<!-- USERS TABLE -->
<h4>Table: <code>users</code></h4>
<div class="card">
<table>
    <tr><th>Column</th><th>Type</th><th>Constraints</th><th>Description</th></tr>
    <tr><td><code>user_id</code></td><td>UUID</td><td><strong>PRIMARY KEY</strong></td><td>Unique user identifier</td></tr>
    <tr><td><code>email</code></td><td>VARCHAR(255)</td><td>UNIQUE, NOT NULL</td><td>User email (login identifier)</td></tr>
    <tr><td><code>password_hash</code></td><td>VARCHAR(255)</td><td>NOT NULL</td><td>Bcrypt-hashed password</td></tr>
    <tr><td><code>first_name</code></td><td>VARCHAR(100)</td><td>NOT NULL</td><td>User first name</td></tr>
    <tr><td><code>last_name</code></td><td>VARCHAR(100)</td><td>NOT NULL</td><td>User last name</td></tr>
    <tr><td><code>phone_number</code></td><td>VARCHAR(20)</td><td>NULLABLE</td><td>User phone number</td></tr>
    <tr><td><code>notification_prefs</code></td><td>JSONB</td><td>DEFAULT '{}'</td><td>Email/push/SMS preferences</td></tr>
    <tr><td><code>created_at</code></td><td>TIMESTAMP</td><td>NOT NULL</td><td>Account creation time</td></tr>
    <tr><td><code>updated_at</code></td><td>TIMESTAMP</td><td>NOT NULL</td><td>Last profile update</td></tr>
</table>

<p><strong>Why SQL:</strong> User data is highly structured and relational. Referential integrity is needed since bookings, payments, and notifications all reference users. User registration and login require strong consistency (can't have duplicate accounts).</p>
<p><strong>Indexes:</strong></p>
<ul>
    <li><strong>Hash index</strong> on <code>email</code> ‚Äî Used for O(1) lookups during login. Hash is ideal because login queries are always exact-match equality checks (<code>WHERE email = ?</code>), never range queries.</li>
</ul>
<p><strong>Read/Write Triggers:</strong></p>
<ul>
    <li><strong>Written to:</strong> When a user registers (POST /register), updates their profile (PATCH /profile).</li>
    <li><strong>Read from:</strong> During login (POST /login), when displaying user profile, when checking notification preferences during notification dispatch.</li>
</ul>
<p><strong>Sharding:</strong> Not recommended for the users table. With ~50M total users and mostly read-heavy, a single primary with read replicas is sufficient. If scale demands it, hash-based sharding on <code>user_id</code> would work since all user queries include the user_id.</p>
</div>

<!-- BOOKINGS TABLE -->
<h4>Table: <code>bookings</code></h4>
<div class="card">
<table>
    <tr><th>Column</th><th>Type</th><th>Constraints</th><th>Description</th></tr>
    <tr><td><code>booking_id</code></td><td>UUID</td><td><strong>PRIMARY KEY</strong></td><td>Unique booking identifier</td></tr>
    <tr><td><code>user_id</code></td><td>UUID</td><td><strong>FOREIGN KEY ‚Üí users.user_id</strong>, NOT NULL</td><td>The user who made the booking</td></tr>
    <tr><td><code>booking_type</code></td><td>ENUM('hotel','flight','car_rental','package')</td><td>NOT NULL</td><td>Type of booking</td></tr>
    <tr><td><code>status</code></td><td>ENUM('pending','confirmed','cancelled','completed','expired','payment_failed')</td><td>NOT NULL</td><td>Current booking status</td></tr>
    <tr><td><code>total_price</code></td><td>DECIMAL(12,2)</td><td>NOT NULL</td><td>Total price charged</td></tr>
    <tr><td><code>currency</code></td><td>CHAR(3)</td><td>NOT NULL, DEFAULT 'USD'</td><td>ISO 4217 currency code</td></tr>
    <tr><td><code>cancellation_policy</code></td><td>JSONB</td><td>NOT NULL</td><td>Snapshot of the cancellation policy at booking time</td></tr>
    <tr><td><code>guest_name</code></td><td>VARCHAR(200)</td><td>NOT NULL</td><td>Primary guest/passenger name</td></tr>
    <tr><td><code>guest_email</code></td><td>VARCHAR(255)</td><td>NOT NULL</td><td>Guest email for itinerary</td></tr>
    <tr><td><code>booked_at</code></td><td>TIMESTAMP</td><td>NOT NULL</td><td>When the booking was created</td></tr>
    <tr><td><code>updated_at</code></td><td>TIMESTAMP</td><td>NOT NULL</td><td>Last status update</td></tr>
</table>

<p><strong>Why SQL:</strong> Bookings are financial transactions requiring ACID guarantees. Referential integrity with users and payments is critical. Status transitions must be atomic.</p>
<p><strong>Indexes:</strong></p>
<ul>
    <li><strong>B-tree composite index</strong> on <code>(user_id, booked_at DESC)</code> ‚Äî Optimizes the "My Bookings" query which lists a user's bookings ordered by most recent. B-tree supports the range scan and ordering efficiently.</li>
    <li><strong>B-tree index</strong> on <code>(status, updated_at)</code> ‚Äî Used by background jobs to find pending/expired bookings for cleanup.</li>
</ul>
<p><strong>Denormalization:</strong> The <code>cancellation_policy</code> field is denormalized (snapshot of the policy at booking time) rather than referencing the listing's current policy. This is intentional: the cancellation policy that applied when the user booked must be preserved, even if the listing's policy changes later. This prevents disputes.</p>
<p><strong>Denormalization:</strong> <code>guest_name</code> and <code>guest_email</code> are denormalized from the user record. This is because a booking's guest might differ from the account holder (e.g., booking for a colleague), and the guest info at booking time must be immutable.</p>
<p><strong>Read/Write Triggers:</strong></p>
<ul>
    <li><strong>Written to:</strong> When user clicks "Book Now" (creates pending booking), on payment success (status ‚Üí confirmed), on cancellation (status ‚Üí cancelled), on trip completion (status ‚Üí completed), on hold expiration (status ‚Üí expired).</li>
    <li><strong>Read from:</strong> When user views "My Bookings," when user views a specific booking, during cancellation (to check policy), by background cleanup jobs.</li>
</ul>
<p><strong>Sharding:</strong> <strong>Hash-based sharding on <code>user_id</code></strong>. Rationale: The most common query pattern is "get bookings for a user," which means all of a user's bookings should reside on the same shard for efficient single-shard queries. Hash-based distribution ensures even data distribution across shards. The tradeoff is that admin queries across all bookings (e.g., "all bookings for hotel X") require scatter-gather across shards, but these are infrequent and can be served by an analytics replica.</p>
</div>

<!-- BOOKING_ITEMS TABLE -->
<h4>Table: <code>booking_items</code></h4>
<div class="card">
<table>
    <tr><th>Column</th><th>Type</th><th>Constraints</th><th>Description</th></tr>
    <tr><td><code>item_id</code></td><td>UUID</td><td><strong>PRIMARY KEY</strong></td><td>Unique item identifier</td></tr>
    <tr><td><code>booking_id</code></td><td>UUID</td><td><strong>FOREIGN KEY ‚Üí bookings.booking_id</strong>, NOT NULL</td><td>Parent booking</td></tr>
    <tr><td><code>listing_type</code></td><td>ENUM('hotel','flight','car_rental')</td><td>NOT NULL</td><td>Type of listing</td></tr>
    <tr><td><code>listing_id</code></td><td>VARCHAR(50)</td><td>NOT NULL</td><td>References listing in NoSQL Inventory DB</td></tr>
    <tr><td><code>listing_name</code></td><td>VARCHAR(300)</td><td>NOT NULL</td><td>Denormalized listing name at booking time</td></tr>
    <tr><td><code>details</code></td><td>JSONB</td><td>NOT NULL</td><td>Room type, seat class, car type, etc.</td></tr>
    <tr><td><code>start_date</code></td><td>DATE</td><td>NOT NULL</td><td>Check-in / departure / pickup date</td></tr>
    <tr><td><code>end_date</code></td><td>DATE</td><td>NOT NULL</td><td>Check-out / arrival / dropoff date</td></tr>
    <tr><td><code>quantity</code></td><td>INT</td><td>NOT NULL, DEFAULT 1</td><td>Number of rooms/seats/cars</td></tr>
    <tr><td><code>unit_price</code></td><td>DECIMAL(10,2)</td><td>NOT NULL</td><td>Price per unit</td></tr>
    <tr><td><code>item_status</code></td><td>ENUM('held','confirmed','cancelled')</td><td>NOT NULL</td><td>Status of this specific item</td></tr>
</table>

<p><strong>Why SQL:</strong> Needs referential integrity with the bookings table (foreign key). Part of the transactional booking flow. A package booking has multiple items that must be atomically committed or rolled back.</p>
<p><strong>Denormalization:</strong> <code>listing_name</code> is denormalized from the NoSQL Inventory DB. This is done so that booking history displays don't need to cross-query the NoSQL DB for every listing name. The listing name at booking time is preserved even if the listing is later renamed or removed.</p>
<p><strong>Indexes:</strong></p>
<ul>
    <li><strong>B-tree index</strong> on <code>booking_id</code> ‚Äî Fast lookup of all items in a booking. B-tree is used because we may query by booking_id equality and ordering doesn't matter much here.</li>
    <li><strong>B-tree composite index</strong> on <code>(listing_id, start_date, end_date)</code> ‚Äî Used by the Inventory Service when checking if a listing has existing bookings in a date range.</li>
</ul>
<p><strong>Read/Write Triggers:</strong></p>
<ul>
    <li><strong>Written to:</strong> When a booking is created (one row per item in the booking), on cancellation (item_status ‚Üí cancelled).</li>
    <li><strong>Read from:</strong> When viewing booking details, during cancellation to determine what inventory to release.</li>
</ul>
<p><strong>Sharding:</strong> Co-located with the <code>bookings</code> table ‚Äî sharded on <code>user_id</code> (derived via the booking_id ‚Üí user_id relationship). This ensures that a booking and all its items are on the same shard, enabling single-shard joins.</p>
</div>

<!-- PAYMENTS TABLE -->
<h4>Table: <code>payments</code></h4>
<div class="card">
<table>
    <tr><th>Column</th><th>Type</th><th>Constraints</th><th>Description</th></tr>
    <tr><td><code>payment_id</code></td><td>UUID</td><td><strong>PRIMARY KEY</strong></td><td>Unique payment identifier</td></tr>
    <tr><td><code>booking_id</code></td><td>UUID</td><td><strong>FOREIGN KEY ‚Üí bookings.booking_id</strong>, NOT NULL</td><td>Associated booking</td></tr>
    <tr><td><code>amount</code></td><td>DECIMAL(12,2)</td><td>NOT NULL</td><td>Amount charged or refunded</td></tr>
    <tr><td><code>currency</code></td><td>CHAR(3)</td><td>NOT NULL</td><td>ISO 4217 currency code</td></tr>
    <tr><td><code>payment_type</code></td><td>ENUM('charge','refund')</td><td>NOT NULL</td><td>Whether this is a charge or refund</td></tr>
    <tr><td><code>payment_method</code></td><td>VARCHAR(50)</td><td>NOT NULL</td><td>Tokenized payment method reference</td></tr>
    <tr><td><code>status</code></td><td>ENUM('pending','authorized','captured','declined','refunded','failed')</td><td>NOT NULL</td><td>Payment status</td></tr>
    <tr><td><code>transaction_reference</code></td><td>VARCHAR(255)</td><td>NULLABLE</td><td>External processor's transaction ID</td></tr>
    <tr><td><code>created_at</code></td><td>TIMESTAMP</td><td>NOT NULL</td><td>When payment was initiated</td></tr>
</table>

<p><strong>Why SQL:</strong> Payment records are financial data requiring ACID guarantees and auditability. Must maintain referential integrity with bookings. Payment status transitions must be atomic.</p>
<p><strong>Indexes:</strong></p>
<ul>
    <li><strong>Hash index</strong> on <code>booking_id</code> ‚Äî Fast exact-match lookup of payments for a booking. Hash is optimal because payment lookups are always by exact booking_id, never range queries.</li>
    <li><strong>B-tree index</strong> on <code>transaction_reference</code> ‚Äî Used for reconciliation with external payment processor records.</li>
</ul>
<p><strong>Read/Write Triggers:</strong></p>
<ul>
    <li><strong>Written to:</strong> When payment is initiated during booking (creates row with status=pending), on payment processor response (status ‚Üí captured/declined), on refund (new row with type=refund).</li>
    <li><strong>Read from:</strong> When viewing booking details (to show payment status), during refund processing (to find original charge), for financial reconciliation reports.</li>
</ul>
<p><strong>Sharding:</strong> Co-located with bookings ‚Äî sharded on <code>user_id</code> (derived via booking_id). Payment queries almost always go through a booking, so co-location is critical for performance.</p>
</div>

<!-- HOTEL_AVAILABILITY TABLE -->
<h4>Table: <code>hotel_availability</code></h4>
<div class="card">
<table>
    <tr><th>Column</th><th>Type</th><th>Constraints</th><th>Description</th></tr>
    <tr><td><code>listing_id</code></td><td>VARCHAR(50)</td><td><strong>PRIMARY KEY (composite)</strong></td><td>References hotel listing in NoSQL DB</td></tr>
    <tr><td><code>room_type_id</code></td><td>VARCHAR(50)</td><td><strong>PRIMARY KEY (composite)</strong></td><td>Room type identifier</td></tr>
    <tr><td><code>date</code></td><td>DATE</td><td><strong>PRIMARY KEY (composite)</strong></td><td>The specific date</td></tr>
    <tr><td><code>total_rooms</code></td><td>INT</td><td>NOT NULL</td><td>Total rooms of this type</td></tr>
    <tr><td><code>booked_rooms</code></td><td>INT</td><td>NOT NULL, DEFAULT 0</td><td>Currently booked rooms</td></tr>
    <tr><td><code>price</code></td><td>DECIMAL(10,2)</td><td>NOT NULL</td><td>Price for this room/date (dynamic)</td></tr>
    <tr><td><code>updated_at</code></td><td>TIMESTAMP</td><td>NOT NULL</td><td>Last update time</td></tr>
</table>

<p><strong>Composite Primary Key:</strong> <code>(listing_id, room_type_id, date)</code> ‚Äî Each row represents the availability of one room type at one hotel on one specific date.</p>
<p><strong>Why SQL:</strong> This is the most critical table for preventing double-bookings. Requires row-level locking (<code>SELECT ... FOR UPDATE</code>) for concurrent booking attempts. ACID transactions ensure that decrementing availability and creating a booking happen atomically.</p>
<p><strong>Indexes:</strong></p>
<ul>
    <li><strong>B-tree composite index</strong> on <code>(listing_id, room_type_id, date)</code> ‚Äî This <em>is</em> the primary key index. B-tree is essential because availability checks always query a date <em>range</em> (e.g., "March 10 to March 15"), and B-tree supports efficient range scans on the <code>date</code> portion.</li>
</ul>
<p><strong>Read/Write Triggers:</strong></p>
<ul>
    <li><strong>Written to:</strong> When a booking is confirmed (booked_rooms incremented), when a booking is cancelled (booked_rooms decremented), when a temporary hold expires (booked_rooms decremented), when suppliers update availability or pricing.</li>
    <li><strong>Read from:</strong> During booking to check availability (SELECT ... FOR UPDATE), during search to filter out fully-booked hotels.</li>
</ul>
<p><strong>Sharding:</strong> <strong>Hash-based sharding on <code>listing_id</code></strong>. Rationale: Booking queries always target a specific hotel's availability, so all dates for one hotel should be on the same shard. This enables single-shard transactions when booking a multi-night stay. Hash distribution prevents hot shards from popular cities.</p>
</div>

<!-- FLIGHT_AVAILABILITY TABLE -->
<h4>Table: <code>flight_availability</code></h4>
<div class="card">
<table>
    <tr><th>Column</th><th>Type</th><th>Constraints</th><th>Description</th></tr>
    <tr><td><code>flight_id</code></td><td>VARCHAR(50)</td><td><strong>PRIMARY KEY (composite)</strong></td><td>References flight listing</td></tr>
    <tr><td><code>seat_class</code></td><td>ENUM('economy','premium_economy','business','first')</td><td><strong>PRIMARY KEY (composite)</strong></td><td>Seat class</td></tr>
    <tr><td><code>total_seats</code></td><td>INT</td><td>NOT NULL</td><td>Total seats in this class</td></tr>
    <tr><td><code>booked_seats</code></td><td>INT</td><td>NOT NULL, DEFAULT 0</td><td>Currently booked seats</td></tr>
    <tr><td><code>price</code></td><td>DECIMAL(10,2)</td><td>NOT NULL</td><td>Current price for this class</td></tr>
    <tr><td><code>updated_at</code></td><td>TIMESTAMP</td><td>NOT NULL</td><td>Last update</td></tr>
</table>

<p><strong>Composite Primary Key:</strong> <code>(flight_id, seat_class)</code></p>
<p><strong>Why SQL:</strong> Same as hotel_availability ‚Äî requires row-level locking and ACID for concurrent seat bookings.</p>
<p><strong>Indexes:</strong> Primary key index covers the main query pattern.</p>
<p><strong>Sharding:</strong> <strong>Hash-based sharding on <code>flight_id</code></strong>. All seat classes for a single flight are on the same shard.</p>
<p><strong>Read/Write Triggers:</strong></p>
<ul>
    <li><strong>Written to:</strong> On booking (booked_seats incremented), on cancellation (booked_seats decremented), on supplier fare updates (price updated).</li>
    <li><strong>Read from:</strong> During booking (availability check), during search (filter sold-out flights).</li>
</ul>
</div>

<!-- CAR_RENTAL_AVAILABILITY TABLE -->
<h4>Table: <code>car_rental_availability</code></h4>
<div class="card">
<table>
    <tr><th>Column</th><th>Type</th><th>Constraints</th><th>Description</th></tr>
    <tr><td><code>rental_id</code></td><td>VARCHAR(50)</td><td><strong>PRIMARY KEY (composite)</strong></td><td>References car rental listing</td></tr>
    <tr><td><code>date</code></td><td>DATE</td><td><strong>PRIMARY KEY (composite)</strong></td><td>The specific date</td></tr>
    <tr><td><code>total_cars</code></td><td>INT</td><td>NOT NULL</td><td>Total cars of this type at this location</td></tr>
    <tr><td><code>booked_cars</code></td><td>INT</td><td>NOT NULL, DEFAULT 0</td><td>Currently booked</td></tr>
    <tr><td><code>daily_price</code></td><td>DECIMAL(10,2)</td><td>NOT NULL</td><td>Price per day</td></tr>
    <tr><td><code>updated_at</code></td><td>TIMESTAMP</td><td>NOT NULL</td><td>Last update</td></tr>
</table>

<p><strong>Composite Primary Key:</strong> <code>(rental_id, date)</code></p>
<p><strong>Why SQL:</strong> Same rationale as other availability tables ‚Äî strong consistency and row-level locking.</p>
<p><strong>Sharding:</strong> <strong>Hash-based sharding on <code>rental_id</code></strong>.</p>
</div>

<!-- INVENTORY_HOLDS TABLE -->
<h4>Table: <code>inventory_holds</code></h4>
<div class="card">
<table>
    <tr><th>Column</th><th>Type</th><th>Constraints</th><th>Description</th></tr>
    <tr><td><code>hold_id</code></td><td>UUID</td><td><strong>PRIMARY KEY</strong></td><td>Unique hold identifier</td></tr>
    <tr><td><code>listing_type</code></td><td>ENUM('hotel','flight','car_rental')</td><td>NOT NULL</td><td>Type of listing being held</td></tr>
    <tr><td><code>listing_id</code></td><td>VARCHAR(50)</td><td>NOT NULL</td><td>The listing being held</td></tr>
    <tr><td><code>booking_id</code></td><td>UUID</td><td><strong>FOREIGN KEY ‚Üí bookings.booking_id</strong>, NULLABLE</td><td>Associated booking (set on confirmation)</td></tr>
    <tr><td><code>quantity</code></td><td>INT</td><td>NOT NULL</td><td>Number of units held</td></tr>
    <tr><td><code>status</code></td><td>ENUM('active','confirmed','released','expired')</td><td>NOT NULL</td><td>Hold status</td></tr>
    <tr><td><code>expires_at</code></td><td>TIMESTAMP</td><td>NOT NULL</td><td>When the hold auto-expires</td></tr>
    <tr><td><code>created_at</code></td><td>TIMESTAMP</td><td>NOT NULL</td><td>When the hold was created</td></tr>
</table>

<p><strong>Why SQL:</strong> Holds are tightly coupled with availability updates and must be transactionally consistent.</p>
<p><strong>Indexes:</strong></p>
<ul>
    <li><strong>B-tree composite index</strong> on <code>(status, expires_at)</code> ‚Äî Used by the Hold Cleanup Job to efficiently find expired holds: <code>WHERE status = 'active' AND expires_at &lt; NOW()</code>. B-tree is ideal because this is a range query on <code>expires_at</code>.</li>
    <li><strong>Hash index</strong> on <code>listing_id</code> ‚Äî Fast lookup of all active holds for a listing.</li>
</ul>
<p><strong>Read/Write Triggers:</strong></p>
<ul>
    <li><strong>Written to:</strong> When a booking begins (creates active hold), on payment success (status ‚Üí confirmed), on payment failure (status ‚Üí released), on expiration (status ‚Üí expired by cleanup job).</li>
    <li><strong>Read from:</strong> By the Hold Cleanup Job (every 60 seconds), during booking to check for existing holds.</li>
</ul>
</div>

<hr style="margin:2rem 0;">

<h3>8.2 NoSQL Document Store Tables</h3>
<p>NoSQL document stores are used for data with <strong>flexible schemas</strong>, <strong>high read volume</strong>, and where <strong>eventual consistency</strong> is acceptable.</p>

<!-- HOTEL_LISTINGS TABLE -->
<h4>Table: <code>hotel_listings</code></h4>
<div class="card">
<table>
    <tr><th>Field</th><th>Type</th><th>Description</th></tr>
    <tr><td><code>listing_id</code></td><td>String</td><td><strong>Partition Key</strong>. Unique hotel identifier.</td></tr>
    <tr><td><code>name</code></td><td>String</td><td>Hotel name</td></tr>
    <tr><td><code>description</code></td><td>String</td><td>Full hotel description</td></tr>
    <tr><td><code>address</code></td><td>String</td><td>Street address</td></tr>
    <tr><td><code>city</code></td><td>String</td><td>City name</td></tr>
    <tr><td><code>country</code></td><td>String</td><td>Country</td></tr>
    <tr><td><code>latitude</code></td><td>Number</td><td>Geo coordinate</td></tr>
    <tr><td><code>longitude</code></td><td>Number</td><td>Geo coordinate</td></tr>
    <tr><td><code>star_rating</code></td><td>Number</td><td>1‚Äì5 star rating</td></tr>
    <tr><td><code>amenities</code></td><td>Array&lt;String&gt;</td><td>["pool", "wifi", "gym", "spa", ...]</td></tr>
    <tr><td><code>images</code></td><td>Array&lt;Object&gt;</td><td>[{ url, caption, order }]</td></tr>
    <tr><td><code>room_types</code></td><td>Array&lt;Object&gt;</td><td>[{ id, name, capacity, base_price, description, images }]</td></tr>
    <tr><td><code>policies</code></td><td>Object</td><td>{ cancellation, check_in_time, check_out_time }</td></tr>
    <tr><td><code>supplier_id</code></td><td>String</td><td>The supplier/chain that manages this hotel</td></tr>
    <tr><td><code>avg_rating</code></td><td>Number</td><td>Average user review rating (denormalized)</td></tr>
    <tr><td><code>review_count</code></td><td>Number</td><td>Total review count (denormalized)</td></tr>
    <tr><td><code>created_at</code></td><td>Timestamp</td><td>When listing was added</td></tr>
    <tr><td><code>updated_at</code></td><td>Timestamp</td><td>Last update</td></tr>
</table>

<p><strong>Why NoSQL Document Store:</strong> Hotels have highly variable attributes ‚Äî a boutique hotel in Bali might have "rice paddy view" as an amenity while a business hotel in NYC has "meeting rooms." Room types vary in number and structure. A document store naturally accommodates this flexible, nested schema without NULL-heavy sparse columns or complex join tables. Read volume is very high (millions of search results displayed daily) and eventual consistency is acceptable for listing data.</p>
<p><strong>Denormalization:</strong> <code>avg_rating</code> and <code>review_count</code> are denormalized from the <code>reviews</code> collection. This avoids expensive aggregation queries on every search result render. These values are updated asynchronously when a new review is submitted (a background job recalculates and updates the listing document). The slight staleness (seconds) is acceptable for display purposes.</p>
<p><strong>Read/Write Triggers:</strong></p>
<ul>
    <li><strong>Written to:</strong> When a new hotel is onboarded by a supplier, when hotel details are updated (photos, description, pricing), when avg_rating is recalculated after a new review.</li>
    <li><strong>Read from:</strong> During search (via the Search Index, which is synced from this collection), when viewing hotel detail pages.</li>
</ul>
<p><strong>Sharding:</strong> Hash-based sharding on <code>listing_id</code>. Even distribution. Geo-based sharding was considered but rejected because users search across regions (e.g., "hotels in Europe"), making geo-sharding inefficient for cross-region queries.</p>
</div>

<!-- FLIGHT_LISTINGS TABLE -->
<h4>Table: <code>flight_listings</code></h4>
<div class="card">
<table>
    <tr><th>Field</th><th>Type</th><th>Description</th></tr>
    <tr><td><code>flight_id</code></td><td>String</td><td><strong>Partition Key</strong>. Unique flight identifier.</td></tr>
    <tr><td><code>airline</code></td><td>String</td><td>Airline name</td></tr>
    <tr><td><code>flight_number</code></td><td>String</td><td>E.g., "UA 123"</td></tr>
    <tr><td><code>departure_airport</code></td><td>String</td><td>IATA code (e.g., "SFO")</td></tr>
    <tr><td><code>arrival_airport</code></td><td>String</td><td>IATA code (e.g., "LHR")</td></tr>
    <tr><td><code>departure_time</code></td><td>Timestamp</td><td>Scheduled departure</td></tr>
    <tr><td><code>arrival_time</code></td><td>Timestamp</td><td>Scheduled arrival</td></tr>
    <tr><td><code>duration_minutes</code></td><td>Number</td><td>Total flight duration</td></tr>
    <tr><td><code>stops</code></td><td>Number</td><td>Number of stops (0 = direct)</td></tr>
    <tr><td><code>stop_details</code></td><td>Array&lt;Object&gt;</td><td>[{ airport, layover_minutes }]</td></tr>
    <tr><td><code>seat_classes</code></td><td>Array&lt;Object&gt;</td><td>[{ class, base_price, amenities }]</td></tr>
    <tr><td><code>aircraft_type</code></td><td>String</td><td>E.g., "Boeing 787"</td></tr>
    <tr><td><code>supplier_id</code></td><td>String</td><td>GDS or airline supplier</td></tr>
</table>

<p><strong>Why NoSQL:</strong> Flights have variable attributes (stop details vary, seat class amenities differ by airline). High read volume during search. Eventual consistency is fine for listing data; availability is checked separately via SQL.</p>
<p><strong>Read/Write Triggers:</strong></p>
<ul>
    <li><strong>Written to:</strong> When flight schedules are imported from GDS/airline APIs (batch and real-time updates).</li>
    <li><strong>Read from:</strong> During search (via Search Index), when viewing flight details.</li>
</ul>
</div>

<!-- CAR_RENTAL_LISTINGS TABLE -->
<h4>Table: <code>car_rental_listings</code></h4>
<div class="card">
<table>
    <tr><th>Field</th><th>Type</th><th>Description</th></tr>
    <tr><td><code>rental_id</code></td><td>String</td><td><strong>Partition Key</strong>. Unique rental listing identifier.</td></tr>
    <tr><td><code>company</code></td><td>String</td><td>Rental company name</td></tr>
    <tr><td><code>pickup_location</code></td><td>Object</td><td>{ address, city, country, lat, lng }</td></tr>
    <tr><td><code>dropoff_locations</code></td><td>Array&lt;Object&gt;</td><td>Allowed drop-off locations</td></tr>
    <tr><td><code>car_type</code></td><td>String</td><td>E.g., "compact", "suv", "luxury"</td></tr>
    <tr><td><code>car_model</code></td><td>String</td><td>E.g., "Toyota Corolla or similar"</td></tr>
    <tr><td><code>features</code></td><td>Array&lt;String&gt;</td><td>["automatic", "ac", "gps", "bluetooth"]</td></tr>
    <tr><td><code>daily_price</code></td><td>Number</td><td>Base daily rental price</td></tr>
    <tr><td><code>images</code></td><td>Array&lt;String&gt;</td><td>Image URLs</td></tr>
    <tr><td><code>supplier_id</code></td><td>String</td><td>Supplier identifier</td></tr>
</table>

<p><strong>Why NoSQL:</strong> Car rental attributes vary (different features per rental company, flexible schema needed). High read volume during search.</p>
</div>

<!-- REVIEWS TABLE -->
<h4>Table: <code>reviews</code></h4>
<div class="card">
<table>
    <tr><th>Field</th><th>Type</th><th>Description</th></tr>
    <tr><td><code>review_id</code></td><td>String</td><td><strong>Partition Key</strong>. Unique review identifier.</td></tr>
    <tr><td><code>listing_id</code></td><td>String</td><td>The listing being reviewed. <strong>Indexed (GSI / secondary index)</strong>.</td></tr>
    <tr><td><code>listing_type</code></td><td>String</td><td>"hotel", "flight", or "car_rental"</td></tr>
    <tr><td><code>user_id</code></td><td>String</td><td>Review author</td></tr>
    <tr><td><code>rating</code></td><td>Number</td><td>1‚Äì5 star rating</td></tr>
    <tr><td><code>title</code></td><td>String</td><td>Review title</td></tr>
    <tr><td><code>body</code></td><td>String</td><td>Review body text</td></tr>
    <tr><td><code>images</code></td><td>Array&lt;String&gt;</td><td>User-uploaded review photos</td></tr>
    <tr><td><code>helpful_count</code></td><td>Number</td><td>Number of "helpful" votes</td></tr>
    <tr><td><code>created_at</code></td><td>Timestamp</td><td>When review was posted</td></tr>
</table>

<p><strong>Why NoSQL:</strong> Reviews are write-heavy (many users submit reviews), read in bulk for a listing (simple access pattern: get all reviews for listing_id, sorted by date), have flexible content (some include images, some don't), and don't require joins. Eventual consistency is acceptable ‚Äî a review appearing a few seconds late is fine.</p>
<p><strong>Indexes:</strong></p>
<ul>
    <li><strong>Secondary index (GSI)</strong> on <code>(listing_id, created_at DESC)</code> ‚Äî Enables efficient query: "Get the most recent reviews for hotel X." The <code>listing_id</code> is the partition key of the index, and <code>created_at</code> is the sort key for chronological ordering.</li>
</ul>
<p><strong>Read/Write Triggers:</strong></p>
<ul>
    <li><strong>Written to:</strong> When a user submits a review after their trip (POST /listings/{id}/reviews).</li>
    <li><strong>Read from:</strong> When viewing a listing's detail page (reviews tab), when displaying review summaries in search results.</li>
</ul>
</div>

<!-- NOTIFICATIONS TABLE -->
<h4>Table: <code>notifications</code></h4>
<div class="card">
<table>
    <tr><th>Field</th><th>Type</th><th>Description</th></tr>
    <tr><td><code>notification_id</code></td><td>String</td><td><strong>Partition Key</strong>. Unique notification ID.</td></tr>
    <tr><td><code>user_id</code></td><td>String</td><td><strong>Indexed (GSI)</strong>. Recipient user.</td></tr>
    <tr><td><code>type</code></td><td>String</td><td>"booking_confirmed", "booking_cancelled", "price_alert", etc.</td></tr>
    <tr><td><code>title</code></td><td>String</td><td>Notification title</td></tr>
    <tr><td><code>body</code></td><td>String</td><td>Notification body</td></tr>
    <tr><td><code>metadata</code></td><td>Object</td><td>{ booking_id, listing_name, ... }</td></tr>
    <tr><td><code>read</code></td><td>Boolean</td><td>Whether the user has read this notification</td></tr>
    <tr><td><code>channels_sent</code></td><td>Array&lt;String&gt;</td><td>["email", "push"] ‚Äî which channels were used</td></tr>
    <tr><td><code>created_at</code></td><td>Timestamp</td><td>When notification was created</td></tr>
</table>

<p><strong>Why NoSQL:</strong> Notifications are write-heavy (every booking/cancellation/event generates notifications), read in reverse chronological order per user (simple access pattern), have varying metadata per notification type, and don't require cross-entity joins. Eventual consistency is acceptable.</p>
<p><strong>Indexes:</strong></p>
<ul>
    <li><strong>Secondary index (GSI)</strong> on <code>(user_id, created_at DESC)</code> ‚Äî Enables the primary query: "Get user's recent notifications, newest first."</li>
</ul>
<p><strong>Read/Write Triggers:</strong></p>
<ul>
    <li><strong>Written to:</strong> By the Notification Service when processing events from the Message Queue.</li>
    <li><strong>Read from:</strong> When user opens the notifications tab in the app (GET /notifications).</li>
</ul>
</div>

<!-- ================================================================== -->
<h2 id="cdn">9. CDN Deep Dive</h2>
<!-- ================================================================== -->
<div class="card">
<h3>Why a CDN is Appropriate</h3>
<p>Expedia serves millions of <strong>hotel photos, car images, and static assets</strong> (JS, CSS, fonts, icons) to users across the globe. These assets are:</p>
<ul>
    <li><strong>Static</strong> ‚Äî Hotel photos don't change frequently.</li>
    <li><strong>Large</strong> ‚Äî High-resolution hotel images are 500KB‚Äì2MB each; a single hotel page may load 20+ images.</li>
    <li><strong>Accessed globally</strong> ‚Äî A user in Tokyo and a user in S√£o Paulo may both view the same Paris hotel.</li>
    <li><strong>Latency-sensitive</strong> ‚Äî Slow image loading degrades user experience and reduces booking conversion rates.</li>
</ul>
<p>Without a CDN, all image requests would travel to the origin Object Storage, adding 100‚Äì300ms of latency for distant users. A CDN reduces this to &lt;30ms by serving from the nearest edge location.</p>

<h3>What the CDN Serves</h3>
<ul>
    <li>Hotel listing photos</li>
    <li>Car rental images</li>
    <li>User-uploaded review photos</li>
    <li>Static web assets (JS bundles, CSS, fonts, logo)</li>
    <li>Marketing/promotional banner images</li>
</ul>

<h3>CDN Strategy: Pull-Based</h3>
<p>The CDN operates in <strong>pull-based</strong> mode:</p>
<ol>
    <li>When a user requests an image URL (e.g., <code>https://cdn.expedia.com/images/hotels/htl_123/room1.jpg</code>), the request goes to the nearest CDN edge.</li>
    <li>If the edge has the image cached ‚Üí serve immediately (cache hit).</li>
    <li>If not ‚Üí the edge pulls the image from the <strong>origin (Object Storage)</strong>, caches it, and serves it.</li>
</ol>
<p>Pull-based is chosen over push-based because the catalog is massive (millions of images), and not all images are frequently accessed. Pull ensures only popular images consume CDN cache space.</p>

<h3>CDN Cache Settings</h3>
<table>
    <tr><th>Setting</th><th>Value</th><th>Rationale</th></tr>
    <tr><td>TTL (Hotel Images)</td><td>30 days</td><td>Hotel photos rarely change; long TTL maximizes cache hit ratio.</td></tr>
    <tr><td>TTL (Static Assets)</td><td>1 year (with cache-busting hashes)</td><td>JS/CSS files use content-hashed filenames; old versions are never requested.</td></tr>
    <tr><td>TTL (Review Photos)</td><td>7 days</td><td>Review photos are immutable once uploaded but accessed less frequently.</td></tr>
    <tr><td>Eviction Policy</td><td>LRU (Least Recently Used)</td><td>Evicts the least-accessed images when edge storage is full, keeping popular hotel photos in cache.</td></tr>
    <tr><td>Cache Invalidation</td><td>URL-based purge API</td><td>When a hotel updates its photos, the Listing Service calls the CDN purge API for the old image URLs.</td></tr>
</table>

<h3>What the CDN Does NOT Serve</h3>
<p>Dynamic, personalized data (search results, booking details, user profiles, availability) is <strong>not served through the CDN</strong> because it changes per request and per user. These go through the API Gateway and backend services.</p>
</div>

<!-- ================================================================== -->
<h2 id="cache">10. Cache Deep Dive</h2>
<!-- ================================================================== -->
<div class="card">
<h3>Why an In-Memory Cache is Appropriate</h3>
<p>Expedia's search queries are the highest-volume operation (10M+ daily). Many users search for the same destinations on the same dates (e.g., "NYC hotels, Dec 24‚Äì31"). Without caching, every search would query the Search Index and potentially the Inventory DB, creating enormous read load. An in-memory cache dramatically reduces latency and backend load.</p>

<h3>Cache Layers</h3>

<h4>Layer 1: Search Results Cache</h4>
<table>
    <tr><th>Property</th><th>Value</th><th>Rationale</th></tr>
    <tr><td>Caching Strategy</td><td><strong>Cache-Aside (Lazy Loading)</strong></td><td>The Search Service checks the cache before querying the Search Index. On a miss, results are fetched from the index and written to the cache. Cache-aside is chosen because not all possible search queries can be pre-populated ‚Äî the search space is too large. Only actually-requested queries are cached.</td></tr>
    <tr><td>Cache Key</td><td>Hash of normalized query parameters</td><td>E.g., <code>SHA256("hotels:city=new_york:checkin=2026-03-10:checkout=2026-03-15:guests=2:sort=price:page=1")</code></td></tr>
    <tr><td>TTL (Expiration)</td><td><strong>5 minutes</strong></td><td>Travel prices and availability change frequently. A 5-minute TTL balances freshness with cache hit ratio. Longer TTLs would show stale prices; shorter TTLs would reduce effectiveness.</td></tr>
    <tr><td>Eviction Policy</td><td><strong>LRU (Least Recently Used)</strong></td><td>Evicts least-recently-accessed search results when memory is full. This keeps popular searches (trending destinations) cached while dropping one-off searches.</td></tr>
    <tr><td>Populated By</td><td>Search Service on cache miss</td><td>After querying the Search Index, the Search Service writes results to the cache with the 5-min TTL.</td></tr>
    <tr><td>Invalidated By</td><td>TTL expiration only (no active invalidation)</td><td>Search results are naturally invalidated by TTL. Active invalidation on every availability change would be too expensive and complex given the volume of changes.</td></tr>
</table>

<h4>Layer 2: Listing Details Cache</h4>
<table>
    <tr><th>Property</th><th>Value</th><th>Rationale</th></tr>
    <tr><td>Caching Strategy</td><td><strong>Write-Through + Cache-Aside</strong></td><td>When a listing is updated (e.g., new photos, description change), the Listing Service writes to both the Inventory DB and the cache simultaneously (write-through). On a read miss, the cache is populated from the DB (cache-aside). Write-through ensures that detail pages always show the latest data without waiting for TTL expiration.</td></tr>
    <tr><td>Cache Key</td><td><code>listing:{listing_id}</code></td><td>E.g., <code>listing:htl_123</code></td></tr>
    <tr><td>TTL (Expiration)</td><td><strong>1 hour</strong></td><td>Listing details change less frequently than prices. 1-hour TTL acts as a safety net in case a write-through update fails.</td></tr>
    <tr><td>Eviction Policy</td><td><strong>LRU</strong></td><td>Popular listings (trending hotels, popular airlines) stay cached; rarely viewed listings are evicted.</td></tr>
    <tr><td>Populated By</td><td>Listing Service on write (write-through) and on read miss (cache-aside)</td><td></td></tr>
</table>

<h4>Layer 3: Session Cache</h4>
<table>
    <tr><th>Property</th><th>Value</th><th>Rationale</th></tr>
    <tr><td>Caching Strategy</td><td><strong>Write-Through</strong></td><td>User sessions are stored in the cache on login and updated on each request (refresh token expiry). If the cache node fails, the user simply re-authenticates.</td></tr>
    <tr><td>TTL (Expiration)</td><td><strong>30 minutes</strong></td><td>Sessions expire after 30 minutes of inactivity for security. Active sessions have their TTL refreshed on each request.</td></tr>
    <tr><td>Eviction Policy</td><td><strong>TTL-based</strong> (no LRU needed ‚Äî TTL naturally cleans up)</td><td>Sessions are small and numerous; TTL is the primary cleanup mechanism.</td></tr>
</table>

<h3>Why NOT Write-Behind (Write-Back) for Search Cache?</h3>
<p>Write-behind would involve writing to the cache first and asynchronously writing to the database. This is inappropriate for search results because the search results are <em>derived data</em> (computed from the Search Index), not a source of truth. There's nothing to "write back" to the database. Cache-aside is the correct pattern for derived/computed data.</p>
</div>

<!-- ================================================================== -->
<h2 id="mq">11. Message Queue Deep Dive</h2>
<!-- ================================================================== -->
<div class="card">
<h3>Why a Message Queue?</h3>
<p>The Booking Service needs to trigger multiple downstream actions after a booking is confirmed or cancelled: send notifications (email, push, SMS), confirm with suppliers, update analytics, etc. These actions are:</p>
<ul>
    <li><strong>Non-blocking</strong> ‚Äî The user shouldn't wait for the email to send before seeing their confirmation page.</li>
    <li><strong>Independently failable</strong> ‚Äî A notification failure shouldn't fail the booking.</li>
    <li><strong>Retriable</strong> ‚Äî If the email provider is temporarily down, the message should be retried, not lost.</li>
</ul>
<p>A message queue provides <strong>decoupling</strong>, <strong>durability</strong>, <strong>guaranteed delivery</strong>, and <strong>retry semantics</strong>.</p>

<h3>Why Not Alternatives?</h3>
<table>
    <tr><th>Alternative</th><th>Why Not Chosen</th></tr>
    <tr><td><strong>Direct synchronous HTTP calls</strong></td><td>The Booking Service would need to wait for the Notification Service to finish sending emails before responding to the user. If the email provider is slow (3+ seconds), the booking response is delayed. If it fails, the booking response fails ‚Äî even though the booking itself succeeded. Tight coupling.</td></tr>
    <tr><td><strong>Pub/Sub</strong></td><td>Pub/sub could work for fan-out (one event ‚Üí multiple consumers). However, basic pub/sub lacks message durability ‚Äî if a consumer is down when the message is published, the message is lost. A durable message queue with topic-based routing provides the fan-out capability of pub/sub <em>plus</em> guaranteed delivery and persistence. For this design, a message queue with topics is sufficient and simpler to operate.</td></tr>
    <tr><td><strong>Webhooks</strong></td><td>Webhooks are HTTP-based and don't provide built-in retry, dead-letter queue, or ordering guarantees. They also require the receiver to be always available.</td></tr>
    <tr><td><strong>Polling</strong></td><td>Consumers polling a database table for new events is wasteful (constant empty queries) and adds latency compared to push-based message delivery.</td></tr>
</table>

<h3>How Messages Are Produced and Consumed</h3>
<h4>Producing Messages</h4>
<p>The <strong>Booking Service</strong> publishes messages to the queue after completing a booking, cancellation, or modification. Messages are produced using a <strong>TCP connection</strong> to the message queue broker. Each message includes:</p>
<pre>
{
  "event_type": "booking_confirmed",
  "booking_id": "BK-789012",
  "user_id": "u_123",
  "booking_type": "hotel",
  "details": {
    "hotel_name": "Grand Tokyo Hotel",
    "check_in": "2026-03-10",
    "check_out": "2026-03-15",
    "total_price": 1200,
    "currency": "USD"
  },
  "timestamp": "2026-02-13T18:30:00Z"
}
</pre>
<p>The message is published to a <strong>topic</strong> (e.g., <code>booking-events</code>). The message queue persists the message to disk for durability.</p>

<h4>Consuming Messages</h4>
<p>Multiple <strong>consumer groups</strong> subscribe to the <code>booking-events</code> topic:</p>
<ul>
    <li><strong>Notification Consumer Group</strong> ‚Äî Notification Service instances consume messages and dispatch emails/push/SMS.</li>
    <li><strong>Supplier Confirmation Consumer Group</strong> ‚Äî Confirms bookings with external suppliers.</li>
    <li><strong>Analytics Consumer Group</strong> ‚Äî Streams booking events to an analytics pipeline.</li>
</ul>
<p>Each consumer group receives a copy of every message (fan-out). Within a group, messages are distributed across consumer instances (load balancing). Messages are acknowledged after successful processing. If processing fails, the message is <strong>retried with exponential backoff</strong> (1s, 2s, 4s, 8s, ...) up to 5 attempts. After 5 failures, the message is moved to a <strong>Dead Letter Queue (DLQ)</strong> for manual investigation.</p>

<h3>Message Ordering and Idempotency</h3>
<p>Messages for the same booking are ordered (using <code>booking_id</code> as the partition key within the topic). This ensures that a <code>booking_confirmed</code> event is processed before a <code>booking_cancelled</code> event for the same booking. Consumers are designed to be <strong>idempotent</strong> ‚Äî processing the same message twice produces the same result (e.g., sending a duplicate confirmation email is prevented by checking a <code>processed_events</code> table keyed by event ID).</p>
</div>

<!-- ================================================================== -->
<h2 id="scaling">12. Scaling Considerations &amp; Load Balancers</h2>
<!-- ================================================================== -->
<div class="card">

<h3>12.1 Load Balancer Deep Dive</h3>

<h4>Where Load Balancers Are Placed</h4>
<ol>
    <li><strong>Global Load Balancer (DNS-based)</strong> ‚Äî Between users and regional clusters. Routes users to the nearest data center based on geographic proximity (geo-routing). If one region is down, traffic is rerouted to the next closest healthy region (failover).</li>
    <li><strong>Regional Load Balancer (L7)</strong> ‚Äî Between the Global LB and multiple API Gateway instances within a region. Operates at Layer 7 (HTTP), enabling path-based routing (e.g., <code>/api/v1/search/*</code> ‚Üí Search cluster, <code>/api/v1/bookings/*</code> ‚Üí Booking cluster) if needed.</li>
    <li><strong>Internal Load Balancers</strong> ‚Äî Between the API Gateway and each microservice (Search, Booking, Payment, Notification, etc.). These are service-mesh-level load balancers that distribute requests across service instances.</li>
</ol>

<h4>Load Balancing Strategy</h4>
<table>
    <tr><th>Location</th><th>Strategy</th><th>Rationale</th></tr>
    <tr><td>Global LB</td><td>Geo-based routing with failover</td><td>Minimize latency by directing to nearest region.</td></tr>
    <tr><td>Regional LB</td><td>Least Connections</td><td>Prevents overloading slow instances. If one API Gateway is handling many long-running requests, new requests go to less-loaded instances.</td></tr>
    <tr><td>Internal LBs</td><td>Round Robin</td><td>Microservice instances are stateless and homogeneous; simple round-robin provides even distribution.</td></tr>
</table>

<h4>Health Checks</h4>
<p>All load balancers perform <strong>active health checks</strong> every 5 seconds via HTTP GET <code>/health</code> on each backend instance. If an instance fails 3 consecutive checks, it is removed from the rotation. When it passes 2 consecutive checks again, it's re-added.</p>

<h3>12.2 Horizontal Scaling</h3>
<table>
    <tr><th>Component</th><th>Scaling Strategy</th><th>Details</th></tr>
    <tr><td>API Gateway</td><td>Horizontal auto-scaling</td><td>Stateless; scale based on request rate (e.g., scale up at &gt;80% CPU or &gt;5000 req/s per instance).</td></tr>
    <tr><td>Search Service</td><td>Horizontal auto-scaling</td><td>Most heavily loaded service. Scale based on request rate and latency. During peak travel booking season (Dec, Jun), pre-scale by 2‚Äì3x.</td></tr>
    <tr><td>Booking Service</td><td>Horizontal auto-scaling</td><td>Scale based on booking request rate. More moderate than search since bookings are ~100x less frequent than searches.</td></tr>
    <tr><td>Notification Service</td><td>Horizontal auto-scaling</td><td>Scale based on message queue depth. If queue depth grows, add consumers.</td></tr>
    <tr><td>Search Index</td><td>Horizontal sharding + replicas</td><td>Shard by geography or listing type. Each shard has replicas for read scalability. Can handle millions of queries per second.</td></tr>
    <tr><td>Availability DB (SQL)</td><td>Read replicas + sharding</td><td>Read replicas for search availability checks (eventual consistency OK). Writes go to primary shards. Sharded by listing_id.</td></tr>
    <tr><td>Booking DB (SQL)</td><td>Read replicas + sharding</td><td>Sharded by user_id. Read replicas for booking history queries.</td></tr>
    <tr><td>Inventory DB (NoSQL)</td><td>Horizontal sharding</td><td>Sharded by listing_id. NoSQL natively scales horizontally.</td></tr>
    <tr><td>Cache</td><td>Clustered mode</td><td>Data partitioned across multiple cache nodes using consistent hashing. Add nodes to scale memory capacity.</td></tr>
    <tr><td>Message Queue</td><td>Partitioned topics</td><td>Topics are partitioned; add partitions and consumer instances to scale throughput.</td></tr>
</table>

<h3>12.3 Handling Traffic Spikes</h3>
<ul>
    <li><strong>Seasonal pre-scaling:</strong> Historical data predicts traffic spikes (holiday booking season, summer vacation planning). Services are pre-scaled 2 weeks before expected spikes.</li>
    <li><strong>Rate limiting:</strong> The API Gateway enforces per-user rate limits (100 searches/min, 10 bookings/min) to prevent abuse or bot traffic from overwhelming the system.</li>
    <li><strong>Circuit breakers:</strong> If a downstream service (e.g., a supplier API) becomes slow or unresponsive, circuit breakers trip and return cached/degraded results rather than cascading the failure.</li>
    <li><strong>Graceful degradation:</strong> If the Search Index is overwhelmed, the system can fall back to serving cached results with a "prices may not be current" disclaimer rather than returning errors.</li>
</ul>

<h3>12.4 Database Scaling Summary</h3>
<table>
    <tr><th>Database</th><th>Scaling Approach</th></tr>
    <tr><td>Users (SQL)</td><td>Single primary + read replicas. Unlikely to need sharding (&lt;100M rows).</td></tr>
    <tr><td>Bookings (SQL)</td><td>Hash-sharded on user_id. Each shard has a primary + 2 read replicas.</td></tr>
    <tr><td>Availability (SQL)</td><td>Hash-sharded on listing_id. Each shard has a primary (writes) + 2 read replicas (search reads).</td></tr>
    <tr><td>Inventory (NoSQL)</td><td>Hash-sharded on listing_id. NoSQL auto-scales horizontally.</td></tr>
    <tr><td>Notifications (NoSQL)</td><td>Hash-sharded on user_id (partition key). High write throughput.</td></tr>
    <tr><td>Reviews (NoSQL)</td><td>Hash-sharded on review_id. Secondary index on listing_id.</td></tr>
</table>
</div>

<!-- ================================================================== -->
<h2 id="tradeoffs">13. Tradeoffs &amp; Deep Dives</h2>
<!-- ================================================================== -->
<div class="card">

<h4>1. Consistency vs. Availability in Search Results</h4>
<p><strong>Tradeoff:</strong> Search results use eventual consistency (cached for 5 minutes). A hotel might show as available in search results but be fully booked by the time the user tries to book.</p>
<p><strong>Decision:</strong> This is acceptable because availability is always re-checked at booking time with strong consistency. Showing slightly stale search results is far better than making every search query hit the primary SQL database. The booking flow guarantees correctness.</p>

<h4>2. Price Accuracy vs. Search Latency</h4>
<p><strong>Tradeoff:</strong> Real-time pricing from suppliers takes 1‚Äì3 seconds per supplier. Showing real-time prices on every search result makes search unacceptably slow.</p>
<p><strong>Decision:</strong> Show <em>estimated</em> prices (from the Search Index, synced every few minutes) in search results, and show the <em>exact real-time price</em> only on the detail page and at booking time. A "prices may have changed" disclaimer is shown if the cached price differs from the real-time price.</p>

<h4>3. Pessimistic vs. Optimistic Locking for Inventory</h4>
<p><strong>Tradeoff:</strong> Pessimistic locking (<code>SELECT ... FOR UPDATE</code>) blocks concurrent transactions but guarantees no double-booking. Optimistic locking (version numbers) allows more concurrency but requires retry logic.</p>
<p><strong>Decision:</strong> Pessimistic locking is chosen because hotel rooms and flight seats have <em>very low inventory</em> (e.g., 1 room left), making contention likely. In low-inventory scenarios, optimistic locking would cause frequent retries, degrading user experience. The lock duration is short (milliseconds) since the availability check is fast.</p>

<h4>4. Monolithic vs. Microservices</h4>
<p><strong>Tradeoff:</strong> Microservices add operational complexity (service discovery, distributed tracing, network latency) but enable independent scaling and deployment.</p>
<p><strong>Decision:</strong> Microservices are chosen because search and booking have fundamentally different scaling profiles: search is 100x more frequent than bookings. With a monolith, scaling for search would over-provision booking resources. Independent deployment also enables the search team to release features without risking the payment flow.</p>

<h4>5. Saga Pattern vs. Two-Phase Commit for Package Bookings</h4>
<p><strong>Tradeoff:</strong> Two-Phase Commit (2PC) provides atomicity across services but is slow, blocking, and fragile (coordinator is a single point of failure). Saga provides eventual consistency with compensating transactions but requires careful rollback logic.</p>
<p><strong>Decision:</strong> Saga Pattern is chosen because 2PC doesn't scale well across independent microservices and external supplier APIs (which don't support 2PC). The Saga's compensating transactions (e.g., release flight seat if hotel booking fails) are straightforward and match the business domain's natural cancel/refund operations.</p>

<h4>6. Temporary Hold Duration</h4>
<p><strong>Tradeoff:</strong> Short holds (2 min) reduce inventory lock-up but give users less time to complete checkout. Long holds (30 min) give users more time but block inventory from other buyers.</p>
<p><strong>Decision:</strong> 10-minute hold is a compromise. It gives users enough time to enter payment details and complete the booking, while not locking up inventory for too long. The Hold Cleanup Job runs every 60 seconds to release expired holds promptly.</p>

<h4>7. Denormalization in Booking Records</h4>
<p><strong>Tradeoff:</strong> Denormalizing listing_name, guest_name, and cancellation_policy into the bookings/booking_items tables introduces data duplication. If a hotel renames itself, old booking records still show the old name.</p>
<p><strong>Decision:</strong> Denormalization is correct here. Booking records must be <em>immutable snapshots</em> of what was booked at the time. The cancellation policy that was in effect when the user booked must be preserved for legal and dispute-resolution purposes. The listing name must match what the user saw when they booked. This is intentional, not accidental denormalization.</p>
</div>

<!-- ================================================================== -->
<h2 id="alternatives">14. Alternative Approaches</h2>
<!-- ================================================================== -->
<div class="card">

<h4>1. GraphQL Instead of REST</h4>
<p><strong>Approach:</strong> Expose a single GraphQL endpoint that lets clients request exactly the fields they need, reducing over-fetching.</p>
<p><strong>Why Not Chosen:</strong> REST is simpler to cache (HTTP caching headers work out-of-the-box with CDNs and proxies; GraphQL POST requests are not cacheable by default). REST is also easier to rate-limit at the endpoint level. For a travel platform where search response shapes are fairly predictable, REST's simplicity outweighs GraphQL's flexibility. However, GraphQL could be valuable for mobile clients that need to minimize data transfer ‚Äî it could be introduced as an additional layer on top of the REST microservices.</p>

<h4>2. CQRS (Command Query Responsibility Segregation)</h4>
<p><strong>Approach:</strong> Separate the read model (optimized for search/display) from the write model (optimized for bookings/updates) entirely, using event sourcing to keep them synchronized.</p>
<p><strong>Why Not Chosen:</strong> The current design already achieves a practical form of CQRS: reads go through the Search Index + Cache (read-optimized), writes go through the SQL databases (write-optimized). Full CQRS with event sourcing adds significant complexity (event store, projection rebuilding, eventual consistency handling) without proportional benefit for this use case. The simpler approach of separate read replicas and a search index achieves similar benefits.</p>

<h4>3. Event Sourcing for Bookings</h4>
<p><strong>Approach:</strong> Instead of storing the current booking state, store a sequence of events (BookingCreated, PaymentProcessed, BookingConfirmed, BookingCancelled) and derive the current state by replaying events.</p>
<p><strong>Why Not Chosen:</strong> Event sourcing provides a full audit trail and enables time-travel queries. However, bookings have simple, linear state transitions (pending ‚Üí confirmed ‚Üí completed/cancelled) that don't benefit from event replay. A simple <code>status</code> column with an <code>updated_at</code> timestamp, plus an audit log table, provides sufficient auditability without the complexity of event sourcing.</p>

<h4>4. WebSockets for Booking Status Updates</h4>
<p><strong>Approach:</strong> After initiating a booking, maintain a WebSocket connection to receive real-time status updates (payment processing ‚Üí confirmed).</p>
<p><strong>Why Not Chosen:</strong> Booking confirmation typically completes within 2‚Äì5 seconds. The overhead of establishing a WebSocket connection (TCP handshake, WebSocket upgrade, maintaining connection state in a connection registry, handling reconnections) is disproportionate for such a short-lived interaction. A simple synchronous HTTP response that returns the confirmation once payment is processed is cleaner and simpler. For the rare case of multi-supplier package bookings that take longer, <strong>HTTP long-polling</strong> (client sends a GET /bookings/{id}/status request with a long timeout; server holds the connection until status changes or timeout) is a simpler alternative that doesn't require persistent connection infrastructure.</p>

<h4>5. Server-Sent Events (SSE) for Real-Time Price Updates</h4>
<p><strong>Approach:</strong> While a user views search results, push price updates via SSE as availability changes.</p>
<p><strong>Why Not Chosen:</strong> The volume of price changes across thousands of listings would generate excessive events, overwhelming the client. It also adds server-side complexity (maintaining open connections per user). The current approach ‚Äî short TTL cache + re-fetch on interaction (clicking into a listing) ‚Äî is simpler and sufficient. Users expect to see the latest price when they click on a listing, not while scrolling through results.</p>

<h4>6. Single SQL Database for Everything</h4>
<p><strong>Approach:</strong> Use a single relational database for all data (listings, bookings, reviews, notifications) with complex joins.</p>
<p><strong>Why Not Chosen:</strong> The read and write patterns are fundamentally different across data types. Listings need flexible schemas and high read throughput (document store is ideal). Bookings need ACID transactions. Notifications need high write throughput with simple access patterns. A polyglot persistence approach (SQL for transactions, NoSQL for flexible high-volume data) matches the actual access patterns much better than forcing everything into SQL with sparse columns and expensive joins.</p>
</div>

<!-- ================================================================== -->
<h2 id="additional">15. Additional Considerations</h2>
<!-- ================================================================== -->
<div class="card">

<h4>Idempotency</h4>
<p>All booking and payment operations must be idempotent to handle retries safely. Each booking request includes a client-generated <code>idempotency_key</code>. If the same key is seen twice (e.g., user double-clicks "Book Now" or a network retry occurs), the system returns the result of the first request without processing a duplicate booking. The idempotency key is stored in the Booking DB with the booking record.</p>

<h4>Data Consistency Across Stores</h4>
<p>Since the system uses both SQL (bookings, availability) and NoSQL (listings, reviews), there's no single transaction spanning both. A change-data-capture (CDC) pipeline syncs data from the Inventory DB (NoSQL) to the Search Index. If the CDC pipeline has lag, search results may be stale. Monitoring on CDC pipeline lag ensures it stays under 30 seconds.</p>

<h4>Multi-Currency and Internationalization</h4>
<p>All prices are stored in the original currency (from the supplier). The Search Service converts prices to the user's preferred currency using a <strong>currency exchange rate table</strong> that is refreshed every hour from a financial data feed. The booking locks the price in the user's currency at booking time to prevent exchange rate fluctuations between search and payment.</p>

<h4>Fraud Detection</h4>
<p>The Payment Service calls an internal <strong>Fraud Detection Service</strong> before processing payment. This service checks for anomalies (e.g., booking from an unusual location, very high-value booking on a new account, velocity of bookings). Suspicious transactions are flagged for manual review or auto-declined.</p>

<h4>Supplier Data Freshness</h4>
<p>Hotel and car rental data is synced from suppliers via scheduled batch imports (every 6 hours for full catalog, every 15 minutes for availability/pricing updates). Flight data from GDS is refreshed in near-real-time via streaming APIs. A supplier health dashboard monitors data freshness and alerts the operations team if a supplier's data is stale.</p>

<h4>Disaster Recovery</h4>
<p>The system is deployed across at least 2 geographic regions. SQL databases use synchronous replication within a region and asynchronous replication across regions. NoSQL databases use eventual consistency with multi-region replication. In a regional failure, the Global Load Balancer redirects traffic to the surviving region. RPO (Recovery Point Objective) is &lt;1 minute for booking data; RTO (Recovery Time Objective) is &lt;5 minutes.</p>

<h4>Observability</h4>
<ul>
    <li><strong>Distributed Tracing:</strong> Every request gets a correlation ID propagated across all services. Traces are collected for latency analysis and debugging.</li>
    <li><strong>Metrics:</strong> Request rate, error rate, latency (p50, p95, p99) per service. Business metrics: search-to-booking conversion rate, payment success rate.</li>
    <li><strong>Alerting:</strong> Alerts on error rate spikes, latency breaches, queue depth growth, cache hit ratio drops, and supplier API failures.</li>
</ul>

<h4>Security</h4>
<ul>
    <li><strong>TLS everywhere:</strong> All external and internal communication is encrypted with TLS 1.3.</li>
    <li><strong>PCI-DSS compliance:</strong> The Payment Service is isolated in a separate VPC with restricted access. No raw card numbers are stored; only tokenized references.</li>
    <li><strong>API authentication:</strong> JWT-based authentication with short-lived access tokens (15 min) and refresh tokens (7 days).</li>
    <li><strong>Input validation:</strong> All API inputs are validated and sanitized to prevent injection attacks.</li>
</ul>
</div>

<!-- ================================================================== -->
<h2 id="vendors">16. Vendor Section</h2>
<!-- ================================================================== -->
<div class="card">
<p>The system is designed to be vendor-agnostic in its core architecture. Below are potential vendor choices with rationale for each category. These can be swapped without architectural changes.</p>

<table>
    <tr><th>Category</th><th>Potential Vendors</th><th>Rationale</th></tr>
    <tr>
        <td><strong>SQL Database</strong></td>
        <td>PostgreSQL, MySQL, Amazon Aurora, Google Cloud Spanner</td>
        <td>PostgreSQL is a strong default: mature, feature-rich (JSONB support, excellent indexing), and free. Cloud Spanner is an option if globally-distributed strong consistency is needed for availability tables across regions.</td>
    </tr>
    <tr>
        <td><strong>NoSQL Document Store</strong></td>
        <td>MongoDB, Amazon DynamoDB, Google Firestore, Azure Cosmos DB</td>
        <td>DynamoDB is excellent for high-throughput, low-latency document access with built-in auto-scaling and global tables. MongoDB provides richer query capabilities and flexible indexing for complex document structures like hotel listings.</td>
    </tr>
    <tr>
        <td><strong>Search Index</strong></td>
        <td>Elasticsearch, Apache Solr, Typesense, Meilisearch</td>
        <td>Elasticsearch is the industry standard for full-text search with geo-spatial support, faceted filtering, and relevance scoring ‚Äî all critical for travel search. It handles complex queries (amenity filters + price ranges + geo-proximity) efficiently.</td>
    </tr>
    <tr>
        <td><strong>In-Memory Cache</strong></td>
        <td>Redis, Memcached, Hazelcast</td>
        <td>Redis is the most versatile: supports strings (search result cache), hashes (session data), sorted sets (leaderboards), and has built-in TTL. Memcached is simpler and slightly faster for pure key-value caching if advanced data structures aren't needed.</td>
    </tr>
    <tr>
        <td><strong>Message Queue</strong></td>
        <td>Apache Kafka, RabbitMQ, Amazon SQS/SNS, Google Pub/Sub, Apache Pulsar</td>
        <td>Kafka excels at high-throughput, ordered, durable event streaming with consumer groups ‚Äî ideal for the booking event fan-out pattern. RabbitMQ is simpler for task-queue patterns with routing. Kafka is preferred for this system due to the need for ordering (by booking_id partition key) and multi-consumer fan-out.</td>
    </tr>
    <tr>
        <td><strong>Object Storage</strong></td>
        <td>Amazon S3, Google Cloud Storage, Azure Blob Storage, MinIO</td>
        <td>S3 is the de facto standard for object storage: 99.999999999% (11 nines) durability, low cost, and seamless CDN integration. Any major cloud provider's object storage is interchangeable.</td>
    </tr>
    <tr>
        <td><strong>CDN</strong></td>
        <td>Cloudflare, Amazon CloudFront, Akamai, Fastly, Google Cloud CDN</td>
        <td>Cloudflare offers a global edge network with excellent performance and DDoS protection at competitive pricing. CloudFront integrates natively with S3. Akamai has the largest edge network globally, which is valuable for a travel platform with worldwide users.</td>
    </tr>
    <tr>
        <td><strong>Payment Processor</strong></td>
        <td>Stripe, Adyen, Braintree (PayPal), Worldpay</td>
        <td>Stripe offers excellent APIs and supports 135+ currencies ‚Äî critical for an international travel platform. Adyen is widely used by large travel companies (including Expedia in reality) due to its global acquiring network and travel-specific features like split payments.</td>
    </tr>
    <tr>
        <td><strong>Email Provider</strong></td>
        <td>SendGrid, Amazon SES, Mailgun, Postmark</td>
        <td>SendGrid provides high deliverability, template management, and analytics. Amazon SES is the most cost-effective for high-volume transactional emails.</td>
    </tr>
    <tr>
        <td><strong>Push Notifications</strong></td>
        <td>Firebase Cloud Messaging (FCM), Apple Push Notification Service (APNs), OneSignal</td>
        <td>FCM (Android) and APNs (iOS) are required for native mobile push. OneSignal provides a unified abstraction layer across both platforms with segmentation and analytics.</td>
    </tr>
    <tr>
        <td><strong>Container Orchestration</strong></td>
        <td>Kubernetes, Amazon ECS, Google Cloud Run</td>
        <td>Kubernetes is the industry standard for orchestrating microservices with auto-scaling, rolling deployments, health checks, and service discovery ‚Äî all critical for the multi-service architecture described here.</td>
    </tr>
    <tr>
        <td><strong>API Gateway</strong></td>
        <td>Kong, AWS API Gateway, Envoy, Nginx, Traefik</td>
        <td>Kong provides rate limiting, authentication, request routing, and plugin extensibility. Envoy is excellent as a service mesh proxy for internal traffic. AWS API Gateway works well for simpler setups with native AWS integration.</td>
    </tr>
    <tr>
        <td><strong>Monitoring &amp; Observability</strong></td>
        <td>Datadog, Grafana + Prometheus, New Relic, Jaeger (tracing)</td>
        <td>Datadog provides unified metrics, logs, and traces in one platform. Grafana + Prometheus is the open-source alternative with excellent dashboard capabilities. Jaeger is purpose-built for distributed tracing across microservices.</td>
    </tr>
</table>
</div>

<br/>
<hr/>
<p style="text-align:center; color:var(--muted); font-size:0.9rem; margin-top:2rem;">
    <em>System Design Document ‚Äî Expedia (Travel Booking Platform) ‚Äî Generated February 2026</em>
</p>

</div><!-- end container -->
</body>
</html>
